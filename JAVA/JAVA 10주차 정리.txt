JAVA 10주차 정리

강의자료 8
메소드 오버라이딩
c2는 케이크가 가려지지만
c1은 치즈케이크 안에있는 야미가 호출된다
메소드 오버라이딩에 의해서

메소드 오버라이딩2     
cake c1 = new ChesseCake();   
인스턴스를 치즈케잌으로
하지만 데이터 타입은 cake다   

오버라이딩 된 메소드 호출하는 방법
super.yummy();
부모클래스에 있는 야미를 호출
슈퍼클래스를 이용해서 또 다른 부모 클래스에있는 걸 사용할수있다?

인스턴스 변수와 클래스 변수도 오버라이딩이 되는가?
인스턴스 변수는 오버라이딩이 되지 않는다.
따라서 참조변수의 형에 따라 접근하는 멤버가 결정된다.
클래스 변수도 당연히 안된다.


15-3. instanceof 연산자


instanceof 연산자의 기본
else if 로 바꾸자
if, else if, else 로
3개다 참이다   

instanceof 연산자의 활용
메소드 오버라이딩으로 만드는것 과제@@@!
public static void warpBox(Box box)
이 줄밑에 지우고 오버라이딩으로 만들기    


16-1. 상속이 도움이 되는 상황의 소개


단순한 인맥 관리 프로그램: 관리 대상이 둘!

두 클래스를 대상을 하는 코드

상속 기반의 문제 해결: 두 클래스 상속 관계로 묶기

상속으로 묶은 결과
이러한 클래스 디자인 기반에서 관리 대상이 넷, 다섯으로 늘어 나도
인스턴스 관리와 관련해서 코드가 복잡해지지 않는다.


16-2 Object 클래스와 final 선언 그리고 @Override

모든 클래스는 Object 클래스를 상속받는다
MyClass 는 entends Object가 자동으로 생성되어있다
다중상속은 되지않으니 간접으로 상속할수있다
Object클래스는 모든 클래스를 상속할수있다

모든 클래스가 Object를 직접 또는 간접 상속하므로

프로그래머가 정의하는 toString은 메소드 오버라이딩

클래스와 메소드의 final 선언
final을 붙이면 상속할수없다는것
오버라이딩도 안됨

@Override
상위 클래스의 메소드를 오버라이딩 하는 것이 목적이라는것을 선언!
오버라이딩을 하는 형태가 아니면 컴파일러가 오류 메세지를 전달.
쓸수도있고 안쓸수도 있다.


17-1 인터페이스의 기본과 그 의미


추상 메소드만 담고 있는 인터페이스
추상 메소드 - 메소드가 정의되어있지만 텅텅 비어있다
몸체가 없다 보통 이렇게 쓰지않고
int abc(); 이런식으로 쓴다
실체가 없는 놈
반드시 구체화 시켜줘야한다
implements - 인터페이스의 상속느낌

상속과 구현
상속과 구현 동시에 가능

인터페이스의 본질적 의미

printer Driver 관련 예제


17-2 인터페이스의 문법 구성과 추상 클래스

인터페이스에 선언되는 메소드와 변수
인터페이스는 추상 메소드 스태틱 메소드  등을 정의해서 사용

인터페이스간 상속: 문제 상황의 제시

제시한 문제의 해결책: 인터페이스의 상속
인터페이스간 상속도 extends로 표현

인터페이스의 디폴트 메소드: 문제 상황의 제시
총 256개의 인터페이스가 존재하는 상황에서 모든 인터페이스에 다음 추상 메소드를 추가해야 한다면?
전부 오버라이딩을 해줘야하는데...

문제 상황의 해결책: 인터페이스의 디폴트 메소드

디폴트 메소드의 효과
인터페이스의 교체
S프린터는 흑백만
prn은 컬러 까지

인터페이스의 static 메소드

인터페이스 대상의 instanceof 연산
똑같이 가능
Cake는 클래스 이름, 인터페이스의 이름도 될수있다.

인터페이스 대상 instanceof 연산의 예

인터페이스의 또 다른 용도: Maker 인터페이스
마커 인터페이스 텅텅 비어있는 인터페이스

추상 클래스
abstract 를 붙이면 추상 클래스이다
abstract 로 메소드가 있다면 그 메소드를 포함한 클래스도 abstract 클래스가 된다
new를 사용할수없다 이미 인스턴스가 할당되어있기 때문
100개의 메소드중 1개라도 추상 메소드라면 abstract 클래스가 된다

public abstract class House {		 // 추상 클래스
}

abstract Class Apart extends House{
}
public abstract void methodTwo();		 // 추상 메소드












