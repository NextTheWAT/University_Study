JAVA 2주차

02-1 변수의 이해와 활용

변수
 - 메모리 공간의 활용을 위한 도구
 - 메모리 공간의 할당과 접근을 위해 필요한 도구
 - 변수의 선언은 '메모리 공간의 할당' 으로 이어진다.

자바에서는 = 은 '같다'가 아닌 '대입'의 의미이다.
대입은 오른쪽에 있는 값을 왼쪽으로!

boolean 참과 거짓  1 바이트 : true, false
char 문자 2 바이트 : 유니코드 문자

byte 정수 1 바이트 : -128~127
short 정수 2 바이트 : -32,768~32,767
int 정수 4 바이트 : -22억~22억 정도
long 정수 8 바이트 : -100경~100경 정도

float 실수 4 바이트
double 실수 8바이트

변수를 선언할때 임시로 int 메모리에 저장함
그래서 long 을 사용할떄 변수 뒤에 L을 써야함

float 과 double의 차이는 정밀도의 차이가 있다
0~1 사이에는 무한대의 실수가 있음
그래서 근사치를 표현을 한다

실수는 임시값을 double에 저장함
그래서 float 을 사용할때 변수 뒤에 f 를 써줘야 float으로 임시로 저장함
그렇지 않으면 컴파일 오류가 발생

first_Class2 1.000001 + 2.000001 을 더하면 3.00002가 출력되지않는다
왜냐하면 실수 표현에 오차가 존재하기 떄문 그래서 3.000001999997이 출력됨

1. 자바는 대소문자를 구분한다
2. 변수의 이름은 숫자로 시작할 수 없다.
3. $와 _ 이외의 특수문자는 변수의 이름에 사용할 수 없다.
4. 키워드는 변수의 이름으로 사용할 수 없다.

02-2 정수의 표현 방식 이해하기

컴퓨터가 양의 정수를 표현하는 방식
 - 부호 비트가 0이면 양의 정수, 1이면 음의 정수
 - 부호 비트가 0이면, 나머지 비트들은 값의 크기를 결정

03-1 상수

자바의 일반적인 상수
 - 변수에 값을 딱 한 번만 할당할 수 있으면 그것은 상수!
 - 한 번 할당된 값은 변경이 불가능하다.
 - 킹ㅝ드 final 선어니 붙어있는 변수

final 기반의 상수 선언의 예                     final in MAX_SIZE = 100; (상수 선언의 
                                                                  예 초기화 하지 않으면 딱 한번 초기화 가능!
 - 상수의 이름은 모두 대문자로 짓는 것이 관례
 - 이름이 둘 이상의 단어로 이뤄질 경우 단어를 언더바로 연결하는 것이 관례

리터럴에 대한 이해
리터럴
 - 자료형을 기반으로 표현이 되는 상수를 의미한다.
ex) int num1 = 5 + 7;
ex) double num2 = 3.3 + 4.5;
 - 정수는 무조건 int형으로 인식하기로 약속되어 있음
 - 따라서 5와 7은 '정수형 리터럴'이다
 - 그리고 3.3 과 4.5 는 '실수형 리터럴'이다
'리터럴' 이라는 표현은 '상수' 라는 표현으로 대신하는 경우가 많다

l 또는 L을 붙여서 long형 상수로 표현해 달라는 요쳥을 해야한다

정수형 상수의 이진수 표현방법과 언더바 삽입
byte seven = 0B111;
int num205 = 0B11001101;

원하는 위치에 언더바 삽입 가능
int num = 100_100_000;
int num = 12_34_56_78_90;
언더바 안넣어도 됨

실수형 상수(리터럴)

30.0004999D
실수는 기본 double형 double형임을 명시하기 위해 d 또는 D 삽입
double 보다는 float 이 더 중요함
30.0004999f

실수형 상수의 e표기법
3.4e3 -- 3.4x10^3 = 3400.0
3.4e-3 -- 3.4x10^-3 = 0.0034

이스케이프 시퀀스
'\b' 백스페이스 문자
'\t' 탭 문자
'\\' 백슬래시 문자
'\'' 작은따옴표 문자
'\'' ' 큰따옴표 문자
'\n' 개 행 문자
'\r' 캐리지 리턴 문자

 03-2 형 변환

자료형 변환의 의미와 필요한 이유는?
num1에 저장된 값이 long형으로 형 변환 된다.(자동 형 변환)
int num1 = 50;
long num2 = 3141353782L;
System.out.println(num1+num2);
 - 두 피연산자의 자료형이 일치해야 동일한 방법을 적용하여 연산을 진행할 수 있다.
 - 피연산자의 자료형이 일치하지 않을 때 형의 변환을 통해 일치를 시켜야 한다.

자동 형 변환
 - 규칙 1. 자료형의 크기가 큰 방향으로 형 변환이 일어난다.
 - 규직 2. 자료형의 크기에 상관없이 정수 자료형보다 실수 자료형이 우선한다.
ex) double num1 = 30;
ex) System.out.println(59L + 34.5);

명시적 형 변환
자동 형 변환 규칙에 부합하지는 않지만, 형 변환이 필요한 상황이면 명시적 형 변환을 진행한다.
ex1)
double pi = 3.1415;
int wholeNumber = (int)pi;
ex2)
long num1 = 300000007L;
int num2 = (int)num1;
ex3)
short = num1 = 1;
short = num2 = 2;
short = num3 = (short)(num1 + num2);


Chapter2
04-1

& 연산자 (비트 연산자)
비트로 바꿔서 계산하는 연산자

복합대입 연산자는 형 변환을 하지않아도 그냥 됨
num = (short)(num + 77l) ;
num += 77l               += 복합대입 연산자

논리 연산자
&& , || , !
&& A와B 모두 참 이면 연산 괄과는 참
|| A와B 둘 중 하나라도 참 이면 연산결과는 참
! 연산 결과는 A가 참이면 거짓, A가 거짓이면 참

논리 연산자 사용시 주의점 : SCE
result = ((num1 += 10) < 0 ) && ((num2 += 10) > 0 );
result = ((num1 += 10) > 0 )  || ((num2 += 10) > 0);
num1 와 num2 의 값이 모두 증가할 수 있을까?

거짓이라면 num1






