JAVA 12주차 정리

18-1. 자바 예외처리의 기본

자바에서 말하는 예외

예외(Exception)
‘예외적인 상황’을 줄여서 ‘예외’라 한다.
단순한 문법 오류가 아닌 실행 중간에 발생하는 ‘정상적이지 않은 상황’을 뜻한다.

예외처리
예외 상황에 대한 처리를 의미한다.
자바는 예외처리 메커니즘을 제공한다. 


예외 상황의 예


예외 상황의 또 다른 예


예외 상황을 알리기 위한 클래스

java.lang.ArithmeticException
→ 수학 연산에서의 오류 상황을 의미하는 예외 클래스
java.util.InputMismatchException
→ 클래스 Scanner를 통한 값의 입력에서의 오류 상황을 의미하는 예외 클래스


예외의 처리를 위한 try ~ catch

try에서 1,2,3번이 있다고하자 만약 2번이 익셉션이 발생하면 
3번으로 넘어가지않고 캐치로 넘어간다

만약 1,2,3번이 다 문제가 없다면 캐치를 건너뛴다

ArithmeticException은 클래스

예외의 처리를 위한 코드를 별도로 구분하기 위해 디자인된 예외처리
메커니즘이 try ~ catch 이다.


try ~ catch의 예


예외 발생 이후의 실행 흐름
2번에서 익셉션이 발생하면 캐치로 넘어감


try로 감싸야 할 영역의 결정
입력 오류에 대한 예외의 관점에서 보았을 때 이는 하나의 작업


둘 이상의 예외 처리를 위한 구성1


둘 이상의 예외 처리를 위


둘 이상의 예외 처리를 위한 구성2


Throwable 클래스


예외의 전


printStackTrace 메소드 관련 예제


ArrayIndexOutOfBoundsException
배열이 4개짜리


ClassCastException
형변환에서 예외가 생긴것

캐스트 - 형변환 연산자
2번째는 안되는것 알고있을거라 생각함


NullPointerException
비어있는것을 가르키는것


18-2. 예외처리에 대한 나머지 설명들


예외 클래스의 구분

• Error 클래스를 상속하는 예외 클래스
• Exception 클래스를 상속하는 예외 클래스
• RuntimeException 클래스를 상속하는 예외 클래스
→ RuntimeException 클래스는 Exception 클래스를 상속한다.

Throwable <- Error
		<- Exception <- RuntimeException
				   <- ...


Error 클래스를 상속하는 예외 클래스들의 특성

• Error 클래스를 상속하는 예외 클래스
• Exception 클래스를 상속하는 예외 클래스
• RuntimeException 클래스를 상속하는 예외 클래스

Error 클래스를 상속하는 예외 클래스의 예외 상황은 시스템 오류 
수준의 예외 상황으로 프로그램 내에서 처리 할 수 있는 수준의 예외가 아니다. 

ex) VirtualMachineError 가상머신에 심각한 오류 발생
IOError 입출력 관련해서 코드 수준 복구가 불가능한 오류 발생


RuntimeException 클래스를 상속하는 예외 클래스들의 특성

코드 오류로 발생하는 경우가 대부분이다. 따라서 이 유형의 예외 발생시 코드의 수정을 고려해야 한다.


Exception 클래스를 상속하는 예외 클래스들의 특성

• Error 클래스를 상속하는 예외 클래스
• Exception 클래스를 상속하는 예외 클래스
• RuntimeException 클래스를 상속하는 예외 클래스

코드의 문법적 오류가 아닌, 프로그램 실행 과정에서 발생하는 예외적 상황을 표현하기 위한 클래스들이다. 
따라서 예외의 처리를 어떻게 할 것인지 -반드시- 명시해 주어야 한다.
ex) java.io.IOException 입출력 관련 예외 상황을 표현하는 예외 클래스


Exception을 상속하는 예외의 예

Exception을 상속하는 예외는 반드시 처리를 해야 한다. 
그렇지 않으면 컴파일 오류로 이어진다.


처리하거나 아니면 넘기거나

throws IOEexception
나를 호출한곳으로 떠넘기기
폭탄 넘기기 m2에서 m1으로 m1에서 try로
그래서 에러가 발생하지않음


둘 이상의 예외 넘김에 대한 선언

호출한 곳으로 넘기면 됨 2개던 3개던 다 가능한것


프로그래머가 정의하는 예외 클래스
직접 정의해서 쓰려면 익셉션 클래스를 상속받아야함

ReadAgeException - 생성자
super - 부모클래스 호출
Throwable 클래스의 getMessage 메소드가 반환할 문자열 지정
그러니 get메세지를 호출하면 super에서 적은 메세지가 나옴


프로그래머 정의 예외 클래스의 예 @@

빨간글자 - 인스턴스를 생성해서 다른곳으로 던짐
그리고 다시 호출한 readAge로 돌아감

 
잘못된 catch 구문의 구성 @@
E <- FE <- SE <- TE
JVM임
FE, SE, TE 세개 다 익셉션이 발생해도
다 FE에 걸려서 잘못된것
그러니 TE - SE - FE 로 캐치를 반대로 작성해야함 순서의 반대로 

catch(ThirdException e) {...}  
catch(SecondException e) {...}
catch(FirstException e) {...}
이런식으로 해야함


finally
코드의 실행이 try 안으로 진입하면, 무조건 실행된다.
익셉션이 발생하던 안하던 파이널를 꼭 거쳐서감
ex) 파일입출력에서 파일을 닫을때


finally 구문의 사용의 예


try-with-resources
이런식으로 만들면 더 편함

1. try catch
2. 예외의 전달, 케이스 결과값 출력 어떻게 되는지


19-1. 자바 가상머신의 메모리 모델


운영체제 입장에서 자바 가상머신

- 운영체제의 관점에서는 가상머신도 그냥 프로그램의 하나. 

- 운영체제가 일반 프로그램에게 4G의 메모리 공간을 할당해준다면,
- JVM에게도 4G 메모리 공간을 할당해준다. 

- 자바 프로그램이 두 개 실행되면, 가상머신도 두 개가 실행된다. 
- 이는 메모장을 두 번 띄우면 두 개의 메모장 프로그램이 실행되는 이치와 같다


자바 가상머신의 메모리 모델

• 메소드 영역 (Method Area) 
	메소드의 바이트코드, static 변수
• 스택 영역 (Stack Area) 
	지역변수, 매개변수
• 힙 영역 (Heap Area) 
	인스턴스

제일 오래가는 순서 메소드 영역 - 힙 영역 - 스택 영역
전역변수는 프로그램이 종료될때 소멸됨
힙 영역은 잊혀질떄--

메모리 공간 활용의 효율성을 높이기 위해 메모리
공간을 이렇듯 세 개의 영역으로 구분하였다.


메소드 영역

메소드 영역 : 바이트코드와 static 변수가 할당되는 메모리 공간
-이 영역에 저장된 내용은 프로그램 종료 시 소멸된다-


스택 영역

스택 영역 : 지역변수 매개변수 할당되는 영역
-이 영역에 저장된 변수는 해당 변수가 선언된 메소드 종료 시 소멸된다.-

힙 영역

힙 영역 : 인스턴스가 저장되는 영역
-가비지 컬렉션의 대상이 되는 영역이다.-
스택영역과 연결되어있다가 종료되면 연결이 끊긴다
그래서 점점 소멸됨
소멸되기전에 예를들어 스트링에서 같은 문자열을 a,b가 만들고
종료됐다면 다른곳에서 c가 또 호출을 했다면
그때도 다시 사용가능하다
언제 인스턴스가 없어지냐면 버려줄때까지 기다리는데
버려주는걸 JVM이 한다


자바 가상머신의 인스턴스 소멸 시기

참조 관계가 끊어진 인스턴스는 접근이 불가! 
따라서 가비지 컬렉션의 대상이 된다.


19-2. Object 클래스


Object 클래스의 finalize 메소드

Object 클래스에 정의되어 있는 이 메소드는 인스턴스 소멸 시 자동으로 호출이 된다.
자식 클래스에서 오버라이딩 할 수 있음.


finalize 메소드의 오버라이딩 예


인스턴스의 비교: equals 메소드

상속받는 클래스가 없는데
자동으로 오브젝트 클래스를 상속해주는것


String 클래스의 equals 메소드
equals 메소드를 쓸 필요가없다
== 과 비슷하기 때문에
참조 대상이 같은지는 ==
내용이 동일한지는 equals


