게임엔진(2) 중간고사 정리


1. 가상현실의 정의 및 디바이스 종류, 문제점 및 해결방법
- 가상현실의 정의
	- 어떤 특정한 환경이나 상황을 컴퓨터로 만들어서, 그것을 사용하는 사람이 마치 실제 주변 상황  환경과 상호작용을 
		하고 있는 것처럼 만들어 주는 인간-컴퓨터 사이의 인터페이스를 말한다. 
		실존하지 않는 가상의 공간에서 사람이 실제로 현장에 있는 듯한착각을 일으키게 해 현실적인 체험을 제공하는것을 말함

- 디바이스 종류
	- 최초의 가상현실 기기 센소라마(1962년)
	- 최초의 HMD
	- 닌텐도 보이(Virtual Boy) 개발
	- 소니의 HMZ-T1
	- 2012년 오큘러스 리프트 DK1
	- 구글 카드 보드 
	- 삼성 기어 VR
	- HTC Vive
	- PICO4 
	- 메타의 오큘러스 퀘스트 2  
	- 메타의 오큘러스 퀘스트 프로  
		- 현존하는 최고의 VR/MR 디바이스

- 문제점
	- VR기기로 가상현실을 체험한 대부분의 사람들은 어지러움증과 두통을 호소함
	- 사람이 느끼는 실제 공간 감각과 시신경으로 전해지는 VR 공간이 일치하지 않아서 생기는 현상으로 알려짐
	- 흔히 이야기 하는 인지 부조화의 결과
	- 낮은 해상도와 어안렌즈 주변부의 왜곡 현상도 그 원인으로 꼽히고 있음

- 해결 방법(완벽한것은 아님)
	- 카메라 이동을 최소화함
	- 가속 또는 감속을 최소화함
	- 모션 블러 기능을 사용하지 않음
	- 1인칭 시점의 경우 걷는 동작에서 헤드 밥 효과를 사용하지 않음
	- 화면에 고정된 물체를 배치
	- 90FPS  이상의 프레임레이트를 권장하고 일정한 FPS를 유지한다. 


2. 레이캐스트의 정의 및 구조체 내용 정리
레이캐스트 적용
- Projectile 방식과는 달리 @눈에 보이지 않는 광선(Ray)을 쏘아서@ 해당 광선에 맞은 물체가 적인지 여부를 판단한 뒤 여러가지 후처리를 하는 방식
- @실제 총알이 날아가는 모습을 보이지 않음@
- 기타, 감지 센서 역할, 클릭 후 회전 및 이동 처리
- VR에서는 마우스와 같은 표준 입력이 아니라, 컨트롤러를 사용하기 때문에 레이캐스팅이 필수적임
	- 예를 들어, 디아블로나 리니지 같은 전통적인 쿼터뷰(Quarter View)방식의 게임에서는 플레이어를 
		마우스 왼쪽 클릭으로 조작해 이동시킬 때 실제로는 마우스 포인트 위치로 레이캐스트 해서 
		3차원 좌표 값을 읽어온 후 해당 좌표로 이동 시킨다. 
구조체
DrawRay
- 레이 캐스트는 @씬 뷰@에서 시각적으로 표시되지 않기 때문에 개발 할 때는 @DrayRay 함수@를 이용해 시각적으로 표시하고 개발 해야 한다. 
- (녹색 광선) 레이캐스트가 어떤 객체를 감지(충돌)하기 위해서는 @콜라이더가 컴포넌트@가 있어야 함

RayCast / RaycastHit 
- Ray를 쏘아서 어떤 게임 오브젝트에 맞았을 때 맞은 게임 오브젝트의 정보를 반환 받을 변수 RaycastHit 타입으로 선언 해야 함 

관련 함수 : Physics.Raycast() 
- 총 16가지의 사용법이 존재
	- 발사 원점 / 발사 방향 / out 결과 값 / 광선 거리 / 검출할 레이어
- 객체에 닿으면 true 값을 반환
- Physics.Raycast(    // 어떤 Collider와 충돌 했으면 true를 반환
- firePos.position,      // Ray의 Start Point
- firePos.forward,      // Ray의 방향
- out hit,                       // 충돌한 객체에 대한 자세한 정보 리턴
- 10.0f );                      // Max Distance          

RaycastHit 구조체 
collider
- 맞은 게임오브젝트의 Collider 반환
transform
- 맞은 게임오브젝트의 Transform 반환
point
- 맞은 위치의 월드 좌푯 값 반환 (Vector3)
distance
- 발사위치와 맞은 위치 사이의 거리
normal
- Ray가 맞은 표면의 법선 벡터

SendMessage() 함수
- Raycast 방식은 자동적인 충돌 이벤트 함수를 일으키지 않는다. 
- 따라서 MonsterCtrl에 OnDamage()함수를 정의한 뒤 FireCtrl 에서 그 함수를 호출하는 방식으로 해야 함. 


3. 동적 장애물의 Navigation 처리 방법

드럼통을 폭파 시킨 후 여전히 장애물로 인식하는 문제 해결
- 지금까지 제작했던 게임에서 드럼통을 장애물로 설정 해 적 캐릭터가 이 장애물을 회피하면서 주인공을 추적하게 했다. 
	하지만 드럼통을 폭파시킨 이후에도 여전히 적 캐릭터는 그 지점을 장애물로 인식하는 문제점이 있다. 이는 드럼통이 
	폭파한 후에도 미리 베이크 했던 네비메시에서 여전히 그 지점은 지나갈 수 없는 영역이기 때문이다. 이와 같은 문제는
	동적으로 변경되는 장애물에 NavMeshObstacle 컴포넌트를 활용하면 해결할 수 있다. 
- Barrel 프리팹을 선택한 후 Navigation Static 옵션 제거 (하위객체까지 모두 변환 체크 -> Yes 체크)
- @메뉴 > Window > Navigation 을 열고 다시 베이크 함@


4. Off Mesh Link 
서로 분리된 메쉬를 연결
- 네비게이션은 기본적으로 3D 메시의 정보를 기반으로 네비 메시를 생성한다. 따라서 서로 분리된 메시는 
	추적할 수 없다. 다만 Off Mesh Link를 통해서 서로 분리된 메시를 연결 할 수 있다. 즉, 추적이 가능하게 연결 고리를 생성할 수 있음
- 예를 들어 Floor (바닥 지형) 위에 계단을 설치 했을 경우 계단과 지형은 함께 베이크 되지 않았으므로 네비게이션 추적이 안됨 (계단위로 추적하지 않음)
- 이러한 경우 Off Mesh Link를 통해 추적을 가능하게 해 줄 수 있다. 

- 네비메시를 베이크 하기 위해 static 옵션 중에 Navigation Static 과 Off Mesh Link Generation 을 동시에 체크한다(Ctrl 키를 누르면 동시에 선택됨)
- Hierarchy 뷰에서 Stair를 선택한 뒤 Navigation 뷰의 Object 탭에서 Navigation Static 과 Generate OffMeshLinks 두개를 체크한다. 

- 계단 모델인 Stair은 Collider 가 없기 때문에 주인공이 올라갈 수 없다. 
- Stair를 선택한 다음에 Mesh Collider 콤포넌트를 추가함
- Collider 가 없기 때문에 주인공이 이동해서 올라 갈 수 있도록 해야 함
- Convex 속성을 체크하여 폴리곤 수를 낮춘다. 
- Navigation 의 Bake 속성에서 Agent Radius 값을 0.2 바꾸면 Off Mesh Link가 촘촘하게 생성되는 것을 확인할 수 있다. 


5. 조명 모드 / Light Mapping / Probe 정의 (Light Probe)

조명 모드
- 유니티에서 제공하는 조명 모드는 3가지가 있음 (Directional Light를 선택)
	- Realtime
	- Mixed
	- Baked

Realtime 모드
- 실시간 조명으로 설정
- 씬에 직접 광을 적용하며 매 프레임 조명 연산을 해서 화면을 업데이트 함
- 연산 부하가 큼
- 직접 광원만 적용 (간접 광원은 적용이 안됨)
- 실시간 조명 모드에서 전역 조명을 사용하기 위해서는 [Windows]-[Rendering]-[Lighting] 뷰 에서 Realtime Global Illumination 옵션을 체크 한다.

Mixed 모드
- Baked Indirect : 
	- 간접 광원만 미리 계산하여 베이크 하며 그림자는 베이크 대상에서 제외됨. Mixed 모드로 설정된 조명은 
		씬에서 실시간 조명 기능을 유지함. 이 옵션은 중급 사양의 PC 또는 고성능 모바일 디바이스에 적합하다. 
- Subtractive : 
	- 정적인 객체의 직접/간접 광원과 그림자를 모두 베이크 한다. 모바일 디바이스에 적합한 옵션이며, Mixed로 
		설정된 Light 컴포넌트가 실시간 조명 처리를 하지 않는다. 
- Shadowmask : 
	- 직접 광원은 실시간으로 처리하고 간접광원과 Light Probe는 라이트 맵에 저장한다. 그림자는 별도의 텍스처인 셰도우마스크에 저장한다.  

Baked 모드
- Baked 모드의 조명은 런타임시 조명 연산을 처리하지 않는 조명이다. 
- 정적(static)인 물체에 전역 조명과 그림자를 생성한다. 
- 동적인 물체의 조명효과는 라이트 프로브(Light Probe)를 통해 적용한다. 
- Backed 모드의 조명은 스펙큘러 조명 효과를 표현할 수 없어서 리플렉션 프로브(Reflection Probe)를 사용해 구현한다. 

라이트 맵핑이란?
- 씬에 배치된 모든 3D 모델에 영향을 미치는 직접 조명, 간접 조명 및 그림자의 효과를 텍스처로 미리 만드는 과정을 말함
- 그 결과로 만들어진 텍스처 파일을 라이트 맵(Light Map)이라고 한다. 
- 이 라이트 맵을 만드는 일련의 과정을 “베이크” 한다고 함

라이트 프로브란?
- 라이트 맵핑을 사용해 실감나는 조명 효과를 표현할 수 있음에도 동적으로 움직이는 객체에는 이러한 조명을 적용할 수 없다. 
- 라이트 매핑은 정적인 객체에만 적용할 수 있다. (static 옵션 체크)
- 움직이는 플레이어가 밝은 곳에 들어갔을 경우 어둡게 보인다든가 하는 현상 (주변의 광원에 영향을 미치지 않아 부자연스러운 장면이 보임) 
- 이러한 점을 보완하기 위해서 유니티에서는 라이트 프로브 기능을 제공하고 있음
- 라이트 프로브는 스테이지의 조명이 있는 곳 주변에 라이트 프로브를 배치하고 라이트 맵을 베이킹 할 때 해당 
	라이트 라이트 프로브에 주변부의 광원 데이터를 미리 저장해 둔다. 
- 라이트 프로브에 저장된 광원 데이터는 실행 시 근처를 지나가는 동적 객체에 광원 데이터를 전달해 해당 객체의 
	색상과 보간 시켜 마치 실시간 조명과 같은 효과를 내는 방식이다. 


6. Post Rendering 정의
- 포스트 프로세싱 설정
- 포스트 프로세싱이란 렌더링된 결과물(영상, 이미지)에 대한 후처리 작업을 말한다. 카메라가 촬영한 영상 또는 이미지를 
	스크린에 출력하기 전에 @다양한 필터와 효과@를 적용하는 기술을 말한다. 즉, 카메라로 촬영한 후에 처리하는 과정이라는 
	의미에서 붙여진 용어라 볼 수 있으며 @다양한 후처리 효과를 통해 시각적 퀄리티를 높일 수 있다.@
- URP 로 설정된 프로세스에서 다음과 같은 포스트 프로세싱은 적용할 수 없다
- 자동 밝기 기능(Auto Exposure)
- 안개(Fog)
- 스크린 공간 반사(Screen Space Reflection)

 
7. 방 / 로비 의 개념 / 
포톤 서버
룸 (Room)
로비 (Lobby)
- 포톤 서버는 룸과 로비의 개념이 존재한다. 즉, 룸 단위 네트워킹 기능을 제공하며 포톤 서버에 접속하면 룸을 생성할 수 있다
- 룸이란 네트워크 게임을 실행할 수 있는 논리적인 공간으로 룸에 입장해야만 해당 룸에 접속한 다른 유저와 통신이 가능하다. 
- 로비에 입장(접속)한 유저는 어떤 룸이 생성되었는지에 대한 정보를 수신 받을 수 있다. 
- 룸의 목록을 받아와서 특정 룸을 선택하여 입장하는 방식


8. URP란?
URP 
- 범용으로 사용 가능한 렌더링 파이프라인
- 고품질의 렌더링 결과를 PC, 콘솔, 모바일, VR, AR 등 모든 플랫폼에 적용할 수 있음
- PP(포스트 프로세싱) 기능과 통합되어 다양한 후처리 그래픽 효과를 처리할 수 있다.
- 광원, 역광, 반사, 블러링(흐림) 등 효과 연출


9. 비네팅 효과 
비네팅(Vignetting)효과는 화면의 주변이나 모서리를 어둡게 처리하는 것으로 자연스럽게 화면의 가운데 부분으로 
시선을 모으는 효과가 있다. 따라서 게임 분야 있어서는 게이머의 몰입도를 증가시키는 효과 중 하나로 사용된다.


10. Bloom, Tonemapping효과
Bloom 효과 
- 빛을 받는 물체는 그 주의의 빛을 발산하는 것과 같은 효과를 냄	
= HDR 렌더링과 함께 사용하여 마법이나 꿈속의 세계 같은 느낌을 주는 매우 특징적인 효과

Tonemapping 효과
- HDR(13, 32비트) 이미지를 SDR(8비트)로 변환할 때 사용하는 효과 
- 좀 더 사실적이고 퀄리티가 높은 이미지를 만들어 낼 수 있다.  


11. 포톤 서버의 콜백 함수 정의
OnPhotonSerializeView 콜백함수를 사용하는 방식
- 네트워크 레이턴시에 대응할 수 있는 코드를 작성해 좀 더 유연하게 로직을 구현할 수 있다. 
- 같은 룸에 입장한 네트워크 객체 간의 데이터를 동기화하는 두 번째 방식이 바로 OnPhotonSerializeView콜백 함수를 사용하는 방식이다. 
	앞서 구현한 PhotonTransformView와 PhotonAnimatorView는 컴포넌트만 추가하면 간단히 동기화 처리가 되지만, 
	좀 더 세밀한 보정이 필요할 때는 이 콜백 함수를 통해 직접 데이터를 송수신해야 한다.
- 기존 주인공 캐릭터의 위치와 회전값을 동기화했던 PhotonTransformView 컴포넌트를 제거해야 한다. 프로젝트 뷰에서 
	Resources 폴더에 있는 Player 프리팹을 선택하고 PhotonTransformView 컴포넌트를 제거한다. 그 다음 Movement 스크립트를 다음과 같이 수정한다.


12. Google VR SDK란?
- Google VR SDK : 구글에서 만든 VR SDK (다양한 플랫폼 지원 : Unity, Unreal, …)
	- developers.google.com/vr/develop
	- 구글에서.. Open Source 로 배포 (제공).. 구글에서 Google VR 개발을 중지.. 
		- VR보다는 AR쪽으로 사업 영역을 확대


13. 우주선의 회전 처리 방법

14. Invoke() 함수에 대한 정리?
일정 시간 만큼 지연시켰다가 코드를 동작하게 한다는 점에서 Invoke와 동일한 기능
앞서 말했듯이, 코루틴을 통해서 Update문과는 별개로 동작하는 또다른 서브루틴을 만들 수 있기도 하지만, 그것 말고도 매개변수를 넘길 수 있다는 장점

15. 360도 영상이란?

16. 스티칭 작업이란?

17. 리그형태의 카메라란?

18. 스크린 도어 효과란?

19. 셰이더란?

20. 게이지 UI 만드는 방법 (게이즈가 차거나 줄어드는 과정)
- Image를 복사하여 하나 더 만든다. 
- 이름을 Reticle로 바꿈
- Image 콤포넌트에서 Color 값을 빨간색으로 지정
- Image Type을 Filled로 바꿈
- Fill Amount를 0 으로 지정




