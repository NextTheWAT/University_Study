데이터베이스 13주차

트랜잭션의 특성 반드시 시험에 나옴@@@


인덱스 방법
• 인덱스 파일과 데이터 파일로 구성
	– 인덱스 파일은 <탐색 키 값, 주소> 쌍으로 구성
• 데이터 레코드를 접근하기 위해 먼저 인덱스(index)를 찾은 후,
• 그 인덱스가 가리키는 주소를 따라가 레코드에 접근하도록 데이터를 저장하는 방법

기본 인덱스
• 탐색 키가 데이터 파일의 기본 키(primary key)인 인덱스
• 기본 키 값에 따라 정렬된 데이터 파일에 대해 정의됨
• 각 테이블마다 최대 한 개의 기본 인덱스를 가질 수 있음
• 흔히 희소 인덱스(sparse index)로 유지
	– 일부 키 값에 대해서만 인덱스에 엔트리를 유지하는 인덱스
	– 일반적으로 각 블록마다 한 개의 탐색 키 값이 인덱스 엔트리에 포함됨

보조 인덱스
• 탐색 키 값에 따라 정렬되지 않은 데이터 파일에 대해 정의됨
• 보조 인덱스는 기본 인덱스에 비해 순차 접근이 비효율적
• 보조 인덱스를 통한 접근은 기본 인덱스를 통한 접근보다 디스크 접근 횟수가 증가할 수 있음
• 밀집 인덱스(dense index)
	– 각 레코드의 키 값에 대해서 인덱스에 엔트리를 유지
	– 데이터 파일의 각 레코드의 탐색 키 값이 인덱스 엔트리에 포함됨


인덱스 관련 SQL
• 인덱스 생성
	CREATE [UNIQUE] INDEX 인덱스이름
		ON 테이블이름(컬럼이름리스트);
• 인덱스 제거
	DROP INDEX 인덱스이름 ON 테이블이름;


인덱스 유형
• PRIMARY (기본 인덱스)
	– 기본키에 대해 자동으로 생성되는 고정된 이름의 인덱스
	– NULL값, 중복된 값을 가질 수 없음
• UNIQUE (고유 인덱스)
	– 중복된 값을 가질 수 없음
	– NULL이 허용된 칼럼에 생성된 UNIQUE 인덱스에는 여러 개의 NULL값이 존재할 수 있음
• INDEX 혹은 KEY (비고유 인덱스)
	– 중복된 값이 허용됨


인덱스의 장단점
• 장점
	– 검색 속도 향상
	– 소수 레코드들의 수정/삭제 연산 속도 향상
	– 테이블이 매우 크고,질의에서 테이블의 레코드들 중 일부를 검색하고
		WHERE절이 잘 표현되었을 때 성능에 도움이 됨
• 단점
	– 인덱스 저장 공간이 추가로 필요함
	– 삽입/삭제/수정 연산 속도 저하
		▪ 인덱스 갱신 필요


인덱스 선정 지침
• 기본키는 인덱스를 정의할 훌륭한 후보: 기본 인덱스
	– MySQL에서 자동 생성
• 외래키도 인덱스를 정의할 중요한 후보
	– MySQL에서 외래키로 지정된 속성에 인덱스가 없으면 인덱스를 자동 생성함
• 한 속성에 들어 있는 상이한 값들의 개수가거의 전체 레코드 수와 비슷하고,
	그 속성이 동등 조건에 사용된다면
	인덱스를 생성하는 것이 좋음

• 튜플이 많이 들어 있는 테이블에서 대부분 질의가 2% ~ 4% 미만의 레코드만을 검색
	하는 경우 인덱스를 생성
• 한 테이블에 가능한 한 3개 이하의 인덱스를 생성
• 자주 수정되는 속성에는 인덱스를 정의하지 않는 것이 좋음
• 수정이 빈번하게 이루어지는 테이블에는 인덱스를 많이 만드는 것을 피함

• 후보 키는 기본 키가 갖는 모든 특성을 마찬가지로 갖기 때문에 인덱스를 생성할 후보
	– MySQL에서 UNIQUE로 설정된 속성에 대해 자동으로 인덱스가 생성됨
• 인덱스는 파일의 레코드들을 충분히 분할할 수 있어야 함
	– 사원번호 vs 성별
• 정수형 속성에 인덱스를 생성
	– 다음 우선순위는 고정 길이 속성
• VARCHAR, 날짜, 실수형 속성에는 가능한 한 인덱스를 만들지 않음

• 작은 파일에는 인덱스를 만들 필요가 없음
• 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고, 
	@데이터 삽입이 끝난 후에 인덱스들을 다시 생성@하는 것이 좋음


질의 튜닝
• DBMS의 질의 최적화 모듈이 테이블의 크기가
	작아서 인덱스가 도움이 되지 않는다고 판단하
	면 DBMS가 인덱스를 사용하지 않음
• 널 값에 대해서는 일반적으로 인덱스가 사용되지 않음
	SELECT *
	FROM EMPLOYEE
	WHERE MANAGER IS NULL;

• 인덱스가 정의된 속성에 산술 연산자가 사용된
경우 인덱스가 사용되지 않음
	SELECT *
	FROM EMPLOYEE
	WHERE SALARY * 12 > 40000000;
	--->
	SELECT *
	FROM EMPLOYEE
	WHERE SALARY > 40000000 / 12;

• DBMS가 제공하는 내장 함수가 사용된 경
우 인덱스가 사용되지 않음
	SELECT *
	FROM EMPLOYEE
	WHERE SUBSTRING(EMPNAME,1,1) = ‘김’;
	--->
	SELECT *
	FROM EMPLOYEE
	WHERE EMPNAME LIKE ‘김%’;

질의 튜닝 추가 지침
• DISTINCT절의 사용을 최소화하라
– SELECT절에 키가 포함된 경우 DISTINCT 불필요
• GROUP BY절과 HAVING절의 사용을 최소화하라
• SELECT * 대신에 SELECT절에 속성 이름들을 구체적으로 명시하라


역정규화
• 성능상의 관점에서,
– 높은 정규형을 만족하는 릴레이션 스키마가 최적일까?

• 데이터베이스 시스템에서 어떤 질의가 더많을까?
	– 검색 질의 vs. 삽입/삭제/수정 질의
• 데이터 중복 및 이상 현상을 대가로 치르면서 성능상의 요구를 만족시킬 필요가 있음
• 역정규화(denormalization)
	– 분해된 두 개 이상의 릴레이션들을 합쳐서 하나의 릴레이션으로 만드는 작업
	– 보다 낮은 정규형으로 되돌아가는 것

역정규화: 테이블 통합
• 두 테이블에 대해 항상 혹은 대부분 조인에 의한 검색을 하는 경우
• 조인에 걸리는 시간을 절약하려는 목적
• 두 테이블의 모든 칼럼을 하나의 테이블로 통합

역정규화: 테이블 분리
• 테이블의 레코드 수 및 칼럼의 수가 매우 많고, 
	칼럼들이 그룹화되어 각 그룹이 특정 부서 혹은
	응용 프로그램에 의해서만 사용될 때
• 분리함으로써 데이터 크기 감소, 검색의 분산

• 레코드의 검색 빈도가 서로 다르다는 점을 이용하여 테이블 분리
• 데이터 크기 감소 효과

역정규화: 칼럼 중복
• 조인하여 가져다 사용하는 칼럼의 수가 적을 경우 테이블 통합은 비효율적임
• 조인에 의해서 가져오는 칼럼을 중복해서 저장하는 편이 더 합리적


테이블 기술서
• 개별 테이블에 대한 보다 자세한 문서화수단
• 테이블 하나하나에 대한 출력된 문서를 필요로 함
• 데이터베이스 시스템 개발자나 유지보수 담당자에게 매우 유용함


뷰(View)
• 하나 또는 둘 이상의 기본 테이블(base table)로부터 유도되어 만들어지는 가상테이블(virtual table)
• 기본 테이블은 물리적으로 구현되어 데이터가 실제로 저장되지만, 뷰는 반드시 물
	리적으로 구현되는 것은 아님
• 뷰의 정의만 시스템 내에 저장해두었다가, 실행시간에 테이블 구축

• 데이터 검색
	– 뷰와 기본 테이블 간에 아무런 차이 없이 사용 가능
• 데이터 변경
	– 뷰에 대한 삽입/삭제/수정 연산에는 약간의 제한이 있음
	– 뷰에 대한 내용 변경 → 기본 테이블에 대한 변경


뷰 생성
• 일반 형식
	CREATE VIEW 뷰_이름 [(열_이름 리스트)]
	AS SELECT문
	[WITH CHECK OPTION];
– WITH CHECK OPTION: 뷰에 대한 갱신/삽입 연산 시, 
뷰 정의 조건(SELECT문의 WHERE 조건)을 위반하면
실행이 거부됨
	CREATE VIEW 저가도서
		AS SELECT 번호, 제목, 가격 FROM 추천도서
			WHERE 가격 <= 20000 ;


뷰 제거
• 일반 형식
	DROP VIEW 뷰_이름 [ RESTRICT | CASCADE ];
– MySQL에서는 RESTRICT와 CASCADE는 아무
효과 없음. (호환을 위해 문법만 허용)
– 오라클:
	DROP TABLE 뷰_이름
		[CASCADE CONSTRAINT] ;
▪ CASCADE CONSTRAINT: 삭제할 뷰와 관련된 모든
참조 무결성 제약조건을 함께 삭제


뷰 조작
• 열 부분 집합 뷰(column subset view)
– 기본 키가 포함된 경우
	CREATE VIEW 저가도서
		AS SELECT 번호, 제목, 가격 FROM 추천도서
			WHERE 가격 <= 20000 ;
▪ 삽입/삭제/수정 가능

• 열 부분 집합 뷰(column subset view)
– 기본 키가 포함되지 않은 경우
CREATE VIEW 저가도서2
	AS SELECT 제목, 가격 FROM 추천도서
		WHERE 가격 <= 20000 ;
▪ 삽입/삭제/수정 불가능

• 행 부분 집합 뷰(row subset view)
CREATE VIEW 저가도서3
	AS SELECT 번호, 제목, 가격, 추천인, 추천일자
		FROM 추천도서 WHERE 가격 <= 20000 ;
– 기본 키가 포함되므로, 삽입/삭제/수정 가능

• 변경연산(삽입/삭제/수정)이 허용되지 않는 경우
	– 기본 테이블의 기본키를 구성하는 속성이 포함되지 않은 경우
	– 기본 테이블에서 NOT NULL로 지정된 속성이 포함되지 않은 경우
	– 뷰의 열이 상수나 산술 연산자 또는 함수가 사용된 산술 식으로 만들어질 경우
	– 집계 함수가 관련되어 정의된 경우
	– DISTINCT, GROUP BY, HAVING이 사용되어 정의된 경우
	– 두 개 이상의 테이블을 조인하여 정의된 경우
	– 변경할 수 없는 뷰를 기초로 정의된 경우

뷰의 장단점
• 장점
	– 데이터의 논리적 독립성을 제공 (확장, 구조 변경)
	– 데이터의 접근을 제어 (보안)
	– 사용자의 데이터 관리를 단순화 (관리 용이, 질의문 간단)
	– 여러 사용자에 다양한 데이터 요구를 지원
• 단점
	– 정의를 변경할 수 없음
	– 삽입, 삭제, 수정 연산에 제한이 많음
	– 성능 저하


트랜잭션(transaction)
• 하나의 작업을 수행하는데 필요한 데이터베이스 연산들을 모아놓은 것
	– 작업 수행에 필요한 SQL 문들의 모임
	– 특히, 데이터베이스를 변경하는 INSERT, DELETE, UPDATE 문의 실행을 관리
• 논리적인 작업의 단위
• 장애 발생 시 복구 작업이나 병행 제어 작업을 위한 중요한 단위로 사용됨
• 데이터베이스의 무결성과 일관성을 보장하기
	위해 작업 수행에 필요한 연산들을 하나의 트
	랜잭션으로 제대로 정의하고 관리해야 함

트랜잭션의 특성: 원자성
• Atomicity
• 트랜잭션의 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 함
	– all-or-nothing 방식
• 만약 트랜잭션 수행 도중 장애가 발생하면?
	– 지금까지 실행한 연산 처리를 모두 취소하고, 데이터베이스를 트랜잭션 작업 전 상태로 되돌려야함
• 원자성의 보장을 위해 장애 발생 시 회복 기능이 필요
	– 트랜잭션의 일부 연산만 처리한 결과를 DB에 반영하는 일이 없게 됨

트랜잭션의 특성: 일관성
• Consistency
• 트랜잭션 수행 전에 DB가 일관된 상태였
	다면, 트랜잭션 수행 후 결과를 반영한 DB
	도 또 다른 일관된 상태가 되어야 함

트랜잭션의 특성: 격리성
• Isolation; 고립성
• 수행 중인 트랜잭션이 완료될 때까지 중간연산 결과에 다른 트랜잭션들이 접근할 수 없음
• 격리성의 보장을 위해서는 여러 트랜잭션
	이 동시에 수행되더라도 마치 순서대로 하
	나씩 수행되는 것처럼 정확하고 일관된 결
	과를 얻을 수 있도록 제어하는 기능 필요

트랜잭션의 특성: 지속성
• Durability; 영속성
• 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 영구적이어야 함
• 지속성의 보장을 위해서는 장애 발생 시 회복 기능이 필요

트랜잭션의 연산
• Commit 연산
	– 트랜잭션의 수행이 성공적으로 완료되었음을 선언하는 연산
	– commit 연산이 실행되면 트랜잭션의 수행 결과
		가 데이터베이스에 반영되고 일관된 상태를 지속
		적으로 유지하게 됨
• Rollback 연산
	– 트랜잭션의 수행이 실패했음을 선언하는 연산
	– rollback 연산이 실행되면 트랜잭션이 지금까지
		실행한 연산의 결과가 취소되고 데이터베이스가
		트랜잭션 수행 전의 일관된 상태로 되돌아감


데이터 이동 연산
• input/output
– 디스크와 메인 메모리 간의 데이터 이동 연산
• read/write
– 메인 메모리와 프로그램 변수 간의 데이터 이동 연산

회복(recovery)
• 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구시키는 것
• 트랜잭션의 특성을 보장하고, 데이터베이스를 일관된 상태로 유지하기 위해 필수적인 기능
• 회복 관리자(recovery manager)가 담당
	– 장애 발생을 탐지하고, 장애가 탐지되면 데이터베이스 복구 기능을 제공

회복
• 데이터를 별도의 장소에 미리 복사해두고, 장애 발생 시
복사본을 이용해 원래 상태로 복원
• 회복을 위해 복사본 만드는 방법
• 회복을 위한 기본 연산


로그
• 로그 파일
	– 데이터를 변경하기 이전 값과 변경한 이후 값을 기록한 파일
	– 레코드 단위로 트랜잭션 수행과 함께 기록됨
• 로그 레코드의 종류











