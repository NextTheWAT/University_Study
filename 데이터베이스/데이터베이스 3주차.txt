데이터베이스 3주차

03. 관계DB

- 현실 세계를 데이터베이스 시스템에서 다루려면?
	- 데이터(개체, 관계)을 어떻게 표현하여 조직화 할 것인가?
	- 이 데이터를 정확성과 현재성이 유지되도록 어떻게 관리해야 하는가
->  (관계) 데이터 모델


관계 데이터 몯레


데이터 모델

데이터 모델
- 컴퓨터에 저장할 데이터의 구조를 논리적으로 표현하기 위해 사용하는 지능적 도구
- <데이터 구조, 연산, 제약조건> 으로 구성됨

데이터 구조(data structure)
- 어떤 요소로 이루어져 있눈지, 데이터를 어떤 모습으로 저장할 것인지 표현
- 표현 대상 정의(개체, 관계)
- 정적(static)

연산(operation)
- 데이터 구조에 따라 표현된  값들을 처리하는 작업
- 연산을 톨해 한 상태에서 다른 상태로 전이
	- 데이터베이스 상태 : 한 시점에 DB에 표현되어 있는 인스턴스들
- 동적(dynamic)

제약조건(constraint)
- 데이터 @무결성 유지를 위한 구조적 측면(허용될 수 있는 개체 인스턴스), 의미적 측면
	(허용되는 연산의 한계)의 제약사항


관계 데이터 모델
- 수학에서의 @릴레이션(relation)과 집합(set)이론에 기초한 데이터 모델
- 직관적으로 테이블 형태로 생각
@릴레이션이란 관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위이다.

속성(Attribute)
- @데이터베이스를 구성하는 가장 작은 논리적 단위
- 릴레이션의 열
- 릴레이션에서 관리하는 구체적인 정보 항목
- 개체(entity)의 특성을 기술
- 동일 릴레이션 내에서는 동일한 이름의 속성이 존재할 수 없음
- 파일의 필드에 해당
- 릴레이션의 @차수(degree) : 속성의 개수
	- 릴레이션의 속성의 개수인데 이것으로 데이터베이스의 값을 알아낸다? 크기?

튜플(Tuple)
- 속성의 모임으로 구성
- 렐레이션의 행
- 릴레이션 -> 현실세계의 개체
  튜플 -> 개체에 속한 구성원 개개의 정보
- 한 릴레이션에 포함된 튜플의 개수는 시간에 따라 변할 수 있음
- 파일의 레코드에 해당
- 릴레이션의 @카디널리티(cardinality) : 릴레이션에 포함되어 있는 튜플의 수
	|A| = 집합에서의 카디널리티 - 집합안에의 원소의 개수

도메인(Domain)
- 속성 하나가 가질 수 있는 모든 값의 집합
- 속성 값을 입력/수정할 때 적합성 판단의 기준이 됨
- 일반적으로 속성의 특성을 고려한 @데이터 타입으로 정의
EX) 데이터베이스에서의 데이터 타입이다.

널(null) 값
- 속성 값을 모르거나 적합한 값이 없는 경우, 널(null)이라는 특별한 값을 사용하여
	@값이 없음을 표현함
- 0이나 공백 문자와는 다름
null로 되어있는것과 0과 다르다
null은 값이 얼마인지 얼마나 있는지를 모르는 상태
0은 다른 값이 넘어오고 최종적 값이 0 이라는 것


릴레이션(Relation)

렐레이션 = 릴레이션 스키마 + 릴레이션 인스턴스
릴레이션 스키마
- 구조를 정의하는 것
	- 속성들
릴레이션 인스턴스


릴레이션 스키마
- Relation schema; 릴레이션 내포(intension)
- 릴레이션의 @논리적인 구조
	- 릴레이션 타입
- 릴레이션의 이름과 릴레이션에 포함된 송석드르이 집합
	- 예 : 고객(고객아이디, 고개깅름, 나이, 등급, 직업, 적립금)
- 정적(static)
	- 시간에 따라 (자주) 변경되지 않음
릴레이션이란 관계가 있는것에 대한 의미?
	EX) 이재은 - 폴더3
		이재은 - 폴더2 는 관계가 없다.

릴레이션 인스턴스
- Relation instance; 릴레이션 외연(extension)
- 어느 한 시점의 릴레이션에 포함되어 있는 튜플들의 집합
	- 예 : {'apple', '김현준', 20, 'gold', '학생', 1000>,..
- 릴레이션의 내용, 상태
- 동적(dynamic)
	- 삽입, 삭제, 수정 등으로 시간에 따라 변함

릴레이션
- 관계 데이터 모델은 개체(entity)나 관계(relationship)를 모두 릴레이션(relation)이란
	한 가지 방법으로 표현함
- 릴레이션의 개념적 정의
	- 릴레이션 스키마 + 릴레이션 인스턴스

(관계) 데이터베이스
- 데이터베이스 스키마 + 데이터베이스 인스턴스
- 데이터베이스 스키마
	- 데이터베이스의 전체 구조
	- 데이터베이스를 구성하는 @릴레이션 스키마 모음 + @무결성 제약조건
- 데이터베이스 인스턴스
	- 데이터베이스를 구성하는 릴레이션 인스턴스의 모음
- 데이터베이스를 시간에 따라 그 내용(상태)이 변할 수 있는 테이블 형태로 표현

릴레이션의 특성
 - 한 릴레이션에 동일한 튜플이 존재할 수 있을까?
	- 튜플이 유일성(uniqueness of tuples)
	- 한 릴레이션에 포함된 튜플들은 모두 상이함

- 다음 두 릴레이션은 동일한가? 다른가?
	- 튜플의 무순서성(no ordering of tuples)
	- 한 릴레이션에 포함된 튜플 사이에는 순서가 없음

- 다음 두릴레이션은 동일한가? 다른가?
	- 속성의 무순서성(no ordering of attributes)
	- 한 릴레이션을 구성하는 속성 사이에는 순서가 없음

@스키마, 튜플들은 집합이기 때문에 순서가 달라도 값이 같다면 같은 릴레이션이다.

- 다음 릴레이션은 적절한가?
	- 학과 스키마에 {컴퓨터, 산경} 이라고 쓰여있다
	- 데이터베이스에서는 속성은 하나만 갖도록 한다.
	- 속성의 원자성(automicity of attrubutes)
	- 모든 속성 값은 원자 값(atomic value)임
	- 그래야 데이터베이스를 관리하기 용이해진다.


@키(Key)
- 튜플을 유일하게 식별하기 위한 고유한 값을 저장하는 속성이 필요함

@키(Key)
- 릴레이션에서 각 튜플을 유일하게 식별하는 속성 또는 @속성들의 집합
- 데이터를 검색하거나 정렬할 때 기준이 되는 유일하게 구분되는 속성

유일성과 최소성
- 유일성(uniqueness)
	- 키의 값만으로 하나의 튜플을 유일하게 식별할 수 있는 능력
- 최소성(minimality)
	- 각 튜플을 유일하게 식별하는데 꼭 필요한 속성으로만 키가 구성되어야 함	
		- EX) 학번, 주민번호가 같이 있다면 최소성을 만족하지 못함.
- 예: 학생(학번, 주민번호, 이름, 학과, 이메일주소, 전화번호)
	- @{학번}, {학번, 주민번호}, {학번, x이름, x학과}
	- @{주민번호}, {이메일주소}, {전화번호}
		- 이메일이 없을수도 있다.

슈퍼키
- Super Key
- 유일성은 만족하지만 최소성은 만족하지 않는 속성 또는 속성들의 집합
	- 학생(학번, 주민번호, 이름, 학과, 이메일주소, 전화번호)

후보키
- Candidate Key
- 유일성과 최소성을 모두 만족하는 속성 또는 속성들의 집합
	- 학생(학번, 주민번호, 이름, 학과, 이메일주소, 전화번호)
		- 여기서의 후보키는 학번, 주민번호 이다.
		- 둘 중 하나를 사용해서 기본키로 사용한다.

기본키
- Primary Key(PK)
- 튜플을 식별하기 위해 후보키 중에서 DB설계자가 지정한 하나의 키
- 각 튜플에 대한 기본 키 값은 항상 유효한 값이어야 함.
- null 값이 허용되지 않음
	- 학생(학번, 주민번호, 이름, 학과, 이메일주소, 전화번호)
		- 학번, 주민번호 둘 중 뭐로 기본키로 사용할까

대체키
- Alternate Key)
- 후보키 중에서 기본키로 선택되지 못한 후보키, 보조키 라고 부른다.
	- 학생(학번, 주민번호, 이름, 학과, 이메일주소, 전화번호)
	- 여기서 학번이 기본키라면 주민번호가 대체키 이다.

외래키
- Foreign Key(FK)
- 어떤 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
- 외래키 속성의 도메인과 참조되는 기본키 속성의 도메인은 같아야 함

참조하는 릴레이션(referencing relation)을
- 참조 릴레이션

참조되는 릴레이션(referenced relation)을
- 피참조 릴레이션

-외래키
- 한 릴레이션에 외래키는 여러 개 존재할 수 있음
- 외래키를 기본키로 사용할 수도 있음
- 같은 릴레이션의 기본키를 참조하는 외래키도 가능
	- 추천아이디, 추천고객이 예시이다.


@기본키와 외래키
- 기본키와 외래키의 관계는 개체와 개체를 연결하는 도구로 사용됨
- 기본키 : 개체 식별자(entity identifier)
- 외래키 : 개체 참조(entity reference)

참조 관계
- 학과 릴레이션에서 멀티미디어 학과 튜플이 삭제되면?
	- 안된다 무결성의 문제가 생긴다.
- 학과 릴레이션에서 정보통신 학과의 학과번호가 25로 변경되면?
	- 
- 학생 릴레이션에 학과번호가 50인 학생 튜플이 삽입되면?
	- 이것또한 무결성을 회손시킨다.
그래서 있는게 무결성 제약조건 이다.


무결성 제약조건(Integrity Constranint)
@데이터베이스 스키마 = 데이터베이스를 구성하는 릴레이션 스키마 모음 + 무결성 제약조건
무결성 : 데이터에 결함이 없는 상태, 즉 데이터가 정확하고 유요하게 유지된 상태

무결성 제약조건
- 데이터베이스 상태가 만족시켜야 하는 조건
- 데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙
- 사용자의 의한 데이터베이스 갱신이 데이터베이스의 무결성/일관성을 깨지 않도록 보장하는 수단.

- 도메인 제약조건
- 키 제약조건
- 개체 무결성 제약조건
- 참조 무결성 제약조건

도메인 제약조건
- 각 속성 값이 반드시 원자값이어야 하며
- 데이터 타입을 통해 값들의 유형을 제한
- 디폴트 값(기본값)을 지정
- 속성에 저장되는 값의 번위를 제한
	- 나이 : 0 ~200
- NOT NULL : 모든 튜플에서 해당 속성 값이 존재하도록 보장

키 제약조건
- 키 속서엥 중복된 값이 존재해서는 안됨
	- 기본키
	- UNIQUE(대체키)

개체 무결성 제약조건
- 기본키를 구성하는 어떤 속성도 널(nul)값을 가질 수 없음
	- DBMS는 어떤 속성이 기본키인지 알고 있어야 함
- 데이터 식별을 위해 필요

참조 무결성 제약조건
- 릴레이션의 외래키는 참조할 수 없는 값을 가질 수 없음
- 외래키 값은 반드시 피참조 릴레이션의 기본키 값이거나 @널(null)이어야 함
- 두 릴레이션의 연관된 튜플들 사이의 일관성 유지를 위해 필요

무결성 제약조건 유지
- 현재 데이터베이스가 모든 무결성 제약조건을 만족하고 있을 경우,
	- 검색 연산을 수행하 결과 제약조건이 위배될 수 있는가?
		- 검색연산은 안전하게 수행할 수 있다. 값을 조회만 하기 때문
	- 삽입, 삭제, 수정 연산은?
		- 삽입, 삭제, 수전 연산을할때 무결성 제약조건이 위배될 수 있다.

삽입
- 무결성 제약조건을 위배하는 삽입 연산은 DBMS가 거절하여 무결성 유지

삭제
- 참조 무결성 제약조건 만족을 위한 옵션
	- @제한(restricted) : 삭제 연산 거절
	- @연쇄(cascade) : 참조 릴레이션의 참조 튜플도 삭제
	- @널값(nullify) : 참조 릴레이션의 참조 튜플의 외래키에 널 값을 설정
	- @기본값(default) : 참조 릴레이션의 참조 튜플의 외래키에 기본값을 설정

수정
- 삭제에서처럼 제한, 연쇄, 널 값, 기본값 옵션을 릴레이션 정의문에 명시


정리
- 관계 데이터 모델이란 무엇인가?
- 릴레이션은 어떤 특징을 갖는가?
- 키의 개념과 종류?
- 무결성 제약조건?


정리 문제 1 : 왜래키
다음과 같이 외래키가 설정되어 있다.
다음 각 연산 수행 시 참조 무결성 제약조건 만족 여부를 검사할 필요가 있는가?
- 고객 릴레이션의 고객 아이디
	- 삽입 X
		- 체크 안해도 괜찮다. 제약조건 회손 가능성이 없음
	- 삭제 O
	-	- 체크를 해줘야 한다.
	- 수정 O
		- 체크를 해줘야 한다.
	- 검색  X
		- 체크 안해도 괜찮다. 검색만 하기 때문
- 주문 릴레이션의 주문고객
	- 삽입 O
		- 체크를 해줘야한다. 엉뚱한 값이 들어가면 안되기 때문
	- 삭제 X
		-  체크를 안해줘도 괜찮다. 엉뚱한 값을 가지지 않기때문
	- 수정 O
		- 체크를 해줘야한다.
	- 검색 X
		검색만 하기 때문.


