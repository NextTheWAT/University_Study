운영체제 13주차


<파일 시스템의 개념>

- 논리적 저장 단위인 파일을 정의하고 메모리에 매핑시키는 기능을 제공
- 파일을 구성하고 데이터 액세스를 관리하므로 파일 시스템은 데이터를 실제로 저장하는
  파일과 이를 계층적으로 연결하는 디렉터리로 구성된다.
- 디스크 저장소를 관리(저장 공간 할당)하는 것과 관련이 많고, 메인 메모리와 다른 매체에 저장된 파일 데이터 엑세스도 포함
- 사용자가 파일을 생성, 수정, 삭제할 수 있도록 지원하며, 파일을 각 응용 프로그램에 가장 적합한 구조로 구성할 수 있도록 지원ㄴ
- 파일 읽기, 쓰기, 실행 등을 다양하게 엑세스 하도록 제어된 방법도 제공
- 파일 시스템 설계 -> 사용자 수, 사용자 당 평균 파일 수와 크기 등 사용자 정보가 필요하고, 해당 시스템에서 실행할 응용 프로그램의 특성을 이해하여 적합한 파일 구성과 디렉터리 구조 결정해야함

(513 p.파일이름짓는거) - 직접적인 접근이 불가능(부모님이나 할아버지가 짓는 것 처럼)
(챕터 11)  - 528페이지 분산 시스템(처리시간이 빠르고 처리량이 많다) = 2개이상의 시스템이 결합(결합관계가 문제)
             - 529페이지 강결합(프로세스가 메모리를 공유) 약결합(그림11-2처럼 프로세서가 메모리를 각각 가지고 있는 것을 의미) 관계 <상호작용적인 면이 약하다)
             - 530페이지
             - 트리구조 -> 연결관계 표현 괜찮음 
             - 선형구조 -> 병목현상
             - 링 구조   -> 원형인 상태에서 서로 서버들이 연결, 구현이 간단하고 비용이 적다 (속도가 상당히 느리다)
             - 버스 구조 -> 532페이지 그림에 나와있음
             - 534페이지 (분산의 목적 - 자원공유)
             - 536페이지 신뢰성향상 왜 의미? - 여러개를 사용하니까 하나 고장나도 대체가능 신뢰성 증가!

<분산시스템>
- 연산속도 증가
- 자원공유도 포함됨 -> 데이터베이스의 특징이라고도 할 수 있다
- 신뢰성향상, 통신가능

<클라이언트 서버 장점>- 545페이지
- 정보를 이용하면 클라이언트
- 정보를 제공하면 서버이다.  

592페이지 (단어 이해하자)
<기술적 고안, 물리적고안, 관리적 고안 정의정도만 알아두자>
- 기술적 고안: 불법공유를 막기위한 소프트웨어 조치
- 물리적 고안: 허가 받지 않은 접근 차단에 대한 모니터링 활동
- 관리적 고안: 조직 내부의 체계

594페이지 <고안의 특성>
- 기밀성 보장
- 무결성 보장(데이터의 순수성)
- 가용성 보장
- 엑세스 제어

<보안 위험의 유형?>
- 4가지 정도! 

<597페이지>
- 웜, 트로이목마, 등등 (바이러스 관한걸 말한다)

<챕터 13 유닉스>
- 632page 대화형(시스템)
- 대화형 시스템
- 다중사용 시스템: 여러 사람이 사용할 수 있다는 특징(동시 접근 허락), 키보드 마우스가 2개이상 있어야 한다는 뜻이다.
- 다중작업을 허용
- c언어의 특성을 그대로 유닉스가 가지고 있음
- 계층적 트리 시스템(파일에 대한 소속, 계층성을 표현하는데 쉬움)

634페이지
- 유닉스의 구성
- 하드웨어, 커널, 쉘
- 커널의 역할: 프로세스,메모리,파일 시스템, 장치 관리 -> CPU에서 하는건 다 하는거임 명령어 처리도
- 커널을 보호해주는게 쉘 (직접적인 접근을 막기위해)
- 명령어 해석기 (쉘에다가 명령)

<보안, 유닉스 문제 나올 떄도 있음!, 분산도 나올수도 있음>
3챕터! 그렇게 중요하지않고 문제도 그렇게 많이 나오지 않음
파일 명령법, 파일 구조정도만 알면 된다.







<중간고사 범위 포함한다>
- 1장 22PAGE 레지스터의 종류 (알아보자) , 프로그램카운터,IR,누산기(AC),

- 1장 MAR,MBR레지스터 확인해보자

- 26PAGE 캐시의 특징 왜 필요한가.(속도차이)

- 34페이지 인터럽트에 대한 사이클( 명령어처리가 어떻게 진행되는지) => PC -> MAR(어디로 가려나보다!) => PC+1(일할거 다했으니 다음꺼 일해야지!) , MBR->IR(명령어를 실행하겠다는 의미이다) =보통 3줄로 끝냄
   [(마이크로 오퍼레이션 (확인해보자)] 
   [메모리 MAR(메모리값을) -> MBR(MBR에 넣는다)]  ==유추해석==(나온다고 확인하자)  , 인출사이클, 

- 36페이지 인터럽트가 무엇인지 확인 (PC->MBR는 프로그램 카운터는 갖고있는게 현재 중단된 위치!) MAR이면 중단된 위치의 주소(MAR이 훨씬 낫다)
  (PC의 역할이 위치를 저장하는 역할이니 MAR이 훨씬 낫다)

- 2번 인터럽트 루틴의 주소를 PC에 넣는다?( 책이 일관성이 없다 ) ==말은 맞음 주소를 PC에 넣었으니까!

- 49PAGE 운영체제의 목적  : 편리성(윈도우의 등장 배경이기도 함), 효율성<처리량 향상>, 신뢰도<정확성,사용 가능도, 안정성> 향상),  제어성 

- 51PAGE: 운영체제의 기능들 확인하기 

- 65PAGE: 시분할, 다중프로그래밍의 확장적인 의미
            = 시분할로 실행하게 되면 대화형으로 진행이 가능하다.

- 66PAGE: 시분할의 장점 (빠른응답 등등) - 대화형 시스템을 구현하기 쉽다.(큰장점)
- 66PAGE: 시분할의 단점도 확인하자
- 66PAGE: 다중처리! (다수의 프로세스로 처리하는 것, 하나의 프로그램을 여러개 나누는 것도 멀티 스레딩), 프로세스를의미  --> ** 하나의 작업을 여러개 나눠서 중복작업을 하는 것! 
- 66PAGE: 다중작업: TASK를 의미, 한번에 여러개의 일을 수행하는 거다  //(EX) 유튜브보면서 워딩치는 것



- 92PAGE: 프로세스, 스레드?
    - 실행중인 PG의 실행단위 , 프로세스 실행에 대한 정보는 PCB에 있다!

- 95PAGE: 프로세스 종류(시스템, 사용자)
  => 시스템 프로세스는 커널이 통제, 사용자 프로세스는 사용자에 의해서 통제

- 97PAGE: 프로세스 상태변화
  => 대기가 가장 많이 나옴! (다른거는 다 기본적인 거 이기 때문에)
  => 대기가 발생한 것은 이벤트가 발생한 것이다(이벤트의 핵심은 인터럽트임)
  => 입출력 신호 발생(인터럽트)
  => 그림도 한번 살펴보자! 왜 인터럽트가 발생, 왜 대기상태로 넘어가는지

- 111PAGE: 스레드랑 프로세스의 관계 확인해보자! (그림)

- 117PAGE : 스레드와 프로세스 (실질적이라는 말이 없으면 프로세스 있으면 스레드)

- 119PAGE: 3-22 하드웨어, 커널(스레드가 일일이 대응 1대1 매핑 진행), 사용자영역

- 136PAGE: 병행 프로세스
  => 공유영역 -> 병렬영역


- 188 PAGE: 교착상태(실행가능한데 서로 엉켜있는거라고 생각)
- 189 PAGE: 그림 보자
- 교착상태 발생 4가지!
- 강 건너기 그림 확인해보자

- 기아상태는 아예 못하는 것을 의미한다. (4인인데 3인실 주는 것)
- 최소작업우선순위가 대표적이다. 

- 228 PAGE : 스케쥴링 **** 매우 중요하다고 말씀하심
  => 프로세스 스케쥴링, 메모리 레벨, 디스크 레벨, 단어만 조금씩 다르지만 기본개념은 같다!
  => 단어는 외워라

- 229 PAGE 
  => 스케쥴링 목적(*응답시간 최소화, *처리량 확대, 공정성보장, 예측가능성 [보장까지는 안해도 ㄱㅊ], 오버헤드 최소화)

- 242PAGE: 선입선출***
  => 칸트 차트?는 그려야하고 큐에대한 내용만 나온다

- 245PAGE: 선입선출 장단점

- 선점형, 비선점형 말없으면 선점형이다. 
  => 기본적으로 아는 SJF 그냥 하면 된다.
  => 우선순위 스케쥴링
 
- 253 PAGE : 라운드로빈 시분할이랑 똑같다
  =>물어보면 FIFO나 SJF만 물어본다. 돌아가는 원리, 장단점만 알면 된다.
 
- 263 PAGE:  ** SJF 단점을 보완

- 290 PAGE: **메모리관리 (적재   ,대치<**FIFO, **LRU, **LFU(불려진 횟수가 많아질수록 중요하다!),> ,     배치<최저,최악,최초> 정책 등등  -> 순서 거꾸로가 중요도임)
   --> 프로세스가 들어가는 공간 프레임(3개로 나옴)

- 298 PAGE: 고정, 가변 할당
  => 프로세스가 들어가는 고정적인 분할상태: PAGE
  => 가변적으로 들어가는 공간: 세그멘테이션 //구현이 복잡하다
  => 버디시스템?  //313페이지에 나와있음

- 314 PAGE: 고정크기블록으로 나누어진 것을 페이지
  => 페이지에는 프로세스가 들어가는 공간이다.
  => 페이지 공간이 3이면 프로세스가 3으로 고정이 아닌
  => 단편화 문제가 발생한다 (조그만한 공간을 사용할 수 가 없다)

- 356 PAGE: 가상메모리 //시험에는 잘,,,
  => 메모리가 부족하니까 (컴퓨터 구조 문제이다) 
  => 디스크를 메모리 처럼 사용 

- 371 PAGE: 페이지 대치 알고리즘
  => 선입선출
  => 372PAGE 그림 참고하자

- 374 PAGE: 최적 페이지 대체 알고리즘(OPT)
  => 자기가 예측을 함 최적한 곳에 넣는 것을
  => 이상적인 상태이다.

- 375PAGE: 최근 최소 대체 알고리즘?
  => 시험문제 한번 풀어보면서 진행해봅시다!
  => 공간지역성, 시간 지역성(시험에 가끔 나옴)
  => 시간지역성: 시간대가 비슷한 애들은 같이 불려짐 (함수, 서브루틴 등등)
  => 공간지역서: 같은 공간에서 호출되는 애들이 같은 위치에 있다(배열)
  => 순착코드: 순차적으로 일어나는 ,,, 공간지역성임
 
- 392 PAGE: 여기에 써져있음! 공간지역성, 시간지역성




- 426 PAGE: 입출력 시스템
   => 입출력장치는 다 느린 애들임,,, 
   => 그래서 CPU가 통제하기에는 억울함,,, 그래서 입출력 시스템 사용
   => 모듈이 붙어있는 이유는 디스크 따로, 키보드따로 다 따로 통신해야함, 난잡한 것을 통제하기 위해
   => USB는 CPU랑 통신하기 위함
   => 입출력장치, 주기억장치, CPU(일하는 건 CPU밖에 없음)

- 428 PAGE: 입출력 모듈의 특징
   => 타이밍 기능을 제공 (시간을 컨트롤 해야함)
   => 맘대로 바꾸면 안되기 때문에!
   => 프로세스에서 명령어를 제공받고 ~~~~ 책에서 보자!
   => 버퍼링을 이용하여 속도를 조절한다. (버퍼에 할당하고 너네 이거하고 있어! 라고 시키는거임)
   => 오류검출을 안하면 왜 기다려야하나 (정상인지, 비정상인지 구분하기 못하기때문)

<입출력장치, 입출력 모듈시스템에서 직접관리, DMA, 인터럽트 기반으로 할 수 있다.>
- [단어 정리]
   => 모듈: 시스템에 일종의 부분을 담당 EX) 사람으로 따지면 머리, 팔 등을 의미한다. 
   => 모듈화: 떨어져있어도 자기 기능을 잘 수행하는 ,,, 함수가 대표적인 예시이다.
   => 프로토타입: 시제품(상형화 되지 않은), 알파베스트의 전 단계 제품(출시 전 단계)


- 431 PAGE: 인터럽트 기반 입출력
  =>은행에서 번호표를 생각하자! (뽑고 기다려라,,,)
  => FIFO 구조! 다만 우선순위가 높은애들이 오면 먼저 처리해줌!
 
- 432PAGE: DMA(메모리가 입출력 바로 관리)
  => 프로세스의 부담이크다, 메인메모리를 직접하여~~~
  => 일반적인 입출력장치는 CPU가 담당을 함 근데 DMA는 메모리가 바로 관리하는 거임)
  => 그림을 한번 살펴보자

- 429 PAGE: 프로그램 제어 입출력
  => 입출력 주소와 데이터를 따로따로 해서 처리한다.
  => 검은색 줄은 데이터, 파란색 점선, 주소만 처리하는 것!

- 445? 435 PAGE: 셀렉터
  => 여러개의 장치를 하나로!
  => TV에서 영화도보고 노트북으로 보는것! 영화를보면 노트북이 안보이고,,
  => **멀티플렉서: 2개를 동시에 볼 수 있는 것
  => 2 * 4 멀티플렉서는 2의 2승이므로 총 4개의 신호를 만들어 낼수 있음

- 438 PAGE 캐싱
  => 캐싱, 스풀링: 둘다 속도차이 때문에 사용된다
  => 스풀링은 일반장치와 CPU , 캐싱은 CPU와 메모리
  => 버퍼링도 속도차이임.

- 440PAGE 디스크 구조
  => 442PAGE를 기억
  => 헤드가 트랙을 탐색하는게 *****탐색시간 
  => 트랙에서 데이터가 있는 세타로 이동하는게 회전 지연시간
  => 전송시간은 데이터를 읽어들이는 시간을 전송시간
  => 디스크는 하드디스크를 구성할떄 여러장의 디스크로 구성 그것을 팩이라고 한다.
  => 한팩에는 10장 동일한 트랙번호가 10개 있다는 것, 모여있는 걸 실린더 (한팩 = 실린더)
  => 실린더: 원통의 기둥임 T1, T2, T3 등 각각 트랙마다 뭉쳐놓고 세운 기둥을 실린더라고 하는거임( 그림으로 설명가능)
  => 같은 트랙의 영역을 모아둔 것을 실린더라고 한것
  => 실린더, 세타, 탐색
  => 디스크 스케쥴링 445PAGE : FCFS, SFTF, SCAN, CSCAN, SLTF, SPTF, LOOK (FCFS ,CSCAN, LOOK정도 --거리문제, 설명)
  => SCAN은 가는 방향으로 쭉 가는 것을 의미한다. 255 PAGE로 나온다
  => CSCAN은 뒤에 있는 애들이 피해를 안봄 SCAN은 끝까지 가기때문에
  => LOOK은 보이는 데 까지 가자
  => 0번 트랙에서 255번 트랙으로 시험에 나옴
  => 레이드 시스템??? ==가끔 나옴==
  

<내용만 적어라. 최대한 아는거 써라>