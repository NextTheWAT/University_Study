운영체제 10주차

챕터6 @
메모리까지 중요하다@
메모리관리까지@
가상메모리까지

디스크관리 안중요함


메모리 관리의 개념
- 메모리 관리는 프로세스들을 위해 메모리 할당, 제거, 보호하는 활동
- 디스크에 있는 프로그램을 실행하려면 먼저 메모리에 적재 후 메모리 관리자가 예약된 메모리 할당해 주는 것
- 다중 프로그래밍 시스템에서 여러 프로세스가 메모리에 상주할 수 있도록 운영체제가 동적으로 메모리 세분화

메모리 관리 정책
- 적재 정책 : 디스크에서 메모리로 프로세스 반입 시기 결정하는 것
	- 요구 적재 : 운영체제나 시스템 프로그램, 사용자 프로그램 등 참조 요청에 따라 다음에 실행 할 프로세스를
				메모리에 적재하는 오래된 방법 
	- 예상 적재 : 시스템의 요청을 미리 예측하여 메모리에 적재하는 방법
- 배치 정책 : 디스크에서 반입한 프로세스를 메모리 어느 위치에 저장할 것인지 결정
- 대치 정책 : 메모리가 충분하지 않을 때 현재 메모리에 적재된 프로세스 중 제거할 프로세스를 결정하는 교체 방법


스케쥴링의 개념
- 여러 프로세스가 번갈아 사용하는 자원을 어떤 시점에 어떤 프로세스에 할당할지 결정
- 좋은 스케줄링은 프로세서 효율성 높이고, 작업의 응답시간 최소화하여 시스템의 작업 처리 능력 향상
- 스케줄링 방법에 따라 프로세서를 할당받을 프로세스 결정하므로 스케줄링이 시스템의 성능에 영향 미침
- 반면에 스케줄링이 필요한 프로세스에는 사용자 프로세스와 시스템 호출로 발생하는 시스템 프로세스가 있음











-----민재------

1. 메모리 관리의 개념
 - 메모리 관리는 프로세스들을 위해 메모리 할당, 제거, 보호하는 활동
 - 디스크에 있는 프로그램을 실행하려면 먼저 메모리에 적재 후 메모리 관리자가 예약된 메모리를 할당해 주는 것
 - 다중 프로그래밍 시스템에서 여러 프로세스가 메모리에 상주할수있도록 운영체제가 동적으로 메모리 세분화

2. 메모리 관리 정책
 - 적재정책: 디스크에서 메모리로 프로세스 반입 시기 결정하는 것
    -> 요구 적재: 운영체제나 시스템 프로그램, 사용자 프로그램 등 참조 요청에 따라 다음에 실행 할 프로세스를
                       메모리에 적재하는 오래된 방법


3. 스케줄링의 개념
 - 여러 프로세스가 번갈아 사용하는 자원을 어떤 시점에 어떤 프로세스에 할당할지 결정
 - 자원이 프로세서인 경우를 프로세서 스케줄링, 대부분의 스케줄링이 프로세서 스케줄링 의미
 - 스케줄링 방법에 따라 프로세서를 할당받을 프로세스 결정하므로 스케줄링이 시스템의 성능에 영향이 미침
 - 좋은 스케줄링은 프로세서 효율성 높이고, 작업의 응답시간 최소화하여 시스템의 작업처리능력 향상
 - 스케줄링이 필요 없는 프로세스(인터럽트 처리, 오류처리, 사용자의 시스템 호출 등)의 사전 처리가 대표적
 - 반면에 스케줄링이 필요한 프로세스에는 사용자 프로세스와 시스템 호출로 발생하는 시스템 프로세스가 있음

 
4. 스케줄링 특징
 - 교착상태, 
 - 자원 할당 관리
 - 오버헤드 최소화
 - 실행대기 방지
 - 에이징 기법(오래 기다린 것을 의미)
 - 우선순위에 따라 처리한다.          

5. 선입선출 스케줄링
 - 비선점방식 ,,, ,대화형 방식에는 좋지는 않음
 - 뒷작업들이 대기시간이 길어지는 현상이 발생가능하다
 
6. 최소작업 우선 스케줄링(SJF)
 - 평균대기시간이 짧다
 - 기아상태발생 --계속 짧은 놈이 들어오면 뺏기기 때문이다.
 - 불공정한 작업을 실행한다.(당근 최소작업을 먼저하기 때문이지)
 - 예측하기가 너무 어려워짐(언제끝날지 모르는 것이다) <-- 짧은놈이 ㅈㄴ돌아가니까

7. 라운드로빈(계산하는 문제 안나옴) 
 - 시분할시스템을 위해 설계되었다.
 - 대화형 프로그램에 적합하다.
 - 기아상태가 발생하지 않는다 (계속 돌아가기 때문)
 - 상호작용, 응답시간, 프로세스의 최악의 응답시간도 알 수 있다.
 - 작업길이가 다양할 때는 대기시간 선입선출, SJF보다 적다.
 - 작업량이 비슷한게 좋다 (너무 길면 선입선출 짧으면 문맥교환의 비용이크다.)
 - 문맥교환(인터럽트 발생을 예시로 들었다 왔다갔다하는 것)
 - read/write가 굉장히 오래걸림
 - 하드웨어 타이머가 필요함
  싀발 ㅈㄴ 힘드네 개같은거  

8. HRN 스케줄링
- Highest Response-ratio Next
- 서비스를 받을시간 + 대기시간 / 서비스를 받을 시간
- 기아가 발생하지 않고 자원을 효과적으로 사용한다. 
- 오버헤드가 높을 수 있다(메모리와 프로세스 낭비가 심하기 때문,, 계산을 많이 하니까!)
- 긴작업의 문제점을 해결한 버전이 hrn이다.


============================================================
< 가상 메모리 >
< 입출력 시스템 > 
---> 444페이지 디스크 스케줄링!!               
---> 프로세스 스케줄링이 더 중요하게 나온다.               
---> 445 그림 9-18 , 최소 탐색시간 스케줄링 등등(FCFS~~~)                         
---> 탐색시간 최적화에서 많이 나온다.                        
---> 446페이지 선입선처리 --거리를 따지게 된다.--                       
---> 최소 탐색 시간 우선 스케줄링(시험) ---총 거리량이 얼마냐?                       
---> 선입선출, SSTF가 잘나옴(시험에 말이죠)  <기말이야 기사야>                     
---> 448페이지 스캔 스케줄링(끝가지가다가 마지막트랙에서 쭉쭉가는거)
---> 순환스캔 스케줄링은 먼저 부른놈부터 먼저 가겠다~~


---->RAID 시스템: 디스크 하나로 해결 못하잖아? 하지만 여러개 달지도 못해 왜? 인터럽트 신호가 15개 전 후로 밖에 없거든
                        - 모든 장치는 인터럽트 신호를 가지고 있는데
                        - 여러개 하드디스크를 하나의 디스크 처럼 사용하는 것 Naas
                              -> 40테라인데 하나의 c로컬디스크에서 사용이 가능한 것이 장점이다.

290페이지
- 적재정책, 배치 정책, 대치 정책이 핵심이다. (매년 100% 나온다.)
(1) 적재정책: 디스크에서 메모리에 올리는 시기를 결정하는 것이다.
        -요구 적재: 나 필요해 올려줘! 라고 하면 올려주는 것
                  -예상 적재: 필요할 것 같은데? 미리 올려주는 것


(2) 배치 정책: 프로세스를 어디 위치에 넣을 것이냐 이게 배치 정책
  - 첫번째 큰 공간 최초적합
- 적당한 공간(내가 들어갔을 때 제일 빈공간이 적은 것) //최저적합 
    = 쓸수없는 공간을 단편화 라고 한다 ex)디스크 조각정리
- 최악 적합: 가장 넓은 공간에 들어가서 남는 공간도 많은 상황


(3) 대치 정책
- lfu: 호출을 얼마나 많이 하나


291 페이지
<메모리 매핑>
- 논리적주소와 물리적 주소를 매핑(다양한 형태의 메모리 구조가 나타남)
- 이때 나오는게 고정분할, 동적분할, 페이징, 세그먼테이션

- 동적 적재: 필요할 때 메모리에 들어감(메모리 절약이가능)
                 하지만 관리가 어렵고 속도가 느림

- 정적 적재: 메모리에 그냥 올라가있는 것이다 쓰던 안쓰던(속도는 무진장 빠름)
- 페이징 기법(고정분할) :  단편화 문제가 발생(내부 단편화이다)
- 세그멘테이션(가변분할) : 크기에 맞게 분할하여 주는 것이다. 속도가 좋지만 시간이 느리고 복잡하다.

- 연속메모리할당: 연속해서 데이터를 넣고
- 불연속메모리할당: 떨어트려서 넣어도 되는 것임 (불연속이 더 좋음)

-------------------------------페이징기법 세그멘테이션 기법이 가장 많이 나옴!! 이거 알아보자!!!!!!-----------------------------------
==========================================================================================
<버디 알고리즘>  <--시험에는 안나옴
- 그림 7-27
- 데이터가 초반에 8K //먼저 자름 그럼 32  -> 또 자름 16 -> 또 자름 8 (오 여기에 넣으면 되겠네)
- 그다음 4가들어옴 // 8을 반으로 나누면 OK
- 그다음에 합쳐버림

========================
FAT32 FAT16 NTFS (포맷단위)
- 맨 처음 블록에는 부트블럭이 먼저들어감 
- 일반포맷, 로우포맷(공장초기화)--->다시 포맷도 해야함, 빠른 포맷(파일 로우테이션? 그거 초기화하는거임 그냥 다시까는거임)


<그냥 언급하신 것>
- TCP/IP , UDP 차이정도를 조금 알아두면 좋을 것 같다.
- 스케줄링 우선순위가 가장 중요하게 쓰이는 것(인터럽트에서 가장 중요하다)
- 스케줄링 목적 
- 분산만 알고 하자


메모리 공간
10, 2, 1, 12, 4, x - 6개?
들어올 프로세스 크기는 3kb

1. 최초적합 - 10
2. 최악적합 - 12
3. 최적적합 - 4

4. 입력 데이터 - 최초적합
5. 입력 데이터 - 최악적합
6. 입력 데이터 - 최적적합













