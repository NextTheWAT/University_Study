컴퓨터 네트워크 12주차 정리

프로세스간 통신 (Process-to-process Comunication)
- 포트번호 이용

(바이트) 스트림 배달 서비스 (Stream Delivry Service)

전이중 통신 (Full-Duplex Communication)
- 양방향 전송 : 양쪽 TCP는 송신 및 수신 버퍼를 동시에 가지고 있음.
- 송신 데이터와 수신 데이터에 대한 확인 응답을 함께 보내는 피기백킹

연결-지향 서비스 (Connection-Oriented Service)
- 송신 TCP와 수신 TCP간이 가상 연결 설정
- 요청 -> 승인 -> 데이터 교환 -> 해제

신뢰성 서비스 (Reliable Service)
- 오류제어: 확인 응답, 재전송, 시간-초과 메커니즘 이용
시간-초과 메커니즘 - 시간이 초과되었을때 다시 보내주는것
- 흐름제어: 슬라이딩 윈도우 프로토콜
- 혼잡제어 등

다중화와 역다중화

UDP는 흐름제어, 혼잡제어 복잡한 전송제어를 하지 않음
신뢰성을 제공하지않음 비신뢰성 서비스 - 비연결형
UDP는 데이터에대한 최종적인 에러검출을함

TCP는 양쪽끝단이 연결한뒤에 데이터를 보내고 연결을 종료함


프로세스간 통신 (Process-to-process Comunication)
- 포트번호 이용

20, 21번 - FTP서비스 파일
원격지에 접속할때는 21번을 사용
실제로 데이터를 전송할떄는 20번을 사용

23번 - TELNET 
25번 - SMTP - 이메일 전송을위한 프로토콜

80번 - HTTP - 웹 서버 포트
443번 - HTTPS - 암호회된 보안기능을 부여한 웹 서버 포트


스트림 배달 서비스 (Stream Delivry Service)
- 두 개의 프로세스가 가상의 튜브로 연결
	- 바이트 스트림 형태로 데이터 송수신
- 송신 TCP
	- 송신 프로세스로부터 바이트 스트림 수신(송신 버퍼 이용)
	- 적절한 크기인 세그먼트를 만들어 네트워크를 통하여 전송
- 수신 TCP
	- 세그먼트를 수신(수신 버퍼 이용)
	- 데이터를 추출하여 바이트 스트림으로 수신 프로세스에 전달

송수신 TCP양쪽은 일종의 튜브형태로 연결되어있다

송신 프로세스가 송신 TCP쪽으로 데이터에 대한 바이트 스트림 형태로 내려보냄
송신 프로세스로부터 수신받은 바이트 스트림을 상대방 TCP쪽에 튜브를 통해서
그 스트림을 그대로 흘려보낸다 라는 개념

실제로는 바이트 스트림을 세그먼트라고 하는 송신 데이터 단위로 구분해서
데이터를 전송하게 되는것

수신 TCP는 송신 TCP가 보낸 세그먼트를 수신
세그먼트에 포함된 바이트들이 수신 프로세스쪽으로 흘러감

TCP와 UDP의 큰 차이점
- @@ TCP바이트 스트림 배달 서비스는 메세지의 경계 구분을 하지 않음
- @@ 응용 계층의 메세지를 TCP단에서 전송할 때 구별하지 않는다

TCP와 UDP의 공통점
TCP와 UDP의 공통점 포트 번호를 이용하여 주소를 지정한다. 

- UDP 같은경우에는 응용 메세지를 구분한다
UDP는 메세지를 하나의 데이터그램으로 만들어서 전송한다
서로 다른 메세지에 포함되어 있는 데이터를 하나의 데이터그램으로 만들어서
전송하지 않는다 즉 메세지를 구별해서 전송한다


- 송신 버퍼와 수신 버퍼
	- 송/수신 속도의 불일치를 처리하기 위해 버퍼 필요
송수신 속도의 불일치를 처리한다라고 하는 개념 - 흐름제어
흐름제어와 동시에 슬라이딩 윈도우 프로토콜을 이용해서 송신 데이터에 대한
오류제어도 더불어 수행하게 된다.


- TCP 세그먼트
	- 일련의 바이트들을 세그먼트라는 패킷으로 그룹화
	  -> IP 계층에 전달
바이트들이 흘러가지만 이러한 바이트들을 모아서 데이터를 모음 - 세그먼트(패킷)


-번호화 시스템(Numbering System)
	- (데이터) 바이트 번호
TCP는 바이트마다 번호를 붙인다
바이트는 데이터의 바이트를 의미한다
	- TCP 세그먼트 헤더
		- 순서번호: 세그먼트에 포함되는 첫 번째 데이터 바이트 번호
첫 번째 데이터 바이트 번호가 순서번호 이다.
		- 확인응답번호: 수신하기를 기대하는 바이트의 번호
수신하기를 기대하는 바이트의 번호를 입력한다.
	ex) 101번부터 1000번까지 받았다 그럼 1001번을 보냄
					cf. 누적 확인 (Accumulative acknowledgment)
받을때마다 확인응답을 보내지 않아도 됨
누적해서 만약 10~20번을 받았다면 이거에 대한 대답을 한번만 해도 괜찮다

- 흐름제어 (Flow Control)
- 오류제어 (Error Control)
- 혼잡제어 (Congestion Control)


- TCP를 이용하여 두 개의 장치간에 전달되는 데이터 단위
	- (헤더 길이 : 20~60 바이트)
세그먼트 패킷
헤더				데이터
20~60Byte			

Source port address		Destination port address
	16bits					16bits
			Sequnce number
				32bits
			Acknowledgment number
				32bits
HLEN	Reserved	U A P R S F	Window size
4bits		6bits		R C S S U I	 16bits
				G K H T N N 	
		Cheksum			Urgent pointer
		16bits 				16bits
여기까지 20바이트
		Options and padding
			40바이트
총 60바이트
28분

Urgent pointer - 긴급한 데이터의 위치를 표기하는 것
			긴급 데이터의 끝위치를 포인터로 기록한다
			얼전트 포인터가 포함되어 있을 경우 제어 플래그값을 1로 셋팅

	
세그먼트
- 발신지 포트 번호(source port address) : 전송 호스트 응용 프로그램의 포트 번호
- 목적지 포트 번호(destination port address) : 수신 호스트 응용 프로그램의 포트 번호
- 순서 번호(sequence number) : 세그먼트에 포함된 데이터의 첫 번째 바이트에 부여된 번호
			cf. ISN: initial sequence number (초기순서번호) 
			ISN - 운영체제에 의해서 임의로 할당된 번호를 집어넣는 번호
			 SYN 세그먼트에 포함되어있는 순서번호를 ISN이라고 한다
- 확인 응답 번호(acknowledgment number) : 상대방 노드로부터 수신하고자 하는 바이트의 번호
	- 성공적으로 수신한 마지막 바이트 순서번호 + 1 	 	cf. piggyback
	- 누적확인응답(Accumulative acknowledgment)
- 헤더길이(header length) : TCP 헤더 길이의 4바이트 워드 값(5~12)
- 예약(reserved) : 차후의 사용을 위해 (6bits)
- 제어(control) : 제어 비트 또는 플래그


- 제어 필드(Control field)
URG: Urgent pointer is valid 
TCP세그먼트에 긴급 데이터가 포함되어 있을 경우 얼전트 포인터 값을 기록하고
이 경우 제어필드에서도 URG의 위치에 컨트롤 필드값을 1로 세팅
만약 긴급 데이터가 포함되어있지 않다면 0

ACK: Acknowledgment is valid
확인응답 순서번호가 포함되어 있을경우 1로 세팅

PSH: Request for push
세그먼트에 포함되는 데이터가 상대방에 수신 되었을때
상대방 TCP로 하여금 그 데이터를 즉시 수신 프로세스에게 전달하도록 요청할때 푸쉬 필드를 1로 설정

RST: Reset the connection
리셋 필드는 연결을 재설정 할 경우에 사용하는 것 

SYN: Synchronize sequence number
데이터를 보내기 전 미리 양쪽 끝단에서 먼저 연결을 확립할때
연결을 요청하는 세그먼트일 경우 SYN 필드를 1로 세팅

FIN: Terminate the connection
연결을 해제 하고자 할 떄 연결해제요청 세그먼트 일 경우
필드 값을 1로 세팅


세그먼트(계속)
- 윈도우 크기(windows size): 상대방이 유지해야 하는 바이트 단위의 윈도우 크기
윈도우 프로토콜은 흐름제어를 위해서 사용되는 필드
수신 버퍼에서 수신 가능한 바이트 크기 즉
수신 버퍼의 여유공간을 의미한다
상대방한테 자기가 받을수있는 수신버퍼의 여유 공간을 상대방에게 전달을하면 어떤 효과냐
상대방은 송신 윈도우 사이즈를 수신 측이 알려준 윈도우 사이즈 값에 의해서 결정하게 된다
윈도우 크기는 수신할수있는 수신 버퍼의 여유공간을 나타내지만 상대방으로 하여금 유지해야하는 바이트 단위의
송신 윈도우 크기다
결국 흐름제어는 송신측이 수신의 버퍼에 오버플로우가 생기지 않도록
송신량을 조절하는 것이지만 그러한 송신량을 조절할수있도록
수신측에 버퍼여유공간 정보는 결국 수신측에 의해서 결정된다는 것
	- 필드 크기 : 16bits -> 윈도우 최대 크기 : 65,535 bytes = 64KB
	- 윈도우크기(rwnd)는 수신측에 의해서 결정
cf. Window Scale Factor
0~14번
64KB X 2^14승까지 크기를 키울수있다 10MB
- 검사합(checksum) : 오류 제어
- 긴급 포인터(urgent pointer)
	- 긴급 데이터의 끝(일반 데이터의 시작) 표시
- 옵션(option) : 옵션 정보


검사합
- UDP와 동일한 절차, 그러나 필수 사항(mandatory)
- 의사 헤더(pseudoheader)를 세그먼트에 추가
- 프로토콜의 값: 6





- TCP : 연결-지향 프로토콜		cf. IP: 비연결형
- 발신지와 목적지 간에 가상 경로 설정
	- TCP의 재전송, 순서정렬에 대해 IP는 알지 못한다.
실제로 TCP세그먼트를 실어 나르는 프로토콜은 ip인데 IP는 일반적으로 비연결형
데이터그램방식으로 통신을 한다 TCP는 연결형이지만 IP는 비연결형
연결지향 TCP는 순서를 보장하지만 IP는 순서를 보장하지 않는다는것 IP는 비연결형

- 연결설정 -> 데이터 전송 -> 연결 종료


연결 설정 2-7분
- 3단계 핸드셰이크(Three-way handshaking)
서버측의 트랜스포트 레이어는 어떤 클라이언트의 연결요청을 받아줄수 있는 응답할수있는
준비상태로 진입
우리가 보통 웹브라우저를 통해 웹서버에 접속하고자 할떄 웹 서버는 항상 구동이 되어 있어야함
클라이언트는 내가 필요할때만 웹 브라우저를 실행시키면 되지만 서버측의 프로세스는
항상 구동해 있어야된다는 뜻 이상태에서 클라이언트가 접속을 하라고 연결요청을 하라고
클라이언트 트랜스포트 레이어에게 명령어를 준다
명령어가 액티브 오픈(Active open)

명령을 받은 클라이언트 트랜스포트 측은 서버측 트랜스포트 레이어에게 연결요청
처음으로 세그먼트를 보내는데 8천번이라는 이메일값을 지정
이 필드는 32번까지 가능
SYN 컨트롤 필드 1번

그다음 확인응답을 보내는데 8천번을 받고 akc 8001번을 보내게 된다

반대방향으로도 연결요청을 서버가 하게 된다
따라서 서버측도 클라이언트한테 SYN세그먼트를 보내게된다
초기 순서번호도 15000번을 보내게된다

SYN세그먼트로 보내는 보낼 떄의 순서번호는 둘다 ISN이 된다

서버측의 5천은 수신 버퍼의 여유공간이 총 5천바이트라는 얘기다
이 말은 상대방측이 5천바이트를 보내더라도 버퍼에 오버플로우가 생기지않고
다 수신할수있다 라는 얘기다

SYN세그먼트는 비록 데이터가 포함되어있지 않더라도 순서번호 하나를 소비한다@

1,2,3 번을 거쳐 연결을 확립한다

ACK만 보내는 세그먼트는 순서번호를 소비하지 않는다 @
그 다음 세그먼트도 8001번이 된다

연결 설정(계속)
- 3단계 핸드셰이크(Three-way handshaking)
	1) Client -> Server : SYN 세그먼트
		- 하나의 순서번호를 소비
		- Client 측 ISN 포함
	2) Server -> : SYN + ACK 세그먼트
		- 하나의 순서번호를 소비
		- Server 측 ISN 포함
		- 수신자 윈도우 크기 (rwnd) 포함
	3) Client -> Server : ACK 세그먼트
		- 데이터를 전달하지 않을 경우 순서번호를 소비하지 않음(일반적)
		- 데이터를 전달할 경우 (piggybacking) 순서번호 소비
			-> 새로운 순서번호 (데이터의 첫 번쨰 바이트 번호)
ACK와 SYN을 따로 보내는 것이 아니라 하나의 세그먼트로 보내기때문에 결국은
3단계 핸드셰이크가 되는것이다@@


연결 설정(계속)
- 동시 개방
	- 양쪽 프로세스가 동시에 TCP에게 Active open(능동 개방) 요구
양쪽 모드가 둘다 서버가 될 수도 있다는 것  피어투피어 구조는
양쪽에 동시에 연결 요청을 할 수도 있다는 것 이것을 동시개방 이라고 한다

그래서 양쪽 프로세스가 동시에 TCP에게 액티브 오픈을 요구하는 경우다

- SYN 플러딩 (Flooding) 공격
	- 송신자 IP 주소를 위조하여 다수의 SYN 세그먼트 전송
		-> 서버 자원 고갈
클라이언트가 SYN세그먼트만을 서버측에 보낼때 메모리의 공간을 이 연결을 위해 버퍼로
할당해버린다 해킹 공격자가 자기의 IP를 바꿔가면서 계속 특정 서버에게 SYN세그먼트를 보내게 된다면 
서버측은 클라이언트 IP주소가 달라졌기 때문에 계속 IP주소가 다른 SYN세그먼트를 받을 때마다 새로운 연결을 위해서
버퍼자원을 계속 메모리에 버퍼공간을 할당하게 된다

공격자는 자기의 IP주소를 바꿔가면서 SYN세그먼트를 보내게 되고 서버측은 계속 버퍼 공간을 확보하다보니
메인메모리에 전체 리소스를 다 소비하게 되는 문제가 발생 메인 메모리를 다 소비하게 되면
시스템이 다운되는 경우가 발생하게 된다

이 것을 SYN플러딩 공격이라고 한다.

	- 해결책
		- 정해진 시간 동안 들어오는 연결 요구의 수를 제한
		- 발신지 주소 선별 필터링
		- 쿠키(Cookie) 이용 -> 전체 연결이 설정되기 전까지 자원할당 연기
				ex. SCTP


데이터 전송(Data Transfer) 2-24분
- 푸링(Pushing) 데이터
	EX. 대화형 서비스 	cf. TCP윈도우
	- 응용프로세스의 push 요구
	- 송신 TCP는 PSH bit를 1로 설정
- 긴급 데이터
	EX. 중지명령어(Control+C)
	-> 수신프로세스에게 먼저 전달
	- URG 비트 : 1
	- Urgent pointer)
		- 긴급 data의 끝
		= 일반 data의 시작


연결 종료
- 3단계 핸드셰이크 (Thress-way handshaking) : 대부분
경우에 따라 핸드쉐이킹 4단계 로 연결을 종료하기도 한다

TCP연결해제 역시 클라이언트가 먼저 연결을 해제하게 된다
웹 브라우저를 먼저 실행해서 통신을 하고 나서 우리가 먼저 웹 브라우저를 닫게 된다
그래서 항상 클라이언트가 연결설정, 해제 둘다 먼저 하게 된다

클라이언트가 연결을 해제하라고 하는 명령어를 클라이언트측 트랜스포트 레이어에게 명령을 전달한다
그러면 클라이언트 프로세스로부터 액티브클로즈 명령을 받은 클라이언트측 트랜스포트 레이어는 핀 세그먼트 라고 하는 것을 
상대방측에게 보내게 된다

그렇다면 기존에 없던 시퀀스번호 s가 있고 ack필드도 있다

컨트롤 필드중에 핀 세그먼트 자리를 1로 세팅한다

이걸 받은 서버측은 더이상 전송할 데이터가 없구나 알아서 판단을 하게 되고
서버측도 클라이언트 측에 전송할 데이터가 없다면 패시브 클로우즈라고 하는 명령어를
서버측 트랜스포트 레이어에게 보내게된다

최종적으로 클라이언트측은 다시 ack를 보내게된다
커넥트 클로우즈라는 사실을 프로세스측에 보고하게 되고 최종적인 에크를 전송하게 된다


연결 종료(계속)
- 3단계 핸드셰이크(Three-way handwhaking)
	1) Client -> Server : Fin 세그먼트
		- 하나의 순서번호를 소비
	2) Server -> Client : FIn+ACK 세그먼트
		- 하나의 순서번호를 소비
	3) Client -> Server : Ack 세그먼트
		- 순서번호를 소비하지 않음
		- ACK 번호 : Server로부터 수신한 FIN 세그먼트 순서번호 +1


반-종료 (Half-Close)
	- 4단계 핸드셰이크(Four-way handshaking)
양방향으로 연결을 종료하는 것이 아니라
먼저 한 방향으로만 연결을 해제한다는 뜻이다

클라이언트 측이 액티브 클로우즈 라는 명령을 클라이언트측의 트랜스포트 레이어에게 준다
그러면 클라이언트측 트랜스포트 레이어는 서버측으로 핀 세그먼트를 보낸다

그런데 서버측은 클라이언트측으로 여전히 데이터를 보낼게 남아있다
이럴경우 서버측에 클라이언트로 핀 세그먼트를 보낼수없는 상황이다
그래서 ACK를 계속 보내지 않을수없기 떄문에 피기백킹을 통해 핀 세그먼트를 보낼수있는 상황도 아니고
그래서 ACK만 먼저 보내는것

이 경우에는 클라이언트 측으로부터 서버측으로 오는 데이터 흐름에 대해서만 연결이 끊긴것이다
그래서 헬프 클로우즈라고 얘기한다

이 상태에서는 클라이언트가 서버측으로 데이터를 전송하는 것을 할 수 없지만
서버측에서 클라이언트쪽으로 연결은 살아있기 때문에 서버측이 클라이언트측으로
에크는 계속 보낼수가 있게 된다

서버는 클라이언트측으로 데이터를 보내고 클라이언트는 서버측으로 에크를 보내는 과정이 종료되면
역시 서버측도 패시브 클로우즈 명령어를 보내고 핀 세그먼트를 보내고 서버측에서
클라이언트 방향으로의 연결또한 해제하게 된다

이 경우를 4핸드셰이크를통한 연결종료라고 얘기할수있다.


연결 리셋(Connection reset) : 연결 파기
		-> RST 비트 : 1
- 연결 거부
- 연결 중단
- 휴지 연결의 종료
연결은 되어있지만 데이터 송수신이 없는 쉬고있는 연결에 대해서 종료할때 연결 리셋을 하게 된다








상태 천이 다이어그램
- 상태(state) : 타원형
- 한 상태에서 다른 상태로으 천이 : 지시선
- 사선으로 나누어지는 두 개의 문자열
	1) 첫 번째 열 : TCP가 수신하는 입력
	2) 두 번째 열 : TCP가 전송하는 출력
- 점선 : 서버
- 실선 : 클라이언트
- 컬러선 : 비 정상적인 상황


시나리오 1 : 연결 설정 및 반-닫기 종료
- Time-line Diagram

#TIMT-WAIT 상태
- Time-Out : 2MSL
- @MSL 타이머가 필요한 이유?

#MSL (Maximum Segment Lifetime)
- 세그먼트가 버려지기 전 인터넷에서 살아남을 수 있는 최대 시가
	(보통 30~60초)
2MSL 이니 1~2분









컴퓨터 네트워크 13주차 실강


ARP, IP, TCP 헤더들 익혀두기

HLEN - 5~15 사이의 값을 넣음 크기 4로 나눔


passive open - 수동적인 연결을 하라 이미 오픈되어있음

Active open - 연결 요청 명령어












