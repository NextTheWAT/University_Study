컴퓨터 네트워크 13주차 정리


송신 윈도우 (Send window)

리시버 윈도우 사이즈 (rwnd)
rwnd = 버퍼크기 -(수신 프로세스로부터 읽히기를 기다리는 바이트의 수)

송신 윈도우 크기가 100바이트인 이유는
이전에 보내온 수시측의 세그먼트 rwmd값이 100이였다는것을 의미한다

201에서 260번까지의 60바이트는 이미 송신했음에도 불구하고
그대로 버퍼에 저장해두고 있다는것
송신한 데이터를 왜 버퍼에 저장해둘까

왜냐하면 송신한 데이터가 수신측에 제대로 도착하지 못하고
혹은 도착했더라도 에러가 났거나 정상적으로 수신측이 수신하지 못할경우
다시 재전송하기 위해서 버퍼에 그대로 유지해야한다

즉 송신측은 송신한 데이터에대해 수신측으로부터 잘 수신했다는 확인응답을
재전송 타이머가 타임아웃 되기 전까지 받지 못할경우 다시 재전송하게 된다

왼쪽 벽이 오른쪽으로 이동하는 것은
송신한 데이터에 대한 확인응답 세그먼트를 수신했다는 얘기다

송신 윈도우의 왼쪽 벽은 수신측으로부터 확인응답번호에 의해서
오른쪽으로 이동하게 된다는 것

수신측의 윈도우 값이라는것은 수신측이 버퍼의 오버플로우 없이 최대 수신 가능한 바이트 수를 얘기한다
수신측이 만약 40보다 큰 50을 보내더라도 버퍼의 오버플로우 없이 수신 가능하다는것

현재 tcp는 송신 윈도우의 우측 벽이 왼쪽으로 쉬링크 즉 줄어드는 것은 허용하지 않는다

수신측 버퍼에서 저장된 데이터를 삭제한다는 것은 결국 수신측의 응용 프로세스가 그 데이터를 읽어 간다는 얘기와 동일한 얘기

수신측 윈도우의 왼쪽 벽이 오른쪽으로 닫히는 것은 수신측 tcp가 송신 측으로부터 데이터를 수신하는 경우이다


흐름제어(flow control)
- TCP에서의 데이터 흐름과 흐름제어 피드백


윈도우 열기(Opening)와 닫기(Closing)
- 슬라이딩 윈도우 프로토콜 (Sliding Window Protocol)
- 송신 윈도우 크기 (Window size)
	- 한 호스트가 다른 호스트로부터 확인을 수신하기 전에 전송할 수 있는 버퍼의 범위
		-> 각 연결마다 하나의 윈도우 사용
	- 수신측에 의해 열기, 닫기, 축소

rwnd - 수신 윈도우 (receiver window)
cwnd - 혼잡 윈도우 (congestion window)

Window Size = minimum rwnd, cwnd
두 값중에 작은값에 맞추어 최종 송신 윈도우의 크기를 결정한다

흐름제어 - ex) 송신 차량 대수를 조절하는것

혼잡제어 - 라우터단에서 버퍼의 오버플로우가 생기지않도록 송신량을 조절하는것


흐름제어의 예

수신측 버퍼의 오른쪽 벽 값 = Ack number + rwnd


윈도우 축소 (Shrinking)
- (송신) 윈도우 축소를 막으려면?
송신측 윈도우의 축소를 방지하기 위하여
수신측에서는 버퍼에 좀 더 많은 여유분이 생길 때까지 기다렸다가 rwnd값을 송신측에게 알려줘야한다


수신측은 rwnd값이 최소현 8이 되어야 8보다 큰 값일때 rwnd값을 알려줘야한다는것
만약 rwnd값이 8이라면 이전의 벽이 고정되었으니 문제가 없었음
수신측이 rwnd값을 송신측에게 알려줄때는 자신의 버퍼 수신측 버퍼의 공간 rwnd값이  
8보다 큰 경우에만 송신측으로 rwnd값을 알려줘야한다


윈도우 폐쇄
- 송신측으로부터 잠시 동안 데이터를 받고 싶지 않을 경우 수신측은 rwnd 값을 0으로 설정
- 교착상태를 막기 위해 송신측의 탐침(Probing)은 허용

바이트의 여유공간이 있다고 보냈지만 중간에 로스가 되어서 송신측에 도착했다
그러니까 여전히 송신측은 수신측의 버퍼의 여유공간이 없다고 생각하고
데이터를 보내지 않는 것
자 이상태 즉 송신측이 보낼 데이터가 있음에도 보내지 않고
수신측은 버퍼의 여유공간이 있음에보 불구하고 송신측이 보낼 데이터가 없어서 안보낸다고 생각하고
이 상태 전혀 송수신이 일어나지 않는 데드락 상태가 빠지게 되는 것
이 데드락 상태에 빠지는 것을 막기위해서 어떻게 하느냐

윈도우 제로라고 하는 세그먼트를 송신측이 받고나면
혹시라도 그 다음에 윈도우가 제로가 아닌 어떤 세그먼트를 송신측으로 보내왔을지도 모르기 때문에
중간에 한 번씩 프로빙 세그먼트를 보낸다는 것
교착상태를 막기 위해서

그래서 1바이트짜리를 포함하는 아주 짧은 세그먼트를 중간에 한 번씩 주기적으로 보낸다


TCP 슬라이딩 윈도우에 대한 사항
- 윈도우 크기는 rwnd와 cwnd 값 중에서 작은 값이다.
- 발신지는 전체 윈도우 크기만큼의 데이터를 전송할 필요는 없다.
- 송신측 윈도우는 수신측에 의해서 열리거나 닫힐 수 있지만, 축소 될 수는 없다.
- 목적지는 윈도우 축소가 일어나지 않는 한 언제든지 확인응답을 전송할 수 있다.
- 수신측은 일이적으로 윈도우를 폐쇄할 수 있다. 그렇지만 윈도우가 폐쇄된 이후에는 송신측은
	한 바이트를 포함하는 세그먼트를 언제든지 전송할 수 있다. - (탐침 세그먼트) = (프로빙 세그먼트)


silly 윈도우 시늗롬 (어리석다 바보같다 라는 의미)
- 전송/수신 응용 프로그램이 데이터를 천천히 생성하거나 천천히 처리할 떄 발생
	- 송신측 (sender)에 의한 신드롬
	- 수신측 (receiver)에 의한 시늗롬
- 예 : 1바이트 데이터 + 20바이트 TCP 헤더 + 20 바이트 IP 헤더

송신측에 의한 신드롬
- 가능한 한 바이트 데이터를 전송하지 못하게 함
- 데이터를 취합하여 큰 블록 데이터로 만들어 전송
- 송신 TCP는 버퍼에 데이터가 찰 때까지 대기 -> 프로세스 지연
- Nagle 알고리즘 적용 : 송신 TCP에서 실행하는 알고리즘
	- 최대 세그먼트 크기 (MSS)가 되면 전송
	- 첫 번째 세그먼트 전송 시 또는 확인응답 수신 시에는 데이터 크기와 상관 없이 전송


수신측에 의한 신드롬
- silly 윈도우 신드롬이 발생하는 상황에서 한 바이트 수신 처리 후에 윈도우 크기를 통보하게 되는 경우
- Clark 해결 방법 : 충분한 공간이 생기거나 적어도 버퍼가 반 이상 비어있을 때까지 윈도우 크기를 0으로 통보
- 확인 응답 지연(Delaed acknowledgement) : 수신 버퍼가 충분한 공간이 생길 때까지 확인 응답 보류
	- 장점 : 수신측으로부터 발생하는 트래픽 감소
	- 단점 : 송신측에서 확인응답을 받지 못한 세그먼트를 재전송할 가능성
		  -> TCP 확인응답지연 < 500ms



































































































