컴퓨터 네트워크 13주차 정리


송신 윈도우 (Send window)

리시버 윈도우 사이즈 (rwnd)
rwnd = 버퍼크기 -(수신 프로세스로부터 읽히기를 기다리는 바이트의 수)

송신 윈도우 크기가 100바이트인 이유는
이전에 보내온 수시측의 세그먼트 rwmd값이 100이였다는것을 의미한다

201에서 260번까지의 60바이트는 이미 송신했음에도 불구하고
그대로 버퍼에 저장해두고 있다는것
송신한 데이터를 왜 버퍼에 저장해둘까

왜냐하면 송신한 데이터가 수신측에 제대로 도착하지 못하고
혹은 도착했더라도 에러가 났거나 정상적으로 수신측이 수신하지 못할경우
다시 재전송하기 위해서 버퍼에 그대로 유지해야한다

즉 송신측은 송신한 데이터에대해 수신측으로부터 잘 수신했다는 확인응답을
재전송 타이머가 타임아웃 되기 전까지 받지 못할경우 다시 재전송하게 된다

왼쪽 벽이 오른쪽으로 이동하는 것은
송신한 데이터에 대한 확인응답 세그먼트를 수신했다는 얘기다

송신 윈도우의 왼쪽 벽은 수신측으로부터 확인응답번호에 의해서
오른쪽으로 이동하게 된다는 것

수신측의 윈도우 값이라는것은 수신측이 버퍼의 오버플로우 없이 최대 수신 가능한 바이트 수를 얘기한다
수신측이 만약 40보다 큰 50을 보내더라도 버퍼의 오버플로우 없이 수신 가능하다는것

현재 tcp는 송신 윈도우의 우측 벽이 왼쪽으로 쉬링크 즉 줄어드는 것은 허용하지 않는다

수신측 버퍼에서 저장된 데이터를 삭제한다는 것은 결국 수신측의 응용 프로세스가 그 데이터를 읽어 간다는 얘기와 동일한 얘기

수신측 윈도우의 왼쪽 벽이 오른쪽으로 닫히는 것은 수신측 tcp가 송신 측으로부터 데이터를 수신하는 경우이다


흐름제어(flow control)
- TCP에서의 데이터 흐름과 흐름제어 피드백


윈도우 열기(Opening)와 닫기(Closing)
- 슬라이딩 윈도우 프로토콜 (Sliding Window Protocol)
- 송신 윈도우 크기 (Window size)
	- 한 호스트가 다른 호스트로부터 확인을 수신하기 전에 전송할 수 있는 버퍼의 범위
		-> 각 연결마다 하나의 윈도우 사용
	- 수신측에 의해 열기, 닫기, 축소

rwnd - 수신 윈도우 (receiver window)
cwnd - 혼잡 윈도우 (congestion window)

Window Size = minimum rwnd, cwnd
두 값중에 작은값에 맞추어 최종 송신 윈도우의 크기를 결정한다

흐름제어 - ex) 송신 차량 대수를 조절하는것

혼잡제어 - 라우터단에서 버퍼의 오버플로우가 생기지않도록 송신량을 조절하는것


흐름제어의 예

수신측 버퍼의 오른쪽 벽 값 = Ack number + rwnd


윈도우 축소 (Shrinking)
- (송신) 윈도우 축소를 막으려면?
송신측 윈도우의 축소를 방지하기 위하여
수신측에서는 버퍼에 좀 더 많은 여유분이 생길 때까지 기다렸다가 rwnd값을 송신측에게 알려줘야한다


수신측은 rwnd값이 최소현 8이 되어야 8보다 큰 값일때 rwnd값을 알려줘야한다는것
만약 rwnd값이 8이라면 이전의 벽이 고정되었으니 문제가 없었음
수신측이 rwnd값을 송신측에게 알려줄때는 자신의 버퍼 수신측 버퍼의 공간 rwnd값이  
8보다 큰 경우에만 송신측으로 rwnd값을 알려줘야한다


윈도우 폐쇄
- 송신측으로부터 잠시 동안 데이터를 받고 싶지 않을 경우 수신측은 rwnd 값을 0으로 설정
- 교착상태를 막기 위해 송신측의 탐침(Probing)은 허용

바이트의 여유공간이 있다고 보냈지만 중간에 로스가 되어서 송신측에 도착했다
그러니까 여전히 송신측은 수신측의 버퍼의 여유공간이 없다고 생각하고
데이터를 보내지 않는 것
자 이상태 즉 송신측이 보낼 데이터가 있음에도 보내지 않고
수신측은 버퍼의 여유공간이 있음에보 불구하고 송신측이 보낼 데이터가 없어서 안보낸다고 생각하고
이 상태 전혀 송수신이 일어나지 않는 데드락 상태가 빠지게 되는 것
이 데드락 상태에 빠지는 것을 막기위해서 어떻게 하느냐

윈도우 제로라고 하는 세그먼트를 송신측이 받고나면
혹시라도 그 다음에 윈도우가 제로가 아닌 어떤 세그먼트를 송신측으로 보내왔을지도 모르기 때문에
중간에 한 번씩 프로빙 세그먼트를 보낸다는 것
교착상태를 막기 위해서

그래서 1바이트짜리를 포함하는 아주 짧은 세그먼트를 중간에 한 번씩 주기적으로 보낸다


TCP 슬라이딩 윈도우에 대한 사항
- 윈도우 크기는 rwnd와 cwnd 값 중에서 작은 값이다.
- 발신지는 전체 윈도우 크기만큼의 데이터를 전송할 필요는 없다.
- 송신측 윈도우는 수신측에 의해서 열리거나 닫힐 수 있지만, 축소 될 수는 없다.
- 목적지는 윈도우 축소가 일어나지 않는 한 언제든지 확인응답을 전송할 수 있다.
- 수신측은 일이적으로 윈도우를 폐쇄할 수 있다. 그렇지만 윈도우가 폐쇄된 이후에는 송신측은
	한 바이트를 포함하는 세그먼트를 언제든지 전송할 수 있다. - (탐침 세그먼트) = (프로빙 세그먼트)


silly 윈도우 시늗롬 (어리석다 바보같다 라는 의미)
- 전송/수신 응용 프로그램이 데이터를 천천히 생성하거나 천천히 처리할 떄 발생
	- 송신측 (sender)에 의한 신드롬
	- 수신측 (receiver)에 의한 시늗롬
- 예 : 1바이트 데이터 + 20바이트 TCP 헤더 + 20 바이트 IP 헤더

송신측에 의한 신드롬
- 가능한 한 바이트 데이터를 전송하지 못하게 함
- 데이터를 취합하여 큰 블록 데이터로 만들어 전송
- 송신 TCP는 버퍼에 데이터가 찰 때까지 대기 -> 프로세스 지연
- Nagle 알고리즘 적용 : 송신 TCP에서 실행하는 알고리즘
	- 최대 세그먼트 크기 (MSS)가 되면 전송
	- 첫 번째 세그먼트 전송 시 또는 확인응답 수신 시에는 데이터 크기와 상관 없이 전송


수신측에 의한 신드롬
- silly 윈도우 신드롬이 발생하는 상황에서 한 바이트 수신 처리 후에 윈도우 크기를 통보하게 되는 경우
- Clark 해결 방법 : 충분한 공간이 생기거나 적어도 버퍼가 반 이상 비어있을 때까지 윈도우 크기를 0으로 통보
- 확인 응답 지연(Delaed acknowledgement) : 수신 버퍼가 충분한 공간이 생길 때까지 확인 응답 보류
	- 장점 : 수신측으로부터 발생하는 트래픽 감소
	- 단점 : 송신측에서 확인응답을 받지 못한 세그먼트를 재전송할 가능성
		  -> TCP 확인응답지연 < 500ms






15.8 오류 제어


오류제어
- 훼손 세그먼트 (corrupted segment) -> 감지 및 재전송
- 손실 세그먼트 (lost segment) -> 재전송
- 순서가 어긋난 세그먼트 (out-of-order segment) -> 저장
- 중복 세그먼트 (duplicate segment) -> 감지 및 폐기

오류 발견 및 정정 메커니즘
- 검사합 (Checksum)
- 확인응답 (Acknowlegment)
- 타임-아웃 (Time-out)


검사합

확인응답 유형
- 누적 확인응답 (Accumlative Acknowlegment : ACK)
- 선택 확인응답 (Selective Acknowlegment : SACK) : TCP 옵션
	- 순서에 어긋난 세그먼트 또는 중복 세그먼트 블록을 송신측에게 알림

확인응답의 전송
- Rule 1: 데이터 세그먼트 전송 시 확인응답 포함 (피기배킹)
- Rule 2: 보낼 데이터가 없는 상태에서 순서에 맞는 단지 하나의 세그먼트 만을
	      수신한 경우 일정 시간(일반적으로 500ms) 동안 ACK보류
보낼 데이터가 없을때 500ms 기다린후 ACK를 보냄
- Rule 3: 확인응답(ACK전송) 하지 않은 두 개의 세그먼트를 수신하면 즉시 ACK 전송
- Rule 4: 순서에 어긋난 세그먼트를 수신한 경우 ACK 전송
		-> 누락 세그먼트의 빠른 재전송
- Rule 5: 누락된 세그먼트가 도착하면 ACK 전송
- Rule 6 중복 세그먼트가 도착하면 폐기 후 즉시 ACK 전송

룰 4,5,6번은 정상적이지 않은, 오류 상황일때 즉시 ACK 를 전송하는 규칙


재전송 (Retransmission)
- RTO (Retransmission Time-Out: 재전송 시간-초과) 이후의 재전송
ACK를 보내지않고 타임아웃이 되면 다시 송신을해준다
	- ACK 세그먼트를 위한 재전송 타이머는 설정되지 않는다.
	- RTO 값은 RTT (Rouns Trip Time)를 기반으로 업데이트 된다.

- 세 개의 중복 ACK 세그먼트 이후에 재전송
	- 손실 세그먼트에 대해 세 개의 중복 ACK를 전송함으로써 손실로 간주된 세그먼트를 즉시 재전송
	- 빠른 재전송 (Fast retransmission)
ACK를 3개를 받으면 타임아웃 되기전 세그먼트를 다시 보낸다
이만큼 빨리 재전송이 되니까 전체적인 성능이 올라간다
Fast retransmission - 빠른 재전송

순서가 어긋난 세그먼트
- 손실된 세그먼트를 수신할 때까지 일시적으로 보관 (현재 대부분)


시나리오 1 : 정상동작 (Norma operation)
룰1,2,3 사용


시나리오 2 : 손실(or 훼손) 세그먼트 	cf. 지연 세그먼트
룰 3,4,5 사용


시나리오 3 : 빠른 재전송 (Fast retransmission)


시나리오 4 : 확인응답의 손실
- 자동으로 교정 
4개의 세그먼트를 보냈는데 리트랜스미션 타임아웃에 걸리지 않는다면
중간에 서버측이 보낸 ACK 세그먼트가 loss가 일어났다는 사실을 클라이언트도 모르고
서버도 모르지만 정상적으로 동작하게 된다는것

- 재전송을 통한
중복된 세그먼트를 수신해서 룰6에 의해서 바로 ACK를 보내는 상황 


시나리오 5: 확인응답 손실로 인한 교착상태 (Deadlock)
- 영속 타이머 (Persistent timer) 필요
윈도우 폐쇄와 관련된 내용
송신측과 수신측이 있는데 수신측의 버퍼가 가득 찬 경우 더이상 수신할 수 없는 경우
수신측은 송신측에게 ACK를 보내는데 윈도우 사이즈 rwnd값이 0라고해서 보낸다
그러면 송신측은 수신측으로부터 윈도우 사이즈가 0을 받으면
송신할 데이터가 있음에도 불구하고 수신측에게 데이터를 보낼 수 없는 상황이 된다

수신측이 다시 버퍼에 여유공간이 생겨서 다시 ACK를 보내고 rwnd를 1000이라는 여유공간을 보낸다
문제는 윈도우 사이즈가 1000이라고 보낸 수신측이 송신측에게 보낸 ACK 세그먼트가 중간에 사라지는 경우이다
이떄는 송신측은 여전히 윈도우가 0라고하는 ACK 세그먼트를 받아둔 상태기 때문에
송신할 데이터가 있음에도 전송하지 못하는 상황이고
수신측은 송신측이 데이터를 보내지 않으니까 보내는 데이터가 없구나 하고 가만히 있는다

양쪽이 서로 데이터 전송을 미루고 있는 상태가 데드락 상태이다 - 교착상태

데드락 상태를 해결하기위해서는
송신측이 수신측에게 일정 주기별로 한 번씩 탐침 세그먼트 즉, 프로브 세그먼트, 프로빙 세그먼트를 보낸다
프로브 세그먼트를 얼마만에 한 번씩 보내느냐
수신측으로부터 rwnd가 0라고 하는 확인응답 세그먼트를 받고 나면 송신측은
영속타이머를 구동시킨다
이 영속 타이머가 타임아웃될때마다 데이터바이트 1을 포함한 프로브 세그먼트를 보낸다


시나리오 6 : 지연 세그먼트 -> 순서가 잘못된 세그먼트
- 데이터그램의 서로 다른 경로를 통한 전달로 인하여 발생
- 이전의 세그먼트를 모두 수신하기까지 확인응답을 전송하지 않음
- 타임-아웃 발생하면 세그먼트가 재전송 됨
1,2,3 번을 보냈는데 1,3번이 먼저 도착 그러면 4번ACK를 보내는게 아니라
2번을 받을때까지 ACK를 보내지않고 대기한다


시나리오 7 : 중복 세그먼트
- 타임-아웃 이전에 확인응답이 도착하지 않는 송신
- 같은 순서번호를 가진 세그먼트는 폐기

















































































