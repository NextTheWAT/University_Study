컴퓨터 네트워크 13주차 정리


송신 윈도우 (Send window)

리시버 윈도우 사이즈 (rwnd)
rwnd = 버퍼크기 -(수신 프로세스로부터 읽히기를 기다리는 바이트의 수)

송신 윈도우 크기가 100바이트인 이유는
이전에 보내온 수시측의 세그먼트 rwmd값이 100이였다는것을 의미한다

201에서 260번까지의 60바이트는 이미 송신했음에도 불구하고
그대로 버퍼에 저장해두고 있다는것
송신한 데이터를 왜 버퍼에 저장해둘까

왜냐하면 송신한 데이터가 수신측에 제대로 도착하지 못하고
혹은 도착했더라도 에러가 났거나 정상적으로 수신측이 수신하지 못할경우
다시 재전송하기 위해서 버퍼에 그대로 유지해야한다

즉 송신측은 송신한 데이터에대해 수신측으로부터 잘 수신했다는 확인응답을
재전송 타이머가 타임아웃 되기 전까지 받지 못할경우 다시 재전송하게 된다

왼쪽 벽이 오른쪽으로 이동하는 것은
송신한 데이터에 대한 확인응답 세그먼트를 수신했다는 얘기다

송신 윈도우의 왼쪽 벽은 수신측으로부터 확인응답번호에 의해서
오른쪽으로 이동하게 된다는 것

수신측의 윈도우 값이라는것은 수신측이 버퍼의 오버플로우 없이 최대 수신 가능한 바이트 수를 얘기한다
수신측이 만약 40보다 큰 50을 보내더라도 버퍼의 오버플로우 없이 수신 가능하다는것

현재 tcp는 송신 윈도우의 우측 벽이 왼쪽으로 쉬링크 즉 줄어드는 것은 허용하지 않는다

수신측 버퍼에서 저장된 데이터를 삭제한다는 것은 결국 수신측의 응용 프로세스가 그 데이터를 읽어 간다는 얘기와 동일한 얘기

수신측 윈도우의 왼쪽 벽이 오른쪽으로 닫히는 것은 수신측 tcp가 송신 측으로부터 데이터를 수신하는 경우이다


흐름제어(flow control)
- TCP에서의 데이터 흐름과 흐름제어 피드백


윈도우 열기(Opening)와 닫기(Closing)
- 슬라이딩 윈도우 프로토콜 (Sliding Window Protocol)
- 송신 윈도우 크기 (Window size)
	- 한 호스트가 다른 호스트로부터 확인을 수신하기 전에 전송할 수 있는 버퍼의 범위
		-> 각 연결마다 하나의 윈도우 사용
	- 수신측에 의해 열기, 닫기, 축소

rwnd - 수신 윈도우 (receiver window)
cwnd - 혼잡 윈도우 (congestion window)

Window Size = minimum rwnd, cwnd
두 값중에 작은값에 맞추어 최종 송신 윈도우의 크기를 결정한다

흐름제어 - ex) 송신 차량 대수를 조절하는것

혼잡제어 - 라우터단에서 버퍼의 오버플로우가 생기지않도록 송신량을 조절하는것


흐름제어의 예

수신측 버퍼의 오른쪽 벽 값 = Ack number + rwnd


윈도우 축소 (Shrinking)
- (송신) 윈도우 축소를 막으려면?
송신측 윈도우의 축소를 방지하기 위하여
수신측에서는 버퍼에 좀 더 많은 여유분이 생길 때까지 기다렸다가 rwnd값을 송신측에게 알려줘야한다


수신측은 rwnd값이 최소현 8이 되어야 8보다 큰 값일때 rwnd값을 알려줘야한다는것
만약 rwnd값이 8이라면 이전의 벽이 고정되었으니 문제가 없었음
수신측이 rwnd값을 송신측에게 알려줄때는 자신의 버퍼 수신측 버퍼의 공간 rwnd값이  
8보다 큰 경우에만 송신측으로 rwnd값을 알려줘야한다


윈도우 폐쇄
- 송신측으로부터 잠시 동안 데이터를 받고 싶지 않을 경우 수신측은 rwnd 값을 0으로 설정
- 교착상태를 막기 위해 송신측의 탐침(Probing)은 허용

바이트의 여유공간이 있다고 보냈지만 중간에 로스가 되어서 송신측에 도착했다
그러니까 여전히 송신측은 수신측의 버퍼의 여유공간이 없다고 생각하고
데이터를 보내지 않는 것
자 이상태 즉 송신측이 보낼 데이터가 있음에도 보내지 않고
수신측은 버퍼의 여유공간이 있음에보 불구하고 송신측이 보낼 데이터가 없어서 안보낸다고 생각하고
이 상태 전혀 송수신이 일어나지 않는 데드락 상태가 빠지게 되는 것
이 데드락 상태에 빠지는 것을 막기위해서 어떻게 하느냐

윈도우 제로라고 하는 세그먼트를 송신측이 받고나면
혹시라도 그 다음에 윈도우가 제로가 아닌 어떤 세그먼트를 송신측으로 보내왔을지도 모르기 때문에
중간에 한 번씩 프로빙 세그먼트를 보낸다는 것
교착상태를 막기 위해서

그래서 1바이트짜리를 포함하는 아주 짧은 세그먼트를 중간에 한 번씩 주기적으로 보낸다


TCP 슬라이딩 윈도우에 대한 사항
- 윈도우 크기는 rwnd와 cwnd 값 중에서 작은 값이다.
- 발신지는 전체 윈도우 크기만큼의 데이터를 전송할 필요는 없다.
- 송신측 윈도우는 수신측에 의해서 열리거나 닫힐 수 있지만, 축소 될 수는 없다.
- 목적지는 윈도우 축소가 일어나지 않는 한 언제든지 확인응답을 전송할 수 있다.
- 수신측은 일이적으로 윈도우를 폐쇄할 수 있다. 그렇지만 윈도우가 폐쇄된 이후에는 송신측은
	한 바이트를 포함하는 세그먼트를 언제든지 전송할 수 있다. - (탐침 세그먼트) = (프로빙 세그먼트)


silly 윈도우 시늗롬 (어리석다 바보같다 라는 의미)
- 전송/수신 응용 프로그램이 데이터를 천천히 생성하거나 천천히 처리할 떄 발생
	- 송신측 (sender)에 의한 신드롬
	- 수신측 (receiver)에 의한 시늗롬
- 예 : 1바이트 데이터 + 20바이트 TCP 헤더 + 20 바이트 IP 헤더

송신측에 의한 신드롬
- 가능한 한 바이트 데이터를 전송하지 못하게 함
- 데이터를 취합하여 큰 블록 데이터로 만들어 전송
- 송신 TCP는 버퍼에 데이터가 찰 때까지 대기 -> 프로세스 지연
- Nagle 알고리즘 적용 : 송신 TCP에서 실행하는 알고리즘
	- 최대 세그먼트 크기 (MSS)가 되면 전송
	- 첫 번째 세그먼트 전송 시 또는 확인응답 수신 시에는 데이터 크기와 상관 없이 전송


수신측에 의한 신드롬
- silly 윈도우 신드롬이 발생하는 상황에서 한 바이트 수신 처리 후에 윈도우 크기를 통보하게 되는 경우
- Clark 해결 방법 : 충분한 공간이 생기거나 적어도 버퍼가 반 이상 비어있을 때까지 윈도우 크기를 0으로 통보
- 확인 응답 지연(Delaed acknowledgement) : 수신 버퍼가 충분한 공간이 생길 때까지 확인 응답 보류
	- 장점 : 수신측으로부터 발생하는 트래픽 감소
	- 단점 : 송신측에서 확인응답을 받지 못한 세그먼트를 재전송할 가능성
		  -> TCP 확인응답지연 < 500ms






15.8 오류 제어


오류제어
- 훼손 세그먼트 (corrupted segment) -> 감지 및 재전송
- 손실 세그먼트 (lost segment) -> 재전송
- 순서가 어긋난 세그먼트 (out-of-order segment) -> 저장
- 중복 세그먼트 (duplicate segment) -> 감지 및 폐기

오류 발견 및 정정 메커니즘
- 검사합 (Checksum)
- 확인응답 (Acknowlegment)
- 타임-아웃 (Time-out)


검사합

확인응답 유형
- 누적 확인응답 (Accumlative Acknowlegment : ACK)
- 선택 확인응답 (Selective Acknowlegment : SACK) : TCP 옵션
	- 순서에 어긋난 세그먼트 또는 중복 세그먼트 블록을 송신측에게 알림

확인응답의 전송
- Rule 1: 데이터 세그먼트 전송 시 확인응답 포함 (피기배킹)
- Rule 2: 보낼 데이터가 없는 상태에서 순서에 맞는 단지 하나의 세그먼트 만을
	      수신한 경우 일정 시간(일반적으로 500ms) 동안 ACK보류
보낼 데이터가 없을때 500ms 기다린후 ACK를 보냄
- Rule 3: 확인응답(ACK전송) 하지 않은 두 개의 세그먼트를 수신하면 즉시 ACK 전송
- Rule 4: 순서에 어긋난 세그먼트를 수신한 경우 ACK 전송
		-> 누락 세그먼트의 빠른 재전송
- Rule 5: 누락된 세그먼트가 도착하면 ACK 전송
- Rule 6 중복 세그먼트가 도착하면 폐기 후 즉시 ACK 전송

룰 4,5,6번은 정상적이지 않은, 오류 상황일때 즉시 ACK 를 전송하는 규칙


재전송 (Retransmission)
- RTO (Retransmission Time-Out: 재전송 시간-초과) 이후의 재전송
ACK를 보내지않고 타임아웃이 되면 다시 송신을해준다
	- ACK 세그먼트를 위한 재전송 타이머는 설정되지 않는다.
	- RTO 값은 RTT (Rouns Trip Time)를 기반으로 업데이트 된다.

- 세 개의 중복 ACK 세그먼트 이후에 재전송
	- 손실 세그먼트에 대해 세 개의 중복 ACK를 전송함으로써 손실로 간주된 세그먼트를 즉시 재전송
	- 빠른 재전송 (Fast retransmission)
ACK를 3개를 받으면 타임아웃 되기전 세그먼트를 다시 보낸다
이만큼 빨리 재전송이 되니까 전체적인 성능이 올라간다
Fast retransmission - 빠른 재전송

순서가 어긋난 세그먼트
- 손실된 세그먼트를 수신할 때까지 일시적으로 보관 (현재 대부분)


시나리오 1 : 정상동작 (Norma operation)
룰1,2,3 사용


시나리오 2 : 손실(or 훼손) 세그먼트 	cf. 지연 세그먼트
룰 3,4,5 사용


시나리오 3 : 빠른 재전송 (Fast retransmission)


시나리오 4 : 확인응답의 손실
- 자동으로 교정 
4개의 세그먼트를 보냈는데 리트랜스미션 타임아웃에 걸리지 않는다면
중간에 서버측이 보낸 ACK 세그먼트가 loss가 일어났다는 사실을 클라이언트도 모르고
서버도 모르지만 정상적으로 동작하게 된다는것

- 재전송을 통한
중복된 세그먼트를 수신해서 룰6에 의해서 바로 ACK를 보내는 상황 


시나리오 5: 확인응답 손실로 인한 교착상태 (Deadlock)
- 영속 타이머 (Persistent timer) 필요
윈도우 폐쇄와 관련된 내용
송신측과 수신측이 있는데 수신측의 버퍼가 가득 찬 경우 더이상 수신할 수 없는 경우
수신측은 송신측에게 ACK를 보내는데 윈도우 사이즈 rwnd값이 0라고해서 보낸다
그러면 송신측은 수신측으로부터 윈도우 사이즈가 0을 받으면
송신할 데이터가 있음에도 불구하고 수신측에게 데이터를 보낼 수 없는 상황이 된다

수신측이 다시 버퍼에 여유공간이 생겨서 다시 ACK를 보내고 rwnd를 1000이라는 여유공간을 보낸다
문제는 윈도우 사이즈가 1000이라고 보낸 수신측이 송신측에게 보낸 ACK 세그먼트가 중간에 사라지는 경우이다
이떄는 송신측은 여전히 윈도우가 0라고하는 ACK 세그먼트를 받아둔 상태기 때문에
송신할 데이터가 있음에도 전송하지 못하는 상황이고
수신측은 송신측이 데이터를 보내지 않으니까 보내는 데이터가 없구나 하고 가만히 있는다

양쪽이 서로 데이터 전송을 미루고 있는 상태가 데드락 상태이다 - 교착상태

데드락 상태를 해결하기위해서는
송신측이 수신측에게 일정 주기별로 한 번씩 탐침 세그먼트 즉, 프로브 세그먼트, 프로빙 세그먼트를 보낸다
프로브 세그먼트를 얼마만에 한 번씩 보내느냐
수신측으로부터 rwnd가 0라고 하는 확인응답 세그먼트를 받고 나면 송신측은
영속타이머를 구동시킨다
이 영속 타이머가 타임아웃될때마다 데이터바이트 1을 포함한 프로브 세그먼트를 보낸다


시나리오 6 : 지연 세그먼트 -> 순서가 잘못된 세그먼트
- 데이터그램의 서로 다른 경로를 통한 전달로 인하여 발생
- 이전의 세그먼트를 모두 수신하기까지 확인응답을 전송하지 않음
- 타임-아웃 발생하면 세그먼트가 재전송 됨
1,2,3 번을 보냈는데 1,3번이 먼저 도착 그러면 4번ACK를 보내는게 아니라
2번을 받을때까지 ACK를 보내지않고 대기한다


시나리오 7 : 중복 세그먼트
- 타임-아웃 이전에 확인응답이 도착하지 않는 송신
- 같은 순서번호를 가진 세그먼트는 폐기







15.9 혼잡 제어 (congestion control)

라우터 큐(Queue) - 버퍼(Buffer)

혼잡(Congestion) 현상
- 라우터가 패킷을 처리할 수 있는 속도보다 더 빨리 패킷을 수신하는 경우 발생
	-> 부하 (Load)를 네트워크 용량(Capacity)보다 적도록 조절 필요

TCP는 손실 세그먼트의 원인이 혼잡에 기인한 것이라고 가정한다.


흐름제어란 최종 수신측의 버퍼오버플로우가 생기지 않도록 송신량을 조절하는것
혼잡제어는 중간에 있는 라우터단의 버퍼 오버플로우를 방지하기 위해서 송신량을 조절하는것

두 제어에서의 차이점

 흐름제어는 최종 수신측이 명시적으로 확인응답 세그먼에 포함된
rwnd값에 의해서 수신측 버퍼 여유공간을 명시적으로 송신측에게 알려준다
 혼잡제어를 위해서 라우터단이 송신측에게 자신의 버퍼의 여유공간을 알려주는것은 하지않는다


네트워크 성능
- 측정 인자: 지연(Delay), 처리율(Throughut)
	- Delay = Queuing delay + Propagation delay + Processing delay
	- Throughput: 단위 시간 동안 망을 통하여 전송되는 패킷의 수

Queuing delay : Queue 버퍼에 진입해서 버퍼에서 빠져나가는 버퍼링 딜레이
Propagation delay - 전파 지연 : 실제적으로 데이터가 링크를 지나가는 시간
Processing delay : 중간의 노드에 의해 프로세스가 프로세싱 하기 위한 처리 지연 이다
이걸 다 합쳐서 Delay라고 하는것

CPU, 하드웨어에 의해서 Processing Delay가 결정된다
Queuing Delay는 라우터단에서 버퍼 메니지먼트 버퍼 관리를 어떻게 하느냐에 따라 결정된다

Propagation Delay와 Processing Delay는 네트워크를 구축할때 하드웨어, 물리적인 조건에 의해서 결정
Queuing Delay는 네트워크 관리를 어떻게 하느냐에 따라서 결정된다

이미 구축된 네트워크에서는 Queuing Delay를 낮추는것이 타겟이 된다

Throughput : 초당 망을 통하여 전송되는 패킷의 수 단위는 - bps 
왜 감소하냐면 - 혼잡이 발생하면 송신측이 또 재전송을 통해서 혼잡을 더 증폭시키기 떄문에
		    결국은 수신측에 세그먼트가 제대로 도달하지 못 한다는 것

혼잡제어의 목적은 네트워크Load가 걸려서 Throughput 이 최대값에 도달하게 되고 네트워크 Load도 
더 올라가면 혼잡이 발생할수밖에 없으니 오히려 일정부분이 떨어진다
떨어지는데 떨어지는 부분을 완전히 떨어뜨리는 것이 아니라 조금만 떨어뜨리고
일정한 Throughput을 유지시키는 것이 혼잡제어의 목표가 되겠다


혼잡 윈도우 (Congestion window) : cwnd
- 실제 송신 윈도우 크기 = min (rwnd, cwnd)

혼잡 제어 원칙
- 느린 시작(Slow start): 지수증가(Exponential Increase)
	- cwnd = 1 MSS (Maximum Segment Size)부터 시작 	cf. MSS는 연결설정 시 결정 (옵션 이용)
		- 각각의 ACK 수신마다 1MSS 만큼 증가 -> 지수적으로 증가 (1,2,4,---)
			cf. 지연-Ack (Delay Ack) 정책일 경우 2의 승수로 증가하지 않는다
			     (ex. 2개 Segment당 1개 Ack -> 승수 ~1.5)
	- ssthresh (Slow start threshole) 설정 : 이전 윈도우 크기의 반 (초기값: 65535)
		-> 확인응답이 도착하면 ssthresh에 도달할 때까지 지수적으로 cwnd 증가

- 혼잡 회피 (Congestion avoidance) : 가산증가(Additive Increase)
	- ssthresh에 도달한 경우 -> 전체 윈도우 크기만큼의 세그먼트에 대한 확인응답이 도착하면
					    cwnd 값을 1 MSS 만큼 증가

- 혼잡 감지(Congestion detection) : 지수 감소(Multiplicative Decrease)
	- 시간-초과 발생 시 : ssthresh = cwnd/2, cwnd=1 -> Slow start 수행
	- 3개의 중복 ACK 수신 시 : ssthresh = cwnd/2, cwnd = ssthresh -> 새로운 혼잡 회피 단계 시작


Slow start : exponential incresase
cwnd =  1MSS
MSS에 해당하는 바이트 수가 첫 번쨰 cwnd 값이 되는것
한 개의 MSS 사이즈만큼 보내고 그리고 정상적이라면 이것에 대한 Ack가 도착한다
그러니 cwnd값이 2
2개를 또 보내고 Ack 를 받으면 cwnd가 4
4개를 또 보내고 Ack 를 받으면 cwnd가 8
이 과정이 바로 슬로우 스타트다
1에서 시작하고 지수적으로 증가


Congestion avoidance : additive increase
Slow start로 시작해서 Slow start threshold 값에 도달하게 되면 
1MSS 만큼 들어나는 Congestion avoidance 단계에 진입

cwnd 값이 4다 Slow start threshold 가 4라고 가정하면
그 다음부터 8이 되는게 아니라 1씩 증가하는 것
4개를 보내면 4개에 대한 Ack 받고
5개를 보내면 5개에 대한 Ack 받고
6개를 보내면 6개에 대한 Ack를 받는다


TCP congestion policy summary
처음에는 송수신간의 연결이 확립되면 Slow start로 시작한다
1 MSS 사이즈만큼 보내다가 지수 증가를 하게 되는것
현재의 cwnd값이 Slow start threshold 에 도달하게 되면
Congestion acoidance 단계로 들어가게 된다
1 MSS만큼만 증가시키는 과정에 들어간다
이렇다해도 언젠가는 혼잡이 발생한다
두 가지의 경우가 있는데

1. Retransmission TimeOut에 걸리면 cwnd값이 다시 Slow start 로 들어가게 된다
그러면 cwnd 값이 1MSS로 설정이 된다 새로운 Slow start threshold 값은
타임아웃이 발생할때의 cwnd값 그떄의 윈도우 값의 1/2에 해당하는 값이 새로운 Slow start threshold 값이 된다

2. 3개의 중복된 Ack 수신한경우에는 Congestion avoidance 단계로 시작한다
Slow start threshold 값은 현재의 cwnd 값의 1/2가 되고 cwnd값은 새롭게 설정된 threshold 값에서 
Congestion avoidance 단계가 진입된다

혼잡은 Slow start 단계에서도 혼잡은 발생할수있다
1, 2번 둘다 해당된다


Congestion example @@@ 3-32분
실제 cwnd 값은 바이트

수평축은 RTT - Round trip time  쉽게 생각하면 전송 횟수라고 생각하면 된다 (왔다갔다 1번)
number of transmission

TCP-Tahoe = Slow start + Congestion avoidance + Fast retransmit
TCP-Reno = TCP-Tahoe + Fast Recovey


TCP 타이머 종류
Timers
1. Retansmission
2. Persistence
3. Keepalive
4. TIME-WAIT


재전송 타이머(retransmisson timer)
- RTO(Retransmission time-out) : 세그먼트 전송 후 확인응답을 기다리는 시간
- 재전송 타이머 규칙
	- 송신 버퍼의 맨 앞에 있는 세그먼트 전송 시 타이머 구동
	- 타임-아웃 발생하면 버퍼의 첫 번째 세그먼트 재전송 -> 타이머 다시 구동
	- 누적 확인 응답된 세그먼트들은 버퍼에서 삭제
	- 버퍼가 빈 경우 타이머 정지
- 긴 재전송 시간 vs 짧은 재전송 시간
길 경우에는 그만큼 재전송 될 확률이 줄기 때문에 재전송으로 인한 오버헤드는 줄일 수 있다
만약 패킷이 lose 되는것이 확실하다면 불필요하게 재전송 타임아웃을 길게 잡으면
오히려 재전송하게 되는 그 시간이 길어지므로 전체적인 성능이 오히려 떨어진다
적절한 값을 결정하는 것이 중요하다

- 왕복시간(RTT : Round Trip Time) 계산
	- 측정된 RTT (Measured RTT) : RTTm
		- 하나의 Segment 전송 후 ACK 수신할 떄까지의 시간
		- 어느 한 순간에는 오직 하나의 RTT 측정만이 진행된다
	- 매끄러운 RTT (Smoothed RTT) : RTTs
		- 첫 번쨰 측정 이후 : RTTs = RTTm
		- 그 이후의 측정 이후 = RTTs=(1-a)RTTs + aRTTm   	, where a = 1/8
	- RTT 편차 (RTT Deviation) : RTTd
		- 첫 번쨰 측정 이후 : RTTd = RTTm/2
		- 그 이후의 측정 이후 : RTTd = (1-b)RTTd + b * |RTTs-RTTm|  		, where b = 1/4

- 재전송 타임-아웃 (Retransmission Timeout : RTO)
	- 처음 : 초기값 (보통 6.00초)
	- 그 이후의 측정 이후 : RTO = RTTs + 4*RTTd


EXample 15.3


Karn 알고리즘
- 전송된 세그먼트에 대해 확인 응답이 되지 않아 재전송된 경우
- 이전 세그먼트에 대한 확인응답인지 재전송에 대한 확인응답 인지 여부 판단이 애매하다
- RTT 값은 재전송 없이 확인응답 수신 전까지 변동이 없음
	- 새로운 RTO의 계산에 재전송 세그먼트의 RTT는 고려하지 않음

지수 백오프 (Exponential Backoff)
- 세그먼트가 재전송될 때마다 RTO 값은 두 배가 된다.


Example 15.4


영속 타이머(persistence timer)
- 윈도우 크기가 0인 경우를 처리하기 위한 타이머
- 수신 TCP가 윈도우 크기 0을 통보한 후, 다시 0이 아닌 윈도우 크기를 아릴는 확인 응답을
  보냈지만 송신 TCP가 이를 수신하지 못함.
- 양쪽 TCP가 서로 기대되는 교착상태(deadlock) 해결
- 송신 TCP가 0의 윈도우 크기를 가진 확인을 수신하면, 영속 타이머를 구동
	-> timeout 발생 시 probe segment 전송
- TIme-out 값 : RTO 값 (초기값) -> 두 배씩 증가 -> 최대 60초 (매 60초마다 probe 전송)
					     -------------
					 probe 세그먼트 미 응답 시마다

Keepalive 타이머
- 두 TCP 간에 설정된 연결이 오랫동안 휴지(idle) 상태에 있는 것을 방지하기 위한 타이머
- 서버에 구현 : 클라이언트로부터 세그먼트를 받을 때마다 타이머 초기화 (시간-종료 . 2시간)
- 2시간이 지나도록 세그먼트를 수신하지 못하면 75초 간격으로 10개의 프로브(probe) 세그먼트 전송
- 응답이 없으면 다운으로 간주하고 연결 종료

시간-대기 타이머(Time-wait timer)
- 연결 종료 동안에 사용
- 시간-대기(2MSL) 시간 동안 연결 유지		Why? (15.5절 참고)


15.11 옵션(option)
- 최대 40바이트

Options - Single-byte - End of option list
			     - No operation
	    - Multiple-byte - Maximum segment size
				- Window scale factor
				- Timestamp
				- SACK-permitted		
				- SACK


15.12 TCP 패키지

- 전송 제어 블록 (TCB : Transmission COntrol Block)
- 타이머 (Timer)
- 메인 모듈 (Main Module)
- 입력 프로세스 모듈 (Input Process Module)
- 출력 프로세스 모듈 (Output Process Module)





