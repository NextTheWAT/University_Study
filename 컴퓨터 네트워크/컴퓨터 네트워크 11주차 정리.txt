컴퓨터 네트워크 11주차 정리

13.2 전송 계층 프로토콜

Examples
- Simple Protocol
- Stop-and-Wait Protocol
- Go-Back-N Protocol
- Selective-Repeat Protocol
- Bo-directional Protocol: poggybacking


정지 대기 프로토콜 (Stop-and-Wait Protocol)
- 흐름제어, 오류제어 제공하는 연결 지향 프로토콜
- 송수신측 모두 크기가 1인 슬라이딩 윈도우 사용
	- 확인 응답이 오기 전까지 다음 패킷을 전송하지 않음
	- 채널에는 한 번에 하나의 패킷과 하나의 확인응답만 전송 가능
- 패킷 훼손 검사를 위해 검사합 (Checksun) 추가
	- 훼손 발견 -> 재전송
- 패킷을 전송할 때마다 타이머 구동
	- Timeout -> 재전송
- 순서번호(Sequence sumber), 확인응답번호(Acknowledgment number) 0번과 1번
	- Module-2 연산
송신 0 - 수신 1 - 송신 1 - 수신 0

더 많은 메모리를 사용할 필요가없으니 0번다음엔 1번 1번다음에는 다시 0번을 받는다
만약 오류가 발생했다면 수신측은 어떻게 반응할까
오류가 발생했다면 ack를 보내긴 보내는데 0번을 받은 것에 대해서 데이터가 오류가 발생했으니
다시 0번을 전송해달라고 요청 그래서 다시 ack0을 보내게 된다
송신측이 0번을 보냈지만 그거에대해서 다시 0번을 송신해달라고 수신측이 요청하는걸 봐서
문제가있었던것을 알고 다시 0번을 보냄

송신측에 데이터가있다고해서 연속적으로 보내지못함
수신측이 받을 준비가 되어있을때만 - 흐름제어
송수신측 모두 크기가1인 슬라이딩 윈도우 사용
슬라이딩 윈도우의 의미는 수신측으로부터 확인응답을 받지 않더라도 연속해서 보낼수있는 송신 데이터량을
송신측 윈도우 라고 얘기한다
wait은 보낼수있는 데이터량이 1개씩 송수신측 크기가 모두 1인 슬라이딩 윈도우를 사용

패킷을 전송할 때마다 타이머 구동 - 수신측에 도착했는데 오류가 발생한 경우 명시적으로 ack0를 보냈었는데 다시 한번 ack0를 보내서
명시적으로 재전송한 상황
만약 송신데이터가 수신측에 도착하지 않고 중간에 로스가 되었다면 그렇다면 수신측에서 송신측 데이터가 도착하지 않으니까
송신측이 데이터를 전송하지 않는구나 라고 판단하고 송신측 데이터가 도착할때까지 기다릴것이다
송신측은 중간에 사라졌는지를 모름 그러니 ack1번을 기다림 계속
이 상태는 데드락 상태에 빠지는것 수신측은 송신측이 아직 데이터를 보내지않는구나
송신측은 송신할 데이터가 있음에도 불구하고 수신측으로부터 아직 확인 응답을 계속해서 기다림
도착상태에 빠짐 - 이걸 막기위해 송신측이 데이터를 보낼때마다 타이머를 구동
타이머가 타임아웃 되기 전까지 ack가 도착하면 정상 구동
만약 타임아웃될때까지 ack가 도착하지 않는다면 확인응답을 수신측으로부터 받지않아도 송신측은
내가 이전에 보낸 데이터가 도착하지 않았구나를 판단하고 동일한정보를 재전송함

송신측이 하나의 데이터를 보내고 정지한 다음 수신측으로부터 확인 응답을 기다리는 stop and wait


정기 대기 프로토콜 (계속)
- 예제 13.4

안정적@
정지 대기 프로토콜 (계속)
- 효율
	- 채널이 두껍고 긴 경우에 비효율정      cf. 채널 = 파이프
- 대역폭 지연 곱(Bandwidth Delay Product)
대역폭 = 초당 전송할 수 있는 비트의 수
	- 비트로 표현된 파이프 의 용량
	- 파이프를 통해 전송되는 bit의 수가 많은 경우 전송 효율 향상
- 예제 13.5 : BW : 1Mbps, RTT: 20msec, 데이터 패킷 길이: 1,000bit
	- 대역폭 지연 곱: (1*10^6) * (20*10^-3) = 20,00 bit
	- 선로 이용률 : 1,000 / 20,000 = 0.05 -> 5%
RTT: 딜레이 20밀리 세컨드

안정적인 데이터 수신이 가능하다
특히 링크가 불안정한 상황에서도 하나씩 하나씩 확인 응답을 해서 잘 받았다 라는 확인응답이 있을때 보내기 때문에
그래서 안정적으로 보낼수있다는 장점

만약 링크가 회선이 품질이 좋은 경우에는 필요 이상으로 확인응답을 하나 하나 받아서 확인응답을 해서 보내기때문에
채널 용량이 클수록 매우 비효율적




Go-Back-ARQ
Go-Back-N 프로토콜 	cf. N-프레임-후퇴
- 전송 효율을 높이기 위해 송신측은 확인 응답이 도착하기 전에 여러개의 패킷을 전송

Go Back N 방법은 송신측이 패킷을 연속적으로 보낼수있음
첫번째 0을보냄 수신측으로 확인응답을 안받아도 1번 2번을 보냄
수신측은 0번, 1번, 2번에 대해서 한꺼번에 2번까지 잘 받았기 때문에 ack 3을 보낼수있다
수신측이 ack3을 송신측에게 보냈다는 말은 2번까지 잘 받았고 그 다음 받을것은 3번이다 라는 의미

이렇게 여러개의 패킷을받아도 누적해서 하나의 확인으로 모든데이터에대한 확인 응답을 한다 그래서
이것을 누적 확인 시스템이라고 한다
0번에 대해서 잘 받았다는 의미로도 ack1번을 보낸다
1번을 잘 받았다는 의미로 ack2번을 보낸다
이런식으로도 보낼수있다

그래서 누적으로 한번만으로 확인을하건 매번 확인을하건 확인응답을 받지 않더라도 계속해서 보낼수있다 
3~6번까지 보냈다
3번을 받고나서 4번을 못 받고, 5번,6번은 받음
그러면 수신측은 뭔가 잘못됐다고 알게된다 5번에대해서 받았으니까 ack6을 보내는게 아니라
3번 다음에 5번을 받게 되면 무슨 문제가 발생했다는걸 수신측이 짐작함
이 경우에 수신측은 5번을 받고나서 ack6을 보내는게 아니라 다시한번 ack4를 보낸다
6번에 대해서도 마찬가지
송신측은 분명히 3번과 4번 5번 6번까지 전송을 함 그런데 계속 ack4가 온다
이상황에서 송신측은 어떻게 대응을 하느냐
3번을 보내고 6번까지 보넀지만 ack4가 계속 왔기때문에 다시 번호를 4번부터 보내게된다
그리고 5번,6번은 실제로 다시 전송했음에도 불구하고 그대로 수신이 잘 되었음에도
문제가 된 4번부터 Back해서 역박향으로 Back해서 4번부터 보내게된다

문제가 생긴 패킷에 대해서 패킷을 재전송할때 그 패킷부터 그 이후의 모든 패킷을 다 재전송한다
Stop-and-wait보다 효율적

Selective-Repeat 보다 버퍼관리측면에서는 좀 더 편리하다


Selective-Repeat 프로토콜	cf. 선택적 반복
- 실제로 손실된 패킷만 선택적으로 재전송

여기서는 0번을 받았다면 ack0번을 보내준다
이건 특정 프로토콜에서 약속하기 나름이다
0~3번 까지 다 패킷을 보냈는데
1번 패킷은 로스가됐다 0,2,3,까지는 ack 0,2,3을 받는다
필요한 패킷을 받고싶은것을 ack1번을 보낼수있다는것
아니면
1번 패킷을 보낸 타이머가 타임아웃이 되면 1번을 다시 재전송하게 되는것

장점은 선택적으로 재전송하는것
단점은 버퍼를 관리함에 있어서 데이터를 중간에 삽입하고 다른것은 여전히 저장해두어야함
	GoBackN 방식에 비해서 버퍼관리면에서는 좀 더 어렵다


양방향 프로토콜: 피기백킹(piggybacking)

양방향통신은 리시버가 센더가 될수도있다
센더도 리시버가 될수있다는 뜻
양쪽방향으로 데이터를 보낼수있다는 뜻
한 쪽에서 다른쪽으로 데이터를 보냈다고해보자
데이터를 수신한 쪽에서는 잘 받았다라는 의미로 확인응답을 보낸다
그런데 양방향통신이니 또 데이터를 보낼일이 있을것이다
그러면 데이터를 받은쪽에서는 확인응답을 보낼것이다
이 경우 응답과 자기가 송신할 데이터를 두번 따로 보내지 말고
하나의 패킷 헤더에 확인응답 번호와 데이터를 동시에 전송하게 되면 더 효율적
그래서 이렇게 양방향 통신에서 수신한 데이터의 확인응답과, 송신 데이터를
동시에 전송하는것을 피기백킹 이라고 한다















































