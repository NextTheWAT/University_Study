컴퓨터 네트워크 11주차 정리

13.2 전송 계층 프로토콜

Examples
- Simple Protocol
- Stop-and-Wait Protocol
- Go-Back-N Protocol
- Selective-Repeat Protocol
- Bo-directional Protocol: poggybacking


정지 대기 프로토콜 (Stop-and-Wait Protocol)
- 흐름제어, 오류제어 제공하는 연결 지향 프로토콜
- 송수신측 모두 크기가 1인 슬라이딩 윈도우 사용
	- 확인 응답이 오기 전까지 다음 패킷을 전송하지 않음
	- 채널에는 한 번에 하나의 패킷과 하나의 확인응답만 전송 가능
- 패킷 훼손 검사를 위해 검사합 (Checksun) 추가
	- 훼손 발견 -> 재전송
- 패킷을 전송할 때마다 타이머 구동
	- Timeout -> 재전송
- 순서번호(Sequence sumber), 확인응답번호(Acknowledgment number) 0번과 1번
	- Module-2 연산
송신 0 - 수신 1 - 송신 1 - 수신 0

더 많은 메모리를 사용할 필요가없으니 0번다음엔 1번 1번다음에는 다시 0번을 받는다
만약 오류가 발생했다면 수신측은 어떻게 반응할까
오류가 발생했다면 ack를 보내긴 보내는데 0번을 받은 것에 대해서 데이터가 오류가 발생했으니
다시 0번을 전송해달라고 요청 그래서 다시 ack0을 보내게 된다
송신측이 0번을 보냈지만 그거에대해서 다시 0번을 송신해달라고 수신측이 요청하는걸 봐서
문제가있었던것을 알고 다시 0번을 보냄

송신측에 데이터가있다고해서 연속적으로 보내지못함
수신측이 받을 준비가 되어있을때만 - 흐름제어
송수신측 모두 크기가1인 슬라이딩 윈도우 사용
슬라이딩 윈도우의 의미는 수신측으로부터 확인응답을 받지 않더라도 연속해서 보낼수있는 송신 데이터량을
송신측 윈도우 라고 얘기한다
wait은 보낼수있는 데이터량이 1개씩 송수신측 크기가 모두 1인 슬라이딩 윈도우를 사용

패킷을 전송할 때마다 타이머 구동 - 수신측에 도착했는데 오류가 발생한 경우 명시적으로 ack0를 보냈었는데 다시 한번 ack0를 보내서
명시적으로 재전송한 상황
만약 송신데이터가 수신측에 도착하지 않고 중간에 로스가 되었다면 그렇다면 수신측에서 송신측 데이터가 도착하지 않으니까
송신측이 데이터를 전송하지 않는구나 라고 판단하고 송신측 데이터가 도착할때까지 기다릴것이다
송신측은 중간에 사라졌는지를 모름 그러니 ack1번을 기다림 계속
이 상태는 데드락 상태에 빠지는것 수신측은 송신측이 아직 데이터를 보내지않는구나
송신측은 송신할 데이터가 있음에도 불구하고 수신측으로부터 아직 확인 응답을 계속해서 기다림
도착상태에 빠짐 - 이걸 막기위해 송신측이 데이터를 보낼때마다 타이머를 구동
타이머가 타임아웃 되기 전까지 ack가 도착하면 정상 구동
만약 타임아웃될때까지 ack가 도착하지 않는다면 확인응답을 수신측으로부터 받지않아도 송신측은
내가 이전에 보낸 데이터가 도착하지 않았구나를 판단하고 동일한정보를 재전송함

송신측이 하나의 데이터를 보내고 정지한 다음 수신측으로부터 확인 응답을 기다리는 stop and wait


정기 대기 프로토콜 (계속)
- 예제 13.4

안정적@
정지 대기 프로토콜 (계속)
- 효율
	- 채널이 두껍고 긴 경우에 비효율정      cf. 채널 = 파이프
- 대역폭 지연 곱(Bandwidth Delay Product)
대역폭 = 초당 전송할 수 있는 비트의 수
	- 비트로 표현된 파이프 의 용량
	- 파이프를 통해 전송되는 bit의 수가 많은 경우 전송 효율 향상
- 예제 13.5 : BW : 1Mbps, RTT: 20msec, 데이터 패킷 길이: 1,000bit
	- 대역폭 지연 곱: (1*10^6) * (20*10^-3) = 20,00 bit
	- 선로 이용률 : 1,000 / 20,000 = 0.05 -> 5%
RTT: 딜레이 20밀리 세컨드

안정적인 데이터 수신이 가능하다
특히 링크가 불안정한 상황에서도 하나씩 하나씩 확인 응답을 해서 잘 받았다 라는 확인응답이 있을때 보내기 때문에
그래서 안정적으로 보낼수있다는 장점

만약 링크가 회선이 품질이 좋은 경우에는 필요 이상으로 확인응답을 하나 하나 받아서 확인응답을 해서 보내기때문에
채널 용량이 클수록 매우 비효율적




Go-Back-ARQ
Go-Back-N 프로토콜 	cf. N-프레임-후퇴
- 전송 효율을 높이기 위해 송신측은 확인 응답이 도착하기 전에 여러개의 패킷을 전송

Go Back N 방법은 송신측이 패킷을 연속적으로 보낼수있음
첫번째 0을보냄 수신측으로 확인응답을 안받아도 1번 2번을 보냄
수신측은 0번, 1번, 2번에 대해서 한꺼번에 2번까지 잘 받았기 때문에 ack 3을 보낼수있다
수신측이 ack3을 송신측에게 보냈다는 말은 2번까지 잘 받았고 그 다음 받을것은 3번이다 라는 의미

이렇게 여러개의 패킷을받아도 누적해서 하나의 확인으로 모든데이터에대한 확인 응답을 한다 그래서
이것을 누적 확인 시스템이라고 한다
0번에 대해서 잘 받았다는 의미로도 ack1번을 보낸다
1번을 잘 받았다는 의미로 ack2번을 보낸다
이런식으로도 보낼수있다

그래서 누적으로 한번만으로 확인을하건 매번 확인을하건 확인응답을 받지 않더라도 계속해서 보낼수있다 
3~6번까지 보냈다
3번을 받고나서 4번을 못 받고, 5번,6번은 받음
그러면 수신측은 뭔가 잘못됐다고 알게된다 5번에대해서 받았으니까 ack6을 보내는게 아니라
3번 다음에 5번을 받게 되면 무슨 문제가 발생했다는걸 수신측이 짐작함
이 경우에 수신측은 5번을 받고나서 ack6을 보내는게 아니라 다시한번 ack4를 보낸다
6번에 대해서도 마찬가지
송신측은 분명히 3번과 4번 5번 6번까지 전송을 함 그런데 계속 ack4가 온다
이상황에서 송신측은 어떻게 대응을 하느냐
3번을 보내고 6번까지 보넀지만 ack4가 계속 왔기때문에 다시 번호를 4번부터 보내게된다
그리고 5번,6번은 실제로 다시 전송했음에도 불구하고 그대로 수신이 잘 되었음에도
문제가 된 4번부터 Back해서 역박향으로 Back해서 4번부터 보내게된다

문제가 생긴 패킷에 대해서 패킷을 재전송할때 그 패킷부터 그 이후의 모든 패킷을 다 재전송한다
Stop-and-wait보다 효율적

Selective-Repeat 보다 버퍼관리측면에서는 좀 더 편리하다


Selective-Repeat 프로토콜	cf. 선택적 반복
- 실제로 손실된 패킷만 선택적으로 재전송

여기서는 0번을 받았다면 ack0번을 보내준다
이건 특정 프로토콜에서 약속하기 나름이다
0~3번 까지 다 패킷을 보냈는데
1번 패킷은 로스가됐다 0,2,3,까지는 ack 0,2,3을 받는다
필요한 패킷을 받고싶은것을 ack1번을 보낼수있다는것
아니면
1번 패킷을 보낸 타이머가 타임아웃이 되면 1번을 다시 재전송하게 되는것

장점은 선택적으로 재전송하는것
단점은 버퍼를 관리함에 있어서 데이터를 중간에 삽입하고 다른것은 여전히 저장해두어야함
	GoBackN 방식에 비해서 버퍼관리면에서는 좀 더 어렵다


양방향 프로토콜: 피기백킹(piggybacking)

양방향통신은 리시버가 센더가 될수도있다
센더도 리시버가 될수있다는 뜻
양쪽방향으로 데이터를 보낼수있다는 뜻
한 쪽에서 다른쪽으로 데이터를 보냈다고해보자
데이터를 수신한 쪽에서는 잘 받았다라는 의미로 확인응답을 보낸다
그런데 양방향통신이니 또 데이터를 보낼일이 있을것이다
그러면 데이터를 받은쪽에서는 확인응답을 보낼것이다
이 경우 응답과 자기가 송신할 데이터를 두번 따로 보내지 말고
하나의 패킷 헤더에 확인응답 번호와 데이터를 동시에 전송하게 되면 더 효율적
그래서 이렇게 양방향 통신에서 수신한 데이터의 확인응답과, 송신 데이터를
동시에 전송하는것을 피기백킹 이라고 한다


















컴퓨터 네트워크 11주차 정리


제 14장

UDP의 특징(임무)

- Process-to-process 통신 생성 <- 포트 번호 이용
- 비연결형, 신뢰성이 없는 전송 프로토콜
	- IP (host-to-host 통신) 서비스에 추가되는 기능 거의 무
- 최소한의 오류 제어 메커니즘 수행 -> 오류탐지시 폐기
TCP처럼 재전송을 요구하거나 흐름제어, 혼잡제어 같은 전송제어는 하지않음
- 흐름제어 및 수신 패킷에 대한 확인응답 무
- 순서번호 무
- 프로세스로부터 데이터 단위를 받아 신뢰성 없는 전달 제공
- 최소한의 오버헤드만 사용하는 간단한 프로토콜
	- 작은 메시지 전송에 적합 (vs. TCP)


User Datagram
- 8바이트 고정 크기 헤더
- 사용자 데이터그램 형식

헤더 필드
Source prot number	Destination port number
Total length			Checksum


사용자 데이터그램 형식
- 발신지 포트 번호(siurce port number)
- 목적지 포트 번호(destination port number)
- 길이(Total length) = 헤더 + 데이터 		cf. TCP에는 무
	- UDP 길이 = IP 길이 - IP 헤더 길이
- 검사합 : 오류 발견
	- 사용자 데이터그램 전체 (헤더+데이터)에 대해 검사
	- 검사합 계산은 옵션(option)
UDP에서 책섬필드를 항상 사용하는 것은 아니다
이 기능을 사용하지 않겠다 하면 책섬필드 16비트를 all 0로 설정하면 된다


Process-to-Process 통신

TFTP - Trivial - File Transfer Protocol



UDP Services (계속)

비 연결형 서비스

- 각 데이터그램은 서로 독립적
- 연결 설정과 종료 과정 없이 서로 다른 경로로 전달될 수 있음
- 응용메세지의 분할/재조립 불가
	- 작은 메세지 (65507 bytes 이하) 를 보내는 프로세스만이 UDP 사용

흐름제어, 오류제어, 혼잡제어

- 간단하고 신뢰성 없는 프로토콜
- 흐름제어도 없고 윈도우 메커니즘도 없음
	- 수신측 오버플로우 발생 가능
- 검사합 외에는 오류 제어 메커니즘이 없음
	- 오류 발견시 폐기됨
- 흐름제어 및 기타 오류제어는 process(응용계층)가 제공해야함
- 혼잡제어 무


UDP 검사합에 포함된 부분
- 의사헤더(Pseudoheader), UDP 헤더, 응용 계층으로부터 온 데이터
#검사합 계산은 옵션사항 -> 검사합 계산 안할 경우는 0으로 채움 16비트를


UDP 검사합 예


캡슐화 와 역 캡슐화


큐잉 (Queing)
- UDP에서 사용되는 큐

흐름제어를 하지 않기 때문에 송신측이 일반적으로 수신측을 감내할 수 없는
처리하기 전에 많은 데이터를 송신하게 된다면 버퍼에서 오버플로우가 생길 수 있다


큐잉(계속)
- 클라이언트에서 프로세스가 시작될 때 운영체제에게 (임시)포트 번호(eqhemeral prot number) 요청
	- 서버 프로세스는 잘 알려진 포트번호 사용
	- 프로세스 당 하나의 포트번호 할당 -> 하나의 입력 큐와 출력 큐
	- 포트번호에 의해 큐를 구분
- 구현에 따라 입력 큐만, 또는 입/출력 큐 생성
- 프로세스가 종료되면 큐는 제거

Client 프로세스
- 출력 큐 : overflow 발생 시 OS는 process에게 waiting 요청
- 입력 큐 : 목적지 포트번호에 해당하는 큐가 있는지 조사
	- 있으면, UDP는 해당 입력 큐에 datagram 추가
	- 생성되어 있지 않으면 datagram 폐기 후, ICMP 프로토콜에게 "port unreachable" 메세지를 Server에 전송할 것을 요청
Server 프로세스 
- 출력 큐 : oerflow 발생 시 OS는 process에게 waiting 요청
- 입력 큐 : 목적지 포트번호에 해당하는 큐가 있는지 조사
	- 있으면, UDP는 해당 큥 datagram 추가
	- 생성되어 있지 않거나 Overflow 발생 시, datagram 폐기 후, ICMP 프로토콜에게 "prot unreachable" 메세지를 Client에 전송할 것을 요청


다중화 와 역 다중화


UDP Services(계속)

Note - UDP는 13장에서 설명한 비연결형 단순 프로토콜의 한 예이며, 오류 감지를 위해서
	 부가적인 검사합을 패킷에 포함한다는 것만 차이가 있다


UDP 응용
- 단순한 요청-응답을 필요로 하는 프로세스
- 흐름제어와 오류제어가 크게 필요하지 않은 프로세스
- 내부적인 흐름 제어와 오류 제어 메커니즘을 가지고 있는 프로세스 ex. TFTP
- 멀티캐스팅과 브로드캐스팅을 위한 전송 프로토콜
- SNMP와 같은 관리 프로세스
- RIP(Routing Information Protocol) 와 같은 경로 갱신 프로토콜에 사용
TCP를 사용하지않고 UDP를 사용한다
- 수신된 메시지의 조각들 간의 지연이 동일하지 않으면 안되는 실시간 응용들에 의해서 일반적으로 사용된다.


UDP 패키지 구성 요소
- 제어 블록 테이블
- 입력 큐
- 제어 블록 모듈
- 입력 모듈
- 출력 모듈




























