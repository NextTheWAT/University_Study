컴퓨터 네트워크 9주차 정리


IP 구성 요소
	- 헤더 추가 모듈
	- 처리 모듈
	- 큐
	- 포워딩 모듈
	- 라우팅 테이블
	- 단편화 모듈
	- MTU 테이블
	- 재조립 모듈
	- 재조립테이블

PDU = IP패킷
Processing module
프레그멘테이션 - 단편화
MTU값이 작다면 바로 링크 계층으로 내려감
ICMP - 아이피 패키지에 각각의 모듈에서 여러가지 이유로 패킷을 디스카드 할 경우는
	ICMP프로토콜이 구동을 하게 됨 이 프로토콜이 송신 호스트에게
	패킷을 디스카드한 이유를 보고하게됨


- 헤더 추가 모듈(Header-Adding Module)
상위계층으로부터 데이터와 목적지 주소정보를 수신하고
헤더를 구성하는 모듈 인캡 과정을 거치고
하나의 아이피데이터그램이 만들어진다
헤더를 추가하기 위해서는 책선필드의값을 구성해야한다
그러기위해서는 다른 데이터를 16비트씩 끊어서 책선을 구성해야한다

- 처리 모듈(Processing Module)
프로세싱 모듈은 만약 송신호스트라면 헤더에딩모듈을 거친 패킷을 받아서 처리를함
만약 중간노드 혹은 최족 목적지라면 링크 계층으로부터 올라온 데이터그램에서 처리를 한다
큐에 저장이 되어있는데 그 데이터그램을 꺼내서 처리를 한다
그 데이터그램의 데이터주소가 로컬 어드레스와 매칭해야한다 는것은
아이피 모델 자체가 최종목적지에서 구현되고있는 아이피 패키지다
해당되는 데이터그램을 리어셈블리 모듈로 보낸다

로컬 호스트가 최종목적지가 아니고 라우터단이라면 TTL값을 1을 감소시키고
그 값이 0거나 0이하라면 데이터그램을 디스카드한다
디스카드하면 ICMP프로토콜이 동작하여 송신호스트에게 보내게된다
ICMP에러 메세지를 보내는것은 IP에 에러가 생겼을때 ICMP프로토콜이 구동되는것이다
그다음 포워딩모듈로 빠진다

- 큐(Queue) - 입/출 큐
- 라우팅 테이블: 패킷의 다음 홉 주소 결정하기 위해 포워딩 모듈이 사양
- 포워딩 모듈: 6장참조
- MTU 테이블: 단편화 모듈이 특정 인터페이스의 MTU를 찾기 위해 사용


- 단편화 모듈(Fragmentation Module)
데이터그램의 사이즈값을 보고 사이즈값이 포워딩모듈에서 결정된 링크의 엠티유값보다 클 경우에
돈프레그먼트 플래그값이 세팅되어 있는지를 봐야한다
사이즈값이 데이트값 엠티유값보다 클 경우 프레그멘테이션을 해야한다
그런데 돈프레그먼트값이 1로 세팅이 되어있다면 단편화를 할수없으므로
디스카드 해야하고 ICMP 에러메세지가 송신호스트에게 보내지게된다

돈프레그먼트의 값이 세팅이 된게아니라면 프레그먼트를 할수있다
여러가지 단편들로 나누고 단편들에 헤더들을 추가해서
여러가지 옵션들을 프레그먼트에 추가한다(헤더)
그다음에 해당되는 프레그먼트를 전송하는 과정을 거치게 된다

- 재조립 테이블(Reassembly table)
	- 재조립 모듈에 의해 사용
	- 재조립 테이블
재조립 테이블에 여러 가지 필드값은 어떤 상태정보라던지 소스어드레스라던지 데이터그렘id라던지
단편화가 됐을 경우에 하나의 한 몸이었다 라고 하는 나누어진 단편들을 구분해야하기 때문에
id값을 리어셈블리 테이블에 필드를 기록하게 된다
단편들이 하나라도 도착하지 않으면 재조립할수없다
그동안 다른 단편들을 임시로 저장해야한다 타임 아웃될때까지만 저장되는데
타임아웃되는 값을 또 관리한다
프레그먼트는 각각의 단편들이 연속해서 도착하지 않으니 재조립하기위해서 포인터를 사용해
그 다음단편 그다음단편 연결을 시켜서 재조립을 하게된다
다음 단편의 주소값을 필드로 기록하게된다

- 재조립 모듈(Reassembly Module)
오프셋 이 0이면 첫 번째 단편
모어프레그먼트가 0면 단편 이후에 또 다른 단편이 없다는 얘기
오프셋 벨류가 0이면 유일한 단편이라는 소리다
다른 단편으로 나뉘어진적이 없는 것이다
이럴 경우에는 재조립테이블을 통해 기다릴 필요가없는것
이럴 경우에는 적절한 큐에다가 바로 상위계층으로 올리게 된다
재조립을 할 필요가 없다는 얘기

만약 유일한 단편이 아니라면 단편들이 나누어져있는것이니
리어셈블리 테이블을 검색해서 처리해야한다
그런데 리어셈블리 테이블에 기록되어있는 어떤 엔트리가 전혀 없다면
현재의 단편부터 리어셈블리 테이블에 새로운 엔트리로 기록을 해야한다
데이터그램을 메모리에 집어넣고 메모리의 시작주소를 리서엠블리 테이블에 기록을 해야한다
그래야 다른 단편들이 다른 단편들의 데이터들을 모아서 묶어 재조립을 한다

모든 프레그먼트들이 도착을 했다면 재조립을 하고 상위계층으로 보낸다
물론 큐를 통해서 보내게된다
만약 다 도착하지 않고 타임아웃이 됐다면
아직까지 모든 단편들이 오지않은 상황에서 타임아웃이 된다면
디스카드 해버리고 ICMP메세지가 송신 호스트에게 전송된다





- 논리 주소 vs 물리 주소
- 주소 변환 (Address Mapping)
	- 정적 변환 (Static mapping)
		- 논리 주소와 물리 주소 연관 테이블 -> 네트워크상의 각 시스템에 저장
		- 필요시 테이블 검색
		- 물리 주소가 변결될 경우 정적 테이블의 주기적인 갱신으로 인한 오버헤드
정적변환은 특수한 경우에만 사용
	- 동적 변환 (Dynamic mapping)
		- 물리 주소와 논리 주소 쌍 중 하나만 알면 -프로토콜-을 이용하여 다른 하나를 알아냄
		- @ARP@: 논리 주소를 물리 주소로 변환
		- RARP: 물리 주소를 논리 주소로 변환
일반적으로는 동적변환 ARP를 사용함
RARP는 R 리버스 ARP라고 생각하면됨
역순 주소 결정 프로토콜(Reverse Address Resolution Protocol, RARP)은 IP호스트가 자신의 물리 네트워크 주소(MAC)는 
알지만 IP주소를 모르는 경우, 서버로부터 IP주소를 요청하기 위해 사용한다.


ARP 프로토콜

- TCP/IP 프로토콜 모음 내에서 ARP의 위치

- ARP동작
ARPrequest
ARPreply
서로 패킷교환을 통해 찾아온다


ARP 패킷 타입

Hardware Type = 1 의 값을 가짐 16비트 
Protocol Type = 0800 IPv4 버전 경우에 16비트

Hardware length = 6 맥 주소의 길이
Protocol = 4 IPv4 버전
Operation Request 1, Reply 2

Sender gardware address = 맥주소
Sender protocol address = IP주소
Target hardware address = 맥주소
Target protocol address = IP주소

다시 정리하면

ARP 패킷 (계속)
Hardware type : 네트워크 유형 정의(이더넷 : 1)
protocol type : 프로토콜 정의(IPv4 : 0800(16))
Hardware length : 물리 주소의 바이트 단위 길이
Protocol length : 논리 주소의 바이트 단위 길이
Operation : 패킷 유형 - ARP 요청(1), ARP 응답(2)
Sender hardware address : 송신자 물리 주소
Sender protocol address : 송신자 논리 주소
Target hardware address : 타겟 물리 주소
Targer protocol address : 타겟 논리 주소



캡슐화 (Encapsulation)
	- ARP 패킷의 캡슐화
Preamble and SFD = 8바이트
Destination address = 6바이트
Source address = 6바이트
Type or length = 2바이트 0806
Data = ARP request or reply packet
CRC = 4바이트 부가 정보

ARP 프로세스의 캡슐화 동작 과정
1. 송신자는 타겟 IP 주소를 알고있다
2. IP가 ARP에게 ARP 요청 메세지 생성 요정
	(송신자 물리 주소, IP주소; 타겟 IP주소, 물리 주소(O))
3. 데이터링크층에 전달되면 발신지 주소는 송신자의 물리 주소, 목적지 주소는
	물리 브로드캐스트 주소로 하는 프레임에 캡슐화
4. 모든 호스트나 라우터가 프레임을 수신하여 자신의 ARP에 전달
5. 타겟 시스템은 자신의 물리 주소를 포함한 ARP 응답 메세지 송신(유니캐스트)
6. 송신자는 응답 메세지를 받고 타겟 시스템의 물리 주소를 알게 된다
7. IP 데이터그램은 프레임으로 캡슐화 되어 목적지에 유니캐스트


ARP가 사용되는 4가지 경우
1. 센더 - 리시버
2. 센더 - 라우터
3. 라우터 - 라우터
4. 라우터 - 리시버


Proxy ARP
	- 서브넷팅 효과를 만들기 위해 사용
		- 네트워크 설정 변경 필요 없음
일반 라우터 일때 모든 호스트들의 서브넷 마스크와 게이트웨이 주소 심지어는 IP주소
도 바뀌었을 가능성이 많을테니 이걸 전부다 일일히 바꿔야 한다는것
서브넷팅을 하니 모든 호스트들의 네트워크 설정을 바꿔야한다 그런데 일반 라우터가 아니라
Proxy ARP 기능을 하는 라우터라면 기존에 사용하던 IP주소를 전혀 변경하지 않고
동일한 서브넷팅 효과를 가져갈수있다
어떤 식이냐면 다른 네트워크에있는 호스트들이 같은 네트워크에 있다고 생각하는것이다
여전히 서브넷팅되어있다는 사실을 모른다 그리고 목적지는 여전히 자신과 같은 네트워크에 있다고 생각하는것이다.


ARP 패키지
구성 요소
- 캐쉬 테이블
- 큐
- 출력 모듈
- 입력 모듈
- 캐쉬 제어 모듈
































