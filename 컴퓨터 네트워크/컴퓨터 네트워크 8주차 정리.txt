컴퓨터 네트워크 8주차 정리

제 7장 IPv4


IP프로토콜
	- TCP/IP에서 사용되는 패킷 전송 메커니즘
	- @신뢰성 없는@ 비연결형 데이터그램 프로토콜
		- 오류검사 및 추적 기능을 수행하지 않음
헤더에 대해서는 오류검사를 수행함
데이터에대해서만 오류검사를 하지않지 헤더에대해서는 함 @@
		- 최선노력 전달 서비스
전달하려고 노력하지만 신뢰성있는 데이터전송을 고정하지는 않음 
신뢰성 보장x@
IP가 왜 오류검사를 수행하지 않을까
IP는 네트워크 계층 프로토콜이다
송신~수신자까지 중간 노드(라우터)를 거쳐서 도착
라우터는 3계층까지 동작 L3
네트워크계층 프로토콜 이므로 중간 노드인 라우터가 다 본다는 뜻
송신자가 보낸 IP패킷이 링크를 타고 라우터를 통해서 2계층 프레임의 헤더와 테일이 
디캡이 되어서 네트워크 계층의 IP데이터그램이 그대로 전달된다는 뜻
그런데 라우터가 네트워크계층을 수행함으로 라우터가 만약 IP에 데이터오류검사를 수행하게된다 그러면
지나가는 라우터들마다 IP패킷의 데이터부분 오류를 계속해서 채킹하게되는 결과가 될것
매번 데이터에 대해서 오류검사를 계속 하는것이 안정적이겠지만 전체적으로 패킷을 전송하는데
딜레이가 너무 심해진다
그래서 중요한 헤더에 대해서만 (데이터량이 적기때문)
헤더의 필드에 대한 오류는 검사를 하지만 데이터에대한 오류검사는 하지 않는다

		- 각 데이터그램은 독립적으로 처리@
라우터들마다 패킷 단위로 라우팅을 대처하기때문에 동일한 송신자와 목적지라 하더라도
데이터가 지나가는 경로는 달라질수있음
		- 각 데이터그램은 서로 다른 경로로 전달될 수 있음@
		- 각 데이터그램은 순서가 바뀌어 전달될 수 있음@
비연결형은 송수신간에 연결을 확립하지 않기때문에
모든 데이터그램, 패킷이 독립적으로 처리가 됨
여기까지 IP프로토콜의 특징 네트워크계층에 속함
4계층의 트랜스포트계층의 대표적 프로토콜은 TCP
3계층의 네트워크계층의 대표적 프로토콜은 IP


IP데이터그램: 네트워크 계층의 패킷
	20~65335비트다
	헤더: 20~60비트
	데이터:

헤더: 20~60비트
	- VER - 4비트 : 0100(버전)
IPv6는 헤더의 필드들이 완전히 새롭게 정의되기때문에 IPv6는 해당이 안됨
	- HLEN - 4비트 : 헤더의 길이를 의미함
헤더의 길이가 만약 고정적이라면 어디서부터 어디까지인지 알수가있다
하지만 IPv4는 옵션까지 추가해서 가변적이기때문에 정확하게 헤더와 데이터의 경계를 수신측은 알수없음
헤더의 길이를 표기해줄 필요가 있음
수신측은 HLEN를 보고 데이터길이가 어디서부터 어디까지인지 알수있다


HLEN: 바이트단위가 아닌 4바이트 단위로 표현할수밖에 없음
	헤더의 길이가 10진수로 5라면 20바이트 0101
Service type: 8비트 - 현재 서비스타입자리의 필드는
		6비트 - DSCP 라는 필드로 정의되어있고
		2비트 - ECN 이라는 필드로 정의되어있음
Total length: 16비트 - 2^16 = 0~65535 (표현할수있는 범위)
		IP헤더의 필드에 토탈렝스 값이 65535라서 최대값이 65535다

2번째 필드들은 단편화에 해당하는 필드들이다
Identification
Flags
Fragmentation offset
단편화

3번째 필드
Time to live: 8비트 TTL 필드 - 송신측부터 수신측까지 중간에 라우터단을 거쳐서 데이터그램이 전달된다
			이때 IP데이터그램은 라우터단을 지나갈 때 마다 Time to live에 설정된 값에서부터 1씩 감소하게 된다
			이렇게 하는 이유는 만약 패킷이 라우팅이 실패가 일어나거나 완전한 오류가 있어서 목적지까지 도착하지 못하고
			라우팅루프가 생겼다거나 한다면 인터넷 안에서 로스된 패킷이 계속 전송을 반복하는 이런 문제점이 생긴다
			이 문제를 해결하기위해 정의된 필드가 TTL 필드이다	
			로스 된 패킷이 네트워크에서 돌아다닌다면 TTL필드가 0이되면 라우터는 그 즉시 그 패킷, 데이터그램을 디스카드 한다(버린다)
			그래서 중요하다@@
Protocol: 8비트 IP에 들어가있는 데이터가 상위계층에 혹은 IP에 의해서 인캡된 데이터의 정체가 무엇인지 TCP일수도있고 SCTP일수도있고
		네트워크계층에 어떤것일수도있음 그래서 이 데이터의 정체가 무엇인지에 대해 저장한것이 Protocol 필드이다
		정의해놓은 값이 있어서 그걸 판별함
Header checksum: 16비트 - 헤더에 대해서 오류검출을 하기위해 사용되는 필드
		
4번째 필드
Source IP address - 32비트

5번째 필드
Destination IP address - 32비트

6번째 필드
Options + padding - 0 to 40 바이트


IP데이터그램
	- 가변 길이 패킷
	- 헤더와 데이터 부분으로 구성
	- 헤더 : 20~60 바이트 길이, 라우팅과 전달에 필요한 정보

	- 헤더 내의 필드
		- 버전(Ver) - IP 프로토콜 버전(4비트)
		- 헤더길이(HLEN) - 헤더의 전체 길이를 4바이트 단위로 표시(4비트)

- 서비스 유형 (Service type) : 8 bits
	- 라우터에 의해 처리하는 방법
	- Codepoint : 우선순위 또는 차별화서비스(DS)
하위 3비트가 000인경우 상위 3비트는 우선순위를 나타낸다
이 데이터그램이 라우터를 지나갈때 라우터단이 IP헤더에 있는 코드포인트값을 보고 우선순위가 높은경우와 낮은경우를 구분
만약 네트워크에 컨제스쳔(폭주) 네트워크 데이터그램이 지나가는 데이터가 아주 많다 네트워크에서 폭주가 일어나고있다
그러면 우선순위가 낮은것부터 디스카드 해버린다 그리고 우선순위가 높은것 부터 처리를 한다

하위비트가 0,11,01 이라면 상위 비트는 서비스 타입을 의미한다 여기에서의 서비스라는것은
최소지원을 요구하는 서비스, 실시간 인터넷 서비스(최소지연을 요구), 최대 성능을 요구(일정시간동안 도달할수있는 데이터를 최대로)
이렇게 다양한 종류의 서비스 요구사항을 가지고있는 차별화된 서비스의 타입들을 코드를 통해서 정의해줄수있다.

다양한 서비스의 종류를 저장해놓은 필드이다 - DSCP
	- DS (Differentiated Services) cf.과거 : TOS(Type of Services)
ECN - 하위 2비트는 혼잡을 알려준다 라는 뜻
	혼잡 제어는 4계층의 기능이다(트랜스포트 계층) 
	트랜스포트 계층에서 혼잡을 발생했다는것을 추적한다 혼잡이 발생했을경우 송신량을 조절함으로서
	혼잡현상을 해결하고자 시도한다
	어떠한 혼잡현상을 겪고있는 라우터단이 송신자에게 혼잡이 발생하고있다는 사실을 명시적으로 알려줄수있도록 정의해놓은 필드가
	IP헤더의 ECN필드라는것!
	
- 전체길이(Total Length)
	- 16bits 필드(65535 까지 표현)
	- IP 데이터그램의 전체 길이를 바이트 단위로 표시
	- 데이터 길이 = 전체 길이 - 헤더 길이
	- 이더넷 프레임에서 작은 데이터그램의 캡슐화
		- Data와 Padding 구분위해 필요
2계층 데이터 프레임에서 부가정보, 패딩되는 정보를 구분해낼수있기때문

순수한 IP데이터그램의 데이터가 41이고 패딩된부분이 5바이트
이러한 프레임이 링크계층을 타고 다른 호스트에 수신을 하게 되었다고 가정하자
목적 호스트가 받았는데 디캡을 하죠 그럼 헤더를 버식고 트레일러를 벗깁니다
그러면 인캡된 데이터의 길이는 46이다 그 중에 나머지 5바이트가 올 0인데
이게 패딩된것인지 실제 데이터인지 수신측이 어떻게 파악할까
그때 판단할수있는 근거가 토탈랭스필드이다 받는 쪽에서 2계층 헤더와 트레일러를 벗기고
나서 안에있는 데이터의 길이는 46이지만 IP헤더의 토탈랭스필드의 길이는 41이기 때문에
여기서 5바이트는 뭐다? 최소길이를 맞춰주기위한 패딩된 임의적으로 삽입된 데이터다라는 것을 알고
이 5바이트를 버리게 된다는 뜻이다.




단편화 (Fragmentation)
	- 물리적인 네트워크가 사용하는 프로토콜에 따라 프레임 형식과 크기가 서로 다르다
	- 각 링크에서 전달될 수 있는 최대 전송 길이를 MTU 라고 함
		- MTU는 SDU의 길이다@@
	- MTU 길이에 따라 나누어 보내는 것 을 단편화라고 함
	- 단편들의 재조립은 목적지 Host에서만 이루어짐
만약 2천3천4천이라면 그대로 밑으로 보내지않고 데이터를 잘라서 내려보낸다
정의해놓은 엠티유값보다 클 경우에는 두개의 이상의 단편으로 나누어서 링크계층으로 전송할 수 밖에 없다 
이렇게 나누어진 단편들을 다시 언졔가는 재조립이 되어야하는데 언제 되냐
목적지 호스트에서만 재조립이 가능하다
라우터단에서는 단편들의 재조립이 불가능할까 이것은 하나의 데이터그램이 여러개의 단편으로
나누어져도 단편마다 독립적인 데이터그램이다
라우터에서 나누어진 단편들을 재조립하기위해서는 각 한모음이였던 단편들이 동일한 라우터를 지나가야 함
IP데이터그램은 비연결형이다 그러니 독립된 경로로 지나감
특정 라우터단을 지나간다는 보장이 없음 그래서 중간 라우터단에서 재조립을한다는건 불가능하다는것
그래서 최종 목적지에서만 각 단편들의 재조립이 가능하다
나누어졌다해도 동일한 목적지를 가지고있기때문에@


- MTU (Maximum Transfer Unit)
예를들어 2천바이짜리 IP데이터그램이 있을때
IP계층에서 라우팅결과 내보내야할 링크가 이더넷 링크라면 프레그멘테이션을 하겠지여
이더넷링크는 엠티유값이 1500이므로 이것보다 큰것은 보낼수없기때문
따라서 프레그멘테이션을 수행해서 링크계층으로 보낼것

동일한 2천바이트짜리 IP데이터그램이있는데 라우팅결과가 내보내야할 인터페이스가
FDDR 이라고하는 링크쪽으로 내려보낸다면 엠티유값이 4352바이트이므로
프레그멘테이션을 할 필요가 없다 왜냐하면 엠티유값보다 작은 바이트이기 때문


단편화와 관련된 필드
	- 식별자(Identification) - 단편들은 같은 식별자 값을 가짐
	- 플래그(flag) - 3비트 빌드
		- 1st bit : not used   => 0
		- 2nd bit : Do not fragment   (Don't fragment)
			- '1' : 단편화 불가 -> 전송 불가시 폐기 (ICMP 에러 메세지 전송)
			- '0' : 단편화 가능
		- 3rd bit : More fragment
			- '1' : 마지막 단편이 아님
			- '0' : 마지막 단편이거나, 유일한 단편
결국 엠티유값보다 큰 IP데이터그램일 경우 단편화 불가 돈프레그먼트가 1일 경우에는 전송할 수가 없으므로
그 라우터는 폐기하게 된다 디스카드










































