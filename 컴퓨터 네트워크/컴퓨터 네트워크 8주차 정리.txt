IP프로토콜
	- TCP/IP에서 사용되는 패킷 전송 메커니즘
	- @신뢰성 없는@ 비연결형 데이터그램 프로토콜
		- 오류검사 및 추적 기능을 수행하지 않음
헤더에 대해서는 오류검사를 수행함
데이터에대해서만 오류검사를 하지않지 헤더에대해서는 함 @@
		- 최선노력 전달 서비스
전달하려고 노력하지만 신뢰성있는 데이터전송을 고정하지는 않음 
신뢰성 보장x@
IP가 왜 오류검사를 수행하지 않을까
IP는 네트워크 계층 프로토콜이다
송신~수신자까지 중간 노드(라우터)를 거쳐서 도착
라우터는 3계층까지 동작 L3
네트워크계층 프로토콜 이므로 중간 노드인 라우터가 다 본다는 뜻
송신자가 보낸 IP패킷이 링크를 타고 라우터를 통해서 2계층 프레임의 헤더와 테일이 
디캡이 되어서 네트워크 계층의 IP데이터그램이 그대로 전달된다는 뜻
그런데 라우터가 네트워크계층을 수행함으로 라우터가 만약 IP에 데이터오류검사를 수행하게된다 그러면
지나가는 라우터들마다 IP패킷의 데이터부분 오류를 계속해서 채킹하게되는 결과가 될것
매번 데이터에 대해서 오류검사를 계속 하는것이 안정적이겠지만 전체적으로 패킷을 전송하는데
딜레이가 너무 심해진다
그래서 중요한 헤더에 대해서만 (데이터량이 적기때문)
헤더의 필드에 대한 오류는 검사를 하지만 데이터에대한 오류검사는 하지 않는다

		- 각 데이터그램은 독립적으로 처리@
라우터들마다 패킷 단위로 라우팅을 대처하기때문에 동일한 송신자와 목적지라 하더라도
데이터가 지나가는 경로는 달라질수있음
		- 각 데이터그램은 서로 다른 경로로 전달될 수 있음@
		- 각 데이터그램은 순서가 바뀌어 전달될 수 있음@
비연결형은 송수신간에 연결을 확립하지 않기때문에
모든 데이터그램, 패킷이 독립적으로 처리가 됨
여기까지 IP프로토콜의 특징 네트워크계층에 속함
4계층의 트랜스포트계층의 대표적 프로토콜은 TCP
3계층의 네트워크계층의 대표적 프로토콜은 IP


IP데이터그램: 네트워크 계층의 패킷
	20~65335비트다
	헤더: 20~60비트
	데이터:

헤더: 20~60비트
	- VER - 4비트 : 0100(버전)
IPv6는 헤더의 필드들이 완전히 새롭게 정의되기때문에 IPv6는 해당이 안됨
	- HLEN - 4비트 : 헤더의 길이를 의미함
헤더의 길이가 만약 고정적이라면 어디서부터 어디까지인지 알수가있다
하지만 IPv4는 옵션까지 추가해서 가변적이기때문에 정확하게 헤더와 데이터의 경계를 수신측은 알수없음
헤더의 길이를 표기해줄 필요가 있음
수신측은 HLEN를 보고 데이터길이가 어디서부터 어디까지인지 알수있다


HLEN: 바이트단위가 아닌 4바이트 단위로 표현할수밖에 없음
	헤더의 길이가 10진수로 5라면 20바이트 0101
Service type: 8비트 - 현재 서비스타입자리의 필드는
		6비트 - DSCP 라는 필드로 정의되어있고
		2비트 - ECN 이라는 필드로 정의되어있음
Total length: 16비트 - 2^16 = 0~65535 (표현할수있는 범위)
		IP헤더의 필드에 토탈렝스 값이 65535라서 최대값이 65535다

2번째 필드들은 단편화에 해당하는 필드들이다
Identification
Flags
Fragmentation offset
단편화

3번째 필드
Time to live: 8비트 TTL 필드 - 송신측부터 수신측까지 중간에 라우터단을 거쳐서 데이터그램이 전달된다
			이때 IP데이터그램은 라우터단을 지나갈 때 마다 Time to live에 설정된 값에서부터 1씩 감소하게 된다
			이렇게 하는 이유는 만약 패킷이 라우팅이 실패가 일어나거나 완전한 오류가 있어서 목적지까지 도착하지 못하고
			라우팅루프가 생겼다거나 한다면 인터넷 안에서 로스된 패킷이 계속 전송을 반복하는 이런 문제점이 생긴다
			이 문제를 해결하기위해 정의된 필드가 TTL 필드이다	
			로스 된 패킷이 네트워크에서 돌아다닌다면 TTL필드가 0이되면 라우터는 그 즉시 그 패킷, 데이터그램을 디스카드 한다(버린다)
			그래서 중요하다@@
Protocol: 8비트 IP에 들어가있는 데이터가 상위계층에 혹은 IP에 의해서 인캡된 데이터의 정체가 무엇인지 TCP일수도있고 SCTP일수도있고
		네트워크계층에 어떤것일수도있음 그래서 이 데이터의 정체가 무엇인지에 대해 저장한것이 Protocol 필드이다
		정의해놓은 값이 있어서 그걸 판별함
Header checksum: 16비트 - 헤더에 대해서 오류검출을 하기위해 사용되는 필드
		
4번째 필드
Source IP address - 32비트

5번째 필드
Destination IP address - 32비트

6번째 필드
Options + padding - 0 to 40 바이트


IP데이터그램
	- 가변 길이 패킷
	- 헤더와 데이터 부분으로 구성
	- 헤더 : 20~60 바이트 길이, 라우팅과 전달에 필요한 정보

	- 헤더 내의 필드
		- 버전(Ver) - IP 프로토콜 버전(4비트)
		- 헤더길이(HLEN) - 헤더의 전체 길이를 4바이트 단위로 표시(4비트)

- 서비스 유형 (Service type) : 8 bits
	- 라우터에 의해 처리하는 방법
	- Codepoint : 우선순위 또는 차별화서비스(DS)
하위 3비트가 000인경우 상위 3비트는 우선순위를 나타낸다
이 데이터그램이 라우터를 지나갈때 라우터단이 IP헤더에 있는 코드포인트값을 보고 우선순위가 높은경우와 낮은경우를 구분
만약 네트워크에 컨제스쳔(폭주) 네트워크 데이터그램이 지나가는 데이터가 아주 많다 네트워크에서 폭주가 일어나고있다
그러면 우선순위가 낮은것부터 디스카드 해버린다 그리고 우선순위가 높은것 부터 처리를 한다

하위비트가 0,11,01 이라면 상위 비트는 서비스 타입을 의미한다 여기에서의 서비스라는것은
최소지원을 요구하는 서비스, 실시간 인터넷 서비스(최소지연을 요구), 최대 성능을 요구(일정시간동안 도달할수있는 데이터를 최대로)
이렇게 다양한 종류의 서비스 요구사항을 가지고있는 차별화된 서비스의 타입들을 코드를 통해서 정의해줄수있다.

다양한 서비스의 종류를 저장해놓은 필드이다 - DSCP
	- DS (Differentiated Services) cf.과거 : TOS(Type of Services)
ECN - 하위 2비트는 혼잡을 알려준다 라는 뜻
	혼잡 제어는 4계층의 기능이다(트랜스포트 계층) 
	트랜스포트 계층에서 혼잡을 발생했다는것을 추적한다 혼잡이 발생했을경우 송신량을 조절함으로서
	혼잡현상을 해결하고자 시도한다
	어떠한 혼잡현상을 겪고있는 라우터단이 송신자에게 혼잡이 발생하고있다는 사실을 명시적으로 알려줄수있도록 정의해놓은 필드가
	IP헤더의 ECN필드라는것!
	
- 전체길이(Total Length)
	- 16bits 필드(65535 까지 표현)
	- IP 데이터그램의 전체 길이를 바이트 단위로 표시
	- 데이터 길이 = 전체 길이 - 헤더 길이
	- 이더넷 프레임에서 작은 데이터그램의 캡슐화
		- Data와 Padding 구분위해 필요
2계층 데이터 프레임에서 부가정보, 패딩되는 정보를 구분해낼수있기때문

순수한 IP데이터그램의 데이터가 41이고 패딩된부분이 5바이트
이러한 프레임이 링크계층을 타고 다른 호스트에 수신을 하게 되었다고 가정하자
목적 호스트가 받았는데 디캡을 하죠 그럼 헤더를 버식고 트레일러를 벗깁니다
그러면 인캡된 데이터의 길이는 46이다 그 중에 나머지 5바이트가 올 0인데
이게 패딩된것인지 실제 데이터인지 수신측이 어떻게 파악할까
그때 판단할수있는 근거가 토탈랭스필드이다 받는 쪽에서 2계층 헤더와 트레일러를 벗기고
나서 안에있는 데이터의 길이는 46이지만 IP헤더의 토탈랭스필드의 길이는 41이기 때문에
여기서 5바이트는 뭐다? 최소길이를 맞춰주기위한 패딩된 임의적으로 삽입된 데이터다라는 것을 알고
이 5바이트를 버리게 된다는 뜻이다.




단편화 (Fragmentation)
	- 물리적인 네트워크가 사용하는 프로토콜에 따라 프레임 형식과 크기가 서로 다르다
	- 각 링크에서 전달될 수 있는 최대 전송 길이를 MTU 라고 함
		- MTU는 SDU의 길이다@@
	- MTU 길이에 따라 나누어 보내는 것 을 단편화라고 함
	- 단편들의 재조립은 목적지 Host에서만 이루어짐
만약 2천3천4천이라면 그대로 밑으로 보내지않고 데이터를 잘라서 내려보낸다
정의해놓은 엠티유값보다 클 경우에는 두개의 이상의 단편으로 나누어서 링크계층으로 전송할 수 밖에 없다 
이렇게 나누어진 단편들을 다시 언졔가는 재조립이 되어야하는데 언제 되냐
목적지 호스트에서만 재조립이 가능하다
라우터단에서는 단편들의 재조립이 불가능할까 이것은 하나의 데이터그램이 여러개의 단편으로
나누어져도 단편마다 독립적인 데이터그램이다
라우터에서 나누어진 단편들을 재조립하기위해서는 각 한모음이였던 단편들이 동일한 라우터를 지나가야 함
IP데이터그램은 비연결형이다 그러니 독립된 경로로 지나감
특정 라우터단을 지나간다는 보장이 없음 그래서 중간 라우터단에서 재조립을한다는건 불가능하다는것
그래서 최종 목적지에서만 각 단편들의 재조립이 가능하다
나누어졌다해도 동일한 목적지를 가지고있기때문에@


- MTU (Maximum Transfer Unit)
예를들어 2천바이짜리 IP데이터그램이 있을때
IP계층에서 라우팅결과 내보내야할 링크가 이더넷 링크라면 프레그멘테이션을 하겠지여
이더넷링크는 엠티유값이 1500이므로 이것보다 큰것은 보낼수없기때문
따라서 프레그멘테이션을 수행해서 링크계층으로 보낼것

동일한 2천바이트짜리 IP데이터그램이있는데 라우팅결과가 내보내야할 인터페이스가
FDDR 이라고하는 링크쪽으로 내려보낸다면 엠티유값이 4352바이트이므로
프레그멘테이션을 할 필요가 없다 왜냐하면 엠티유값보다 작은 바이트이기 때문


단편화와 관련된 필드
	- 식별자(Identification) - 단편들은 같은 식별자 값을 가짐
	- 플래그(flag) - 3비트 빌드
		- 1st bit : not used   => 0
		- 2nd bit : Do not fragment   (Don't fragment)
			- '1' : 단편화 불가 -> 전송 불가시 폐기 (ICMP 에러 메세지 전송)
			- '0' : 단편화 가능
결국 엠티유값보다 큰 IP데이터그램일 경우 단편화 불가 돈프레그먼트가 1일 경우에는 전송할 수가 없으므로
그 라우터는 폐기하게 된다 디스카드
돈 프레그멘트의 값이 0이라면 별도로 단편화 불가와같은 옵션을 사용하지 않는다는것
아이피 데이터그램의 길이가 특정 링크의 엠티유 보다 클 경우에는 단편화를 정상적으로 해서
전송하라 라는뜻
		- 3rd bit : More fragment
			- '1' : 마지막 단편이 아님
			- '0' : 마지막 단편이거나, 유일한 단편
무브 프레그먼트 (더 많은 프레그먼트가 있다는 뜻)
나 자신의 단편보다 더 많은 프레그먼트가 있으니까 내가 마지막 단편이 아니라는 뜻
무브프레그먼트는 어떤 특정 단편에 무브프레그먼트가 1이란말은 나 말고 다른 프레그먼트들이 많다 라고
적어도 나는 마지막 단편이 아니라는 뜻
반면에 0라면 더 많은 단편이 존재하지 않는다 라는 뜻
지금 현재의 아이피 데이터그램의 단편이 유일하다 그 말은 단편이 나누어져 있지 ㅇ낳다란느 뜻이거나
단편들 중에 마지막 단편이라는 뜻이다

최종 목적지에서 조립할때 언제까지 모든 단편들이 도착할때까지 기다려야할까
단편들이 10개로 나눠져있는지 20개로 나눠져있는지 모른다
올때마다 조립은 아이덴티피케이션 필드를 보고 조립을 한 몸이였다 원래 하나의 아이피 데이터그램에
속한 단편들이라는것은 알지만 언제까지 이 단편들을 모아야할까 - 마지막 단편이 올때까지
그때 사용할수있는 정보가 되는것 @@ 무브 프레그먼트


단편화 옵셋(Fragmentation offset) : 13bits 필드
	- 전체 데이터그램에서 단편의 상대적인 위치(8바이트 단위)
각 단편들의 전체 아이피 데이터그램에서 각 단편들의 시작 위치 상대적인 위치 값을 기록을한다
16비트로 표현되고있는 토탈렝스의 바이트 자리값을 13비트로 이루어진 필드를 가지고 각 단편들의 시작 위치를 지정해줘야 된다는 뜻

단편화 예
학생이 100명이 있다 번호를 100개를 사용할수있다
학생당 한개의 번호 시리얼번호
자 만약 번호가 10개밖에 없다면
각각의 학생을 구분할수있는것은 없고
100명의 학생을 10개의 그룹으로 나눈다음 구룹별로 번호를 나눌수밖에 없다
결국 이야기하는 얘기는 16비트로 이루어진 토탈렝스의 길이값을 13비트로 상대적인 값을
표현해줘야되기 때문에 3비트가 차이가 나는데 3비트로 표현할수 있는것은 8이라는 값이고
결국은 상대적인 값을 8로 나누어서 표현할수밖에 없다

어떤 하나의 아이피 데이터그램이 있는데 4000바이트
옵셋필드는 3비트가 부족한 상태에서 각 바이트 번호를 표현해야하기 때문에
8로 나누어서 설명할수밖에 없다

첫 번째 단편
값: Offset = 0000/8=0
0~1399번까지 속해있는 하나의 단편을 구성
이때 시작위치 값은 0을 기록 8로 나누어서
0을 8로 나눈 0이다

두 번째 단편
값: Offset = 1300/8 = 175
1400~2799번까지 속해있는 하나의 단편을 구성
1400을 8로나눈 175가 되는것

세 번째 단편
값 Offset = 2800/8 = 350
2800~3999번까지 속해있는 하나의 단편을 구성
2800을 8로나눈 350이 된다는것

최종 목적지에 도착했을 때 각 단편의 상대적인 위치값이 175, 350 이라고 기록되어있을텐데
재조립할때는 175를 8로곱한 최종 목적지 값을 알수있다는 얘기
350역시 곱하기8을해서 2800이라는 값이 시작위치구나 라는것을 알수있다는 얘기


상세한 단편화 예
단편들을 세 개로 나누었는데
첫 번째 단편은 0~1399 총 1400바이트 짜리 데이터
토탈렝스가 1420이 되고
프레그먼트 값은 0 0 1
모어 프레그먼트가 1
이유는 총 4000바이트 중에 첫 번째 단편이니 뒤에있는 단편들이 존재한다는 이야기

두 번째 단편은 1400~2799
토탈렝스는 1420
프레그먼트 값은 0 0 1
옵셋 필드는 175

세 번째 단편은 2800~3999
토탈렝스는 1220
프레그먼트 값은 0 0 0
프레그멘테이션 옵셋값 350

이렇게 세 개로 나누어져서 라우팅이 된다
자 두 번째 단편이 또 나누어졌다고 하자
또 나누어졌다고 하더라고 각각 독립적으로 처리되기 때문에
서로 다른 경로로 목적지까지 이동된다
근데 두 번째 단편이 전송중에 어떤 엠티유 값이 더 작은 링크로
지나가는 일이 발생했다 (가정)
두 번째 단편이 또 나누어진것
1400짜리가 600,800짜리로 나누어진것

두 번째 단편이

첫 번째로 나누어진값
토탈렝스 820
프레그먼트 값 0 0 1
프레그멘테이션 옵셋 : 175

두 번째로 나누어진값
토탈렝스 620
프레그먼트 값 0 0 1
프레그멘테이션 옵셋 : 275

무브 프레그먼트 필드가 1이라고 하는 필드를 1이라고 하는 값을
가지는 단편을 또 단편을 할때는 전부 무브 프레그먼트 값이 1이되는것@

최종적으로는 단편이 3개로 나누어졌는데
두 번째가 2개로 나누어져서 5개가 아니라 4개로 나누어진거다


일단 재조립하려면 재조립할 단편들을 모두가 동일한 id값을 가져야함
완전히 서로다른 복수의 송신자로부터 온 다양한 아이피데이터그램들이 도착한다
이 단편을 재조립하기위해서는 동일한 id값을 별도로 모아야한다
첫 번째 어떤 그룹을 띄워야한다 동일한 아이디 값 실제로는 아이디 값으로만 하지 않지만
송,수신 아이피 값 도 동일하고 id값도 동일한 단편들을 일단 모은다
최종적으로는 4개가 도착하는데 
순서대로 재조립을 해야한다
프레그멘테이션 옵셋값을 000이라는 것을 보고 첫 번째 단편이 되는것
두 번째 단편의 값은 1400을 8로 나눈 값을 보고
175라고 한는 단편이 있는 옵셋값을 가지는 단편을 기다린다는 얘기
세 번째 단편의 값은 175고 1400부터 시작 데이터 길이는 800 토탈렝스가 820
헤더렝스가 5이니 20이다 빼면 800
1400부터 시작하니 800바이트 짜리면 2199까지 해당이 될것
세 번째 단편은 2200이라는 값을 가질것
2200을 8로 나눈다면 275가 될거고 목적지는 옵셋값 275짜리를 기다리고있다가
이것이 세 번쨰 단편이다 라는 값을 알게 될것
----4번째까지 받는다
받으면 기다리지 않는다 모어 프레그먼트가 0다
마지막이라는 사실을 알게되고 재조립해서 상위계층으로 올려보낸다
이렇게해서 재조립이 된다@


검사합
	- TCP/IP 프로토콜에 의해 사용되는 오류 검출 방법
	- 헤더만 대상으로 하고 데이터는 검사하지 않는다.
데이터에 대해서는 오류검출을 하지않고 헤더를 대상으로만 오류 검출을 한다
아이피 헤더의 필드들을 16비트씩 끊어서 책성필드에 값을 결정하게 된다
각 16비트들을 세로의 비트들을 쭉 익스클로시브or연산 1의 계수가 짝수면 0고
1의 개수가 홀수면 1이되는것
모두 익스클로시브or연산을 하여 16비트들이 1이 되도록
책성필드의 값을 결정하게 된다
책성필드의 값을 1로 채워서 전송
목적지에서 받았을때 또 다시 오류 검출을한다 라우터단에서 받을수도있고
목적지에서 받을수도 있으니 최종 결과가 올 1이 나오면 에러가 발생하지 않았다 라고 판단
이렇게 오류검출을 하는방법이 검사방법 이라고 한다

	- IP 패킷의 검사합 예
헤더 책성필드의 값이 올 1이 되도록 해야하므로 이 헤더 책성필드의 값은
그 헤더책성필드를 제외하고 더한 결과의 1의 보수를 취해주면 된다
보수를 취한 값이 헤더책성필드에 들어간다
그래서 헤더책성필드가 이미 들어가 있다고 전제하고
다시 익스클로시브 or연산을 취하면 모든값이 올 1이되는것

목적지에 도착할때마다 네트워크 계층에서 다시한번 검사합을 시행하게 된다
모든 검사결과가 올1이 되도록 검사합을 할때마다 16비트 올1이 나와야
에러가 없었다 라고 판단할수가 있는것
만약 라우터단이나 최종 목적지단에서 검사를했는데 올1이 아닌
다른값이 나왔다면 헤더값에서 오류가 발생했다고 판단할 수 있게되는것


보안 문제점들
	- 패킷 엿보기 -> 패킷 암호화
	- 패킷 수정 -> 데이터 무결성 메커니즘
	- IP위장하기 -> 발신지 인증
IPSec (IP Security)
		- IP와 같이 사용되는 연결지향형 보안 프로토콜
	- 알고리즘과 키의 결정: 양쪽 개체는 보안 알고리즘 및 키에 대해 합의
	- 패킷 암호화: 기밀성 유지 
	- 데이터 무결성: 패킷 변경 유무 확인
	- 발신지 인증 




