컴퓨터 네트워크 7주차 정리

직접 전달 vs 간접 전달
직접 전달 (Direct delivery)
	- 패킷의 최종 목적지가 전달자 와 같은 네트워크에 위치
	- 직접 전달 여부 판별은 어떻게?
	- ARP: 목적지 IP주소 <-> 목적지 MAC주소
m1인터페이스
m2인터페이스

목적지 주소가 목적지주소의 프리픽스가 전달자의 IP주소의 프리픽스가
동일하냐 다르냐 보고 판단 프리픽스가 같으면 네트워크 id가 같다는것
그것은 동일한 네트워크 상에있는 호스트에게 직접 전달 한다는것
다르다면 간접전달이 되는것

C는 목적지 B의 프리픽스는 다르다 그러니 서로 다른 네트워크
그러니 직접전달이 아니라는것
ARP라는것은 IP주소에 해당하는 MAC주소를 찾아주는 프로토콜이다!
MAC주소의 맵핑정보를 관리하는 프로토콜!
목적지의 IP주소에 해당하는 목적지 MAC주소의 맵핑정보를 ARP가 관리

호스트 C입장에서는 네트워크계층에서의 목적지는 B이지만
ARP입장에서 찾아야하는 IP주소는 B가 아니다
로컬에있는 어떤 라우터의 IP주소와 MAC주소가 C라고하는 호스트 입장에서 본
ARP의 타켓 IP주소와 타켓 MAC주소가 되는것


간접 전달 (Indirect delivery)
	- 목적지 호스트가 전달자 와 다른 네트워크에 위치
	- 라우터를 경유
	- ARP: 다음 라우터의 IP주소 <->다음 라우터의 MAC주소
A는 소스
B는 데스티네이션 (목적지)
첫번째 라우터 R1
두번쨰 라우터 R2
m1 - R1 - m2
m3 - R2 - m4
소스 A가 데스티네이션 B로 패킷을 전달하기위해서는 라우터 R1을 통해서
전달하게 되는데 이게 간접 전달
R1입장에서는 B에게 직접전달이 되지않으니
R1은 R2에게 다시 전달 이것도 간접 전달
R2는 B에게 m4라는 인터페이스를 통해서 직접전달이 되겠지요
ARP입장에서
A가 네트워크 계층에서 목적지는 B이지만
ARP프로토콜에서 타겟팅하고있는 IP주소는 R1의 m1의 설정되어있는 IP주소가 될것
ARP에서 찾아야하는 MAC주소는 R1의 m1 인터페이스의 MAC주소가 될것이다
R1이 R2로 보내는데 R1에서 ARP프로토콜이 동작한다면
R2의 m3인터페이스에 설정된 IP주소가될것
타겟팅해야하는 ARP의 MAC주소는 R2의 m3에 설정된 MAC주소가 될것
R2에서 APR를 타겟팅하고있는 주소가 동일한것 네트워크계층에서의 타겟팅 주소가


목적지 주소 (Destinatuin address) 기반 포워딩
가장 일방정이고 전통적방식의 기반 포워딩
	- IP가 비연결형 프로토콜로 사용되는 경우 (전통적 방법)
이 형식으로 사용
	- 목적지 주소 -> 라우팅 테이블 검색
목적지주소를 추출한 이후에 목적지 주소에 해당하는 최적경로를 라우팅테이블에서
검색함으로서 최적경로를 찾는것을 말하는것
	- 포워딩 기술
		- 다음 홉 방법 (Next-hop method)
		- 네트워크 지정 방법 (Network-specific method)
		- 호스트 지정 방법 (Host-specific method)
		- 디폴트 방법 (Default method)
목적지 주소 기반포워딩은 목적지 주소를 기반으로 매칭되는 라우팅 테이블을 하나하나
검색하며 찾지만

레이블 (Lable) 기반 포워딩
	- IP가 연결형 프로토콜로 사용되는 경우
	- 레이블 -> 스위칭 테이블에 접근 (Accessing)
	- MPLS
레이블 기반 포워딩은 목적지 주소기반으로 하는것이 아니라
데이터의 패킷의 흐름 특정 소스로부터 목적지까지 일정한 경로대로
전달되는 패킷들의 흐름을 플로우(Flow)라고 하는데 그 플로우에 해당하는 인덱스(값)
이있는데 그걸 레이블이라고 부름
그 레이블이 라우팅테이블(스위칭테이블)에 접근 하나의 인터페이스로받은 패킷을
다른 인터페이스로 스위칭하는것

라우팅테이블(스위칭테이블)의 특정 엔트리를 바로 엑세스 해서 해당되는
인터페이스로 패킷을 포워딩하는것
목적지 주소 기반 포워딩보다 레이블 기반 포워딩 기반 포워딩이 패킷 포워딩을
훨씬 더 빨리 결정할수있다는 장점이 있다.
레이블기반 포워딩 개념을 실제로 구현한 프로토콜중에 대표적인 표준 프로토콜인
MPLS라는것이 있다

다음 홉 (Next-hop) 방법
	- 라우팅 테이블의 크기를 작게 만드는 기술 중 하나
	- 전체 경로 정보 대신 다음 홉 주소만 저장
호스트 A입장에서는 R1의 왼쪽 인터페이스의 설정된 IP주소 그게 바로
호스트 A입장에서의 Next Hop IP주소가 되는것
이 정보만 있어도 넥스트홉까지 패킷을 보낼수있음
그 다음 넥스트홉은 R2의 왼쪽 인터페이스
R2가 받고 다음 B로가는데 B에는 넥스트홉 IP주소가 없음

그래서 호스트마다 목적지까지의 전체경로를 저장하는것보다 넥스트홉의 IP주소를 저장함으로서
패킷전달은 가능하지만 저장해야할 정보량은 줄일수있는 장점이 있다.


네트워크 지정 방법 (Network-specific method)
	- 라우팅 테이블 크기 작게, 검색 과정 간단하게
	- 같은 네트워크에 연결된 모든 호스트 별 엔트리 대신 네트워크 주소지정
총 엔트리수가 4개인데 데스티네이션 주소를 기록
A,B,C,D나 어떤 목적지로 보내든간에 넥스트홉 IP주소는 R1의 왼쪽 인터페이스의 IP주소가 되는것
ABCD가 같은 네트워크에 속해있으니 네트워크 단위로 라우팅테이블엔트리를 관리한다면
4개에서 1개로 줄어드는것
단순히 저장해야하는 정보량이 줄어드는것 이상의 의미가 있다
목적지 주소기반 포워딩은 패킷을 수신했을때 목적지 주소의 일치되는 어떤 엔트리를 찾기 위해서
라우팅테이블에서 계속 검색하는데 라우팅테이블의 엔트리수가 많으면 많을수록 검색시간이 오래걸림
엔트리수를 줄여놓으면 패킷포워딩을 위해서 찾는 시간이 줄어들음
결과적으로 시간이 줄어들으면 네트워크 송신 속도를 올릴수있는 이득, 효과를 기대할수있다


호스트 지정 방법 (Host-specific method)
잘 사용하지 않음
	- 라우팅 테이블에 목적지 호스트의 주소 저장
		- 네트워크 지정 방법과 반대: 라우팅 테이블 사이즈 증가@
	- 관리자가 라우팅 테이블을 제어하고자 할 때 사용
	- 경로 점검이나 보안성 제공을 위해 사용하기도 함
일반적으로는 호스트 지정방법을 잘 사용하지않음


디폴트 방법 (Default method)
	- 라우팅 테이블을 간단하게
	- 인터넷상의 모든 네트워크 나열대신 디폴트 엔트리만 지정
라우터가 인식하고있는 어떤 네트워크들에 대해서는 테이블에 기록하지만
그 외의 모든 경로에서는 하나의 엔트리로 대체할수있는 방법을 디폴트경로지정
혹은 디폴트라우팅이라고 하는것
N1, N2만 엔트리로 별도관리 그 외의 모든 경로는 디폴트루트로 설정해서
패킷을 보낼수있도록 관리할수있다는것






클래스 기반 주소체계에서의 포워딩
	- 서브넷팅이 없는 경우
	- 서브넷팅이 있는 경우

클래스 없는 주소체계에서의 포워딩 (이걸사용함)

클래스 없는 주소 체계에서 단순화된 포워딩 모듈
IP계층의 포워딩 모듈에서는 패킷을 수신했을떄 패킷의 IP헤더중에 목적지 주소
필드를 먼저 추출해낸다
목적지 주소의 정보를 가지고 포워딩 테이블 라우팅 테이블에서 매치가 되는 최적경로를 찾는 과정이 됨
그렇게해서 찾는과정이 목적지주소 기반 포워딩이라는것
테이블을 검색하라고했는데 그것이 라우팅테이블 혹은 포워딩 테이블이라고 부른다
이것에는 4개의 주요항목 혹은 마스크는 서브넷 마스크를 얘기하는것
그 다음 네트워크 주소, 넥스트홉 어드레스, 로컬 인터페이스
이렇게 4개의 열을 가지게 된다
매 엔트리마다 매치가 되는지는 매칭되는 엔트리를 찾을때까지 서칭을 한다
특정 엔트리에 매치가 된다면 넥스트홉주소로 패킷을 포워딩하게된다는 뜻이다

예제 6.7 : 라우터 R1의 라우팅 테이블을 보여라
R1에 연결되어있는 네트워크는 총 4개
아래쪽에도 연결되어있는 라우터를 R2라고 하자
R1의 연결되어있는 네트워크는 4개
R2에 연결되어있는 네트워크에는 5개로 보임
마스크, 네트워크 주소, 넥스트홉, 로컬 인터페이스
4개가 필요
라우팅 테이블을 검색할때 가장 긴 마스크 부합이라고해서 
원래는 롱기스트 마스크 매칭(Longest Mask Match)이라고 하는 규칙이 있다
네트워크 엔트리의 순서를 정할때 마스크의 프리픽스 길이가 가장 긴 것 부터
매칭을 시도하라는것
라우팅 테이블에서도 프리픽스 길이가 가장 긴 것부터 엔트리에 기록하도록 하자
/26  10진법으로 표기한다면 8 8 8 2 니까 255.255.255.192/26
마스크 자리에는 /26이나 255.255.255.192 라고 적어도 상관없다
네트워크 주소에는 180.70.65.192 이다
넥스트홉의 주소는 R1에서 180~ 의 패킷을 보낼떄 지나가야하는 라우터가 있냐 라고 물어보는것
하지만 없다 직접연결되어 있기 때문에
넥스트홉 라우터의 주소는 없음
나가야하는 인터페이스의 주소는
Exit 로컬 인터페이스 는 m2이다

mask		Net		Next-hop		Int	@@@@@
/26	  180.70.65.192	----------		m2
/25	  180.70.65.128	----------		m0
/24	  201.4.22.0	----------		m3
/22	  201.4.16.2	----------		m1
/0	  0.0.0.0    	    180.70.65.200		m2		디폴트 라우팅일경우

이것 4개의 엔트리 네트워크 말고 외에는 전부다
디폴트 라우팅으로 보내버림

예제 6.8 : 목적지 주소가 180.70.65.140 인 패킷의 포워딩
주소를 /26짜리 주소와 마스킹을 한다 180.70.65.140인 목적지 IP주소가 있고여
이거를 처음에 가장 큰 서브넷 마스크 뭐와 한다그랬져 255.255.255.192 아닙니까
이 두 개를 비트 엔드연산을 취한다면 180.80.65.128가 나온다
IP주소와 서브넷 마스크하고 마스킹을하면 무슨 주소가 나오냐
서브 네트워크 주소가 나온다
하여간 주소가 매치가 되지않음 그러니 동일하게 매치가 되는 주소를 찾아야함
/25랑 마스킹을 해야함 140이니 128부터시작되는것 안에 포함이되니 매칭이 됨
m0인터페이스로 포워딩을 하게 됨
/25짜리 엔트리에 매칭이 되었은
답: m0 인터페이스를 통해서 포워딩한다

예제 6.8 : 목적지 주소가 201.4.22.35 인 패킷의 포워딩
가장 긴것부터 매칭여부를 조사해감
/26랑 매칭을 한다면 201.4.22.35 는 0~ 에 속한 패킷의 목적지 주소
매칭이 되지않음
/25랑 매칭을 한다면 128부터 속한 주소이기때문에 두번째도 미스매칭
/24랑 마스킹을 한다면 네트워크 주소는 201.4.22.0 이 되기 때문에	매칭o
답: m3 인터페이스를 통해서 패킷을 포워딩한다

예제 6.8 : 목적지 주소가 18.24.32.78 인 패킷의 포워딩
/26     18.24.32.64가 됨 - 미스매칭
/25랑 마스크 매칭을 하면 18.24.32.0가 됨 - 미스매칭
/24랑 시도 18.24.32.0 - 미스매칭
/22랑 시도 18.24.32.0이 됨  	64등분 됨 0,4,8,12,~~ - 미스매칭
어떤것과도 매칭이 되지않음 나머지 남은것은 디폴트 루트
디폴트 루트는 어떠한 엔트리 외에는 어떠한 목적지 주소가와도 매칭이 되도록 만들어야함
목적지 주소가 무엇이든간에 반드시 매칭이 되도록 할까요
그게 바로 마스크와 네트워크 주소가 모두 0.0.0.0이면 된다는것 프리픽스 길이는 /0
/0    0.0.0.0 이 됨
어떠한 IP주소가 오더라도 0.0.0.0과 마스크 매칭하면
0.0.0.0이 됨 그러니 반드시 매칭이 이루어지게 됨
디폴트 루트인 경우에는 /0    0.0.0.0 이라고 기록해야함
답: m2라는 인터페이스를 통해서 넥스트홉 라우터의 주소인 180.70.65.200 이라는 주소로 패킷을 포워딩하게 됨

@라우팅테이블 구성하는것 그리고 정보에따라 패킷을 수신했을때 목적지 주소에 맞는 최적경로를 목적지 주소 기반의 포워딩을 결정할 수 있어야함

예제 6.11: 라우팅 테이블을 보고, 토폴로지 그리기@@@
엔트리 6개
직접 연결되어있는 주소를 먼저 그리는게 좋음 넥스트롭 주소가 없는 것
				
								  m1  - R(190.17.6.2) - (130.4.8.0/24)
								   l
(140.6.12.64/24)	-	R(180.14.2.5)    -	 m2	- R1 - m0     -     R(110.70.40.6)  - 임이의 인터넷
이것 역시도 점서적으로 표현하는것이 좋음




라우팅 테이블 사이즈
	- 클래스 기반 주소체계 vs @클래스가 없는 주소체계@
라우팅 테이블 사이즈를 줄이면 전체적인 네트워크 성능을 향상시킬수있다


클래스가 없는 주소체계에서 라우팅 테이블 사이즈를 줄이기 위한 방법
	- 주소 집단화 (Address Aggregation) / 대표적 방법@
5장에서 슈퍼네팅(Route Aggregation, Route Summanization)
루트 에그리게이션, 루트 서머라이제이션 이라고도 부름
	- 가장 긴 마스크 부합 (Longest Mask Matching)
이것 자체가 라우팅 테이블의 사이즈, 엔트리수를 줄인다기보다
주소 집단화가 일어나더라도 제대로된 경로를 찾아갈수있는 규칙 방법이라고 생각해도 되겠다
라우팅 실패를 막을수있는지
	- 계층적 라우팅 (Hierarchical Routing)
	- 지리적 라우팅 (Geographical Routing)

라우팅 테이블 탐색 알고리즘@

주소 집단화 (Address aggregation)
R1의 경우에는 m4인터페이스로 패킷을 수신했을경우
패킷의 목적지 주소에 따라 첫 번째 네트워크 부터 네 번째까지
해당되는 네트워크로 패킷을 전달해야하기 때문에
4개의 네트워크를 엔트리로 가져야함
어떤 네트워크로 가는 패킷이더라도 R1으로 보내야함 결국 동일한 경로로 보내는것
R2는 R1 처럼 엔트리를 각각 가지고 있을 필요가 없다
집단화하여 에그리게이션하여 요약하면 좋겠다는 것
그게 슈퍼네팅이다
140.24.7.0/26
64
128
128
192
이 네 개를 합친 슈퍼 네트워크 주소는 뭐가되냐
일단 프리픽스 길이가 /26이 아니라 /24로 줄게 된다
140.24.7.0/24
0은 네 개를 합쳤으니 4의 배수가 된다
그러니 140.24.7.0/24가 된다
합치니 그만큼 패킷 포워딩이 빨라진다는 개념이 됨


가장 긴 마스크 부합 (Longest Mask Matching)
	- 가장 긴 Mask를 가지는 엔트리부터 정렬
경로요약 -> Discontiguous
오히려 라우팅실패로 이어질수있다
그러니 가장 긴 마스크 부합 을 함으로서 라우팅 실패의 위험을
해결, 방지 할수있다

R2는 3개의 엔트리에 대해서 경로 요약을 한거다
3개를 경로요약을하면 최소 4개를해야함
140.24.7.0/24 로 경로요약
하지만 140.24.7.192도 포함된 경로 요약이다
만약 R2가 m2인터페이스를 통해 패킷을 받았다고 해보자
140.24.7.200 이라는 목적지 주소를 가진 패킷을 수신
이 주소는 어디에 있나
R3밑에있는 4번째 네트워크에 속해있다
라우터가 매칭을 시도할때 만약 24짜리와 먼저 매칭을 시도하게 된다면 어떻게 될까
140.24.7.200/24
결과는 140.24.7.0 이 된다 결국 매칭이 됨
m0를 통해 m3로 내보내는 라우팅실패가 발생함
경로요약을 하니 이런일이 발생함
이럴떄는 뭐를 해결해야 하느냐
프리픽스 길이가 긴 /26짜리와 먼저 매칭을 시도하라는것
결국 /26이랑 먼저 매칭을 시도하면 140.24.7.192/26
m1인터페이스로 패킷을 포워딩할수있다
그래서 이러한 문제점 때문에 프리픽스 길이가 가장 긴 마스크부터 매칭을 시도해야한다@


계층적 라우팅 (Hierarchical Routing)
120.14.64.0/30 --- 120.14.64.0/23 --- 120.14.64.0/20
이런식으로 합쳐놓은 로컬 IPS1가 있고 2개 3개가있고 사용하지 않는것도 있음
이 네 개를 합치면 /18이 될것
가장 작은단위부터 큰단위로 묶는 과정이
루트 서머라이제이션 혹은 슈퍼네팅이 될것
반대로 늘어나는것은 서브네팅이 되는것

지리적 라우팅 (Geographical Routing)
	- 대륙별로 큰 블록 할당   *계층적 라우팅 개념의 확장


레이블 (Lable) 기반 포워딩
	- Routing을 Switching으로 대치하여 IP를 연결 지향 프로토콜처럼 동작
	- 레이블 (Lable): 스위칭 테이블의 인덱스(index)@
	- 패킷 헤더에 Lable 부착 -> 스위칭 테이블에 @바로 접근@
		- 탐색 과정이 필요 없으므로 신속한 포워딩 가능@
	- MPLS (Multi-Protocol Lable Switching)
목적지는 서치하는 개념이라면
레이블은 플로우 레이블을 가지고 바로 엑세스(접근)한다 라는 점에서 훨씬 더 포워딩경로를 결정하는게 빨라짐
그리고 전체적 네트워크 성능이 향상됨
이러한 IP에서 레이블기반 포워딩 개념을 도입한 프로토콜이 MPLS라는 것


MPLS (Multi-Protocol Lable Switching)
	- 1980년대 교환기술을 구현한 MPLS 라우터 개발 -> IETF 표준
	- 라우터로 동작할 때는 목적지 주소 기반, 스위치로 동작할 때는
	  Lable 기반으로 포워딩
	- MPLS 헤더 추가 : IPv4 패킷을 MPLS 패킷으로 캡슐화

MPLS (Multi-Protocol Lable Switching)
	- MPLS헤더: 레이블 스택 (Lable stack)으로 구성
		- 레이블: 20비트, 라우팅 테이블 인덱스에 사용
		- Exp: 3비트, 실험 목적 예약
		- S: 1비트, 서브 헤더의 상황 정의 (1: 마지막 서브 헤더)
		- TTL: 8비트, IP의 TTL과 유사 
	- 계층적 교환 (Hierarchical switching)
		- Ex) 상위 레이블은 조직 외부 교환기를 통하여, 하위 레이블은 조직 내부
			교환기를 통하여 패킷 포워딩
구성요소
	- 입력포트: L1 및 L2 기능 수행, Decapsulation (프레임 -> 패킷)
	- 출력포트: 입력포트 반대, L1 & L2, Encapsulation (패킷 -> 프레임)
	- 라우팅 처리기: L3 기능, 목적지 주소를 이용하여 Next hop 주소 및 출력포트 번호 결정
	- 교환 조직: 패킷을 입력 큐에서 출력 큐로 이동시킴




