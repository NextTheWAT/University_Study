컴퓨터 네트워크 기말고사 정리 1~5장

1장


프로토콜((protocol) : 통신을 원활하게 하기 위해 맺은 통신 규약&약속

프토콜의 3요소
 - 구문(Syntax) : 데이터의 구조와 형식, 사용하는 코딩의 종류 ex) 컴퓨터에서 데이터를 표현할때도
                     아스키코드나 여러가지 종류의 코드를 사용
 - 의미(Semantics) : 구문에서 데이터의 형식을 여러가지 필드로 나눈다, 각 필드의
 	비트 패턴이 어떤 의미를 가지는지 약속하고 정해놔야함
 - 타이밍(Timing) : 데이터를 전송할때 전송 속도, 동기


표준 (Standard)
 - 사실 표준: 많은 업체들이 윈도우 표준에 맞게 만들기때문에 시장에서는 표준으로 받아들임
 - 법률 표준: 공식표준으로도 얘기함 ex) kx표준이라는것이 있음 법으로 정해놓은 표준
	     IOT같은 국제연합에서의 표준으로 제정한 표준 공식적 법률 표준



2장


2.1&2.2 OSI 모델
 = OSI 모델 (통신 참조모델)
 - 통신이나 네트워크가있어서 아주기본적인개념 반드시 이해할것
 - 총 7개 계층으로 통신기능을 나눔
 = Physical 1계층
 - 구조화 되지않은것을 비트스트림을 물리 매체를 통하여 전송하기 위한 기계적, 기능적, 전기적,절차적 스팩을 정리하는 계층이다
    비트스트림 비트를 잘 전송하는게 목적인 계층
 = Data Link 2계층
 - 2계층부터 데이타를 구조화시킴 데이터를 프레임이라 부름 그래서 프레팀 단위로 데이터를 보냄
   2계층부터는 비트가 아닌 프레임 단위로 인접한 노드간에 신뢰성있게 전송제어를 담당하는 계층
 = Network 3계층
 - 3계층에서 책임지는 데이터 전송단위를 패킷이라고 부름 송신자의 의해서 목적지까지 넷트웤을통해서 
    데이터를 보낼수 있도록 가작 최적의 경로를 찾는 기능이 네트워크 계층이다 --경로 제어--라고 할수있음 (라우팅)
 = Trandport 4계층
 - 4계층은 통신을 하는 양쪽 끝 단 (종단간) 신뢰성있는 데이터 전송을 담당하는 계층
   2계층도 신뢰성을 제공하기위해 전송제어를 담당하는데 동일하게 4계층에서도 담당
   똑같은 전송제어를 담당하지만 두 계층의 차이는 2계층은 링크단위, 홉 단위로 전송제어를 하지만
   4계층에서는 양쪽 끝 단간에서 전체적인 전송제어를 함 상위에서 구별하기 위해 포트번호같은걸 사용하게됨
 = Session 5계층
 - 5계층은 응용간에 앱 간에 대화 세션을 구성하고 통신방식을 결정하는 세션이다 결정하는 세션 계층
   통신방식은 크게 단방향 통신과 양방향 통신 이 있다 양방향은 한 순간의 송신이나 수신 중 하나를 할 수 있는 
   반이중 통신,동시에 송신과 수신을 할 수 있는 전이중 통신이 있다 어떠한 통신방식을 사용해서 커뮤니케이션을
   할것인지 결정하는 것이 5계층
 = Presentation 6계층
 - 응용간에 대화를 할때 데이터를 어떻게 표현할 것이냐 주로 데이터 표현에관련된 기능을 담당하는 계층이 6계층
   표현계층이라고도 불림 데이터를 표현하기 위한 코딩방식, 압축방식, 암호화방식 이 모두 표현계층
 = Applicayion 7계층
 - 응용계층 이라고도 불림 사용자로 하여금 OSI에 접속해서 이러한 통신 기능들을 사용할수 있도록
   사용자에게 응용 인터페이스를 제공하는 계층


n+1 계층 : 데이터가 하위에있는 계층으로 내려오게되는데 자기의 기능을 부여해주기위해 상위 계층으로 부터 받은 데이터에
	  헤더를 추가하게 됨 그래서 n 계층의 어떤 기능들은 자기가 붙여놓은 헤더에 필드로서 정의되어서 들어감
n    계층 : n-1 계층으로 또 내려감
n-1 계층 : 자기 고유의 기능을 헤더로 정의해서 내려받은 데이터에 붙이게 됨 상위 계층에서 하위계층으로
	 내려오는것을 인캡슐레이션 캡슐화 라고 한다

	 n+1 계층의 데이터가 n 계층으로 내려오면 이것은 n 계층의 서비스 데이터 단위
	 즉 SDU가 됨 N-SDU 즉 n계층의서의 PCI 라고 불림
	 n계층 관점에서보면 n계층의 sdu와 pci가 합쳐진 전체 데이터를 n계층의 PDU라고 불림
	 그래서 N-PDU = N-SDU + N-PCI
	 n계층의 PDU는 N-1 계층의 SDU와 동일하다 ★★★

	링크를 타고 간 데이터는
	헤더를 제거하는 과정을 디캡슐레이션이라고 불림 (다시 올라가는 과정)
	EX) 카카오톡에서 보낸 데이터 안녕이라는것을 송수신주소,포트,응용제어 등등
	중간 통신과정에서 헤더를 붙이고 떼어내는과정을 사용자들은 인지하지 못함
	실제 시스템과 네트워크 통신 과정에서는 인캡슐레이션, 디캡슐레이션이 일어나고있다
	
	계층과 계층사이의 전달 인터페이스 이것을 뭐라고 부르냐면 서비스 엑세스포인트 SAP라고 불림 

계층마다 불리는 데이터 단위 TCP/IP
1계층 - 비트 (1계층에서도 비트로 하되 비트스트림을 이용한다)
2계층 - 프레임 (2계층에서는 프레임으로 하되 노드를 이용한다)
3계층 - 패킷
4계층 - 세그먼트
5계층 - 메세지


1계층에서는 데이터를 구조화하지않음
2계층 - MAC 주소
3계층 - IP 주소


TCP/IP에서 사용하는 주소

MAC address : 물리주소(Physical address), L2 주소
 - 링크 상에서 NIC 구별
 - 48bits = OUI cod(24bits) + Serial(24bits)

IP address : 논리주소(Logical address), L3 주소
 - 인터넷상에서 호스트를 구별
 - IPv4 address (32bits) = Network ID (Prefix) + Host ID (Suffix)
   IPv6 address (128bits) (아직까지는 쓰지않음)

Port number : L4 주소
 - Transport 계층에서 상위 응용 Process를 구별
 - 16bits 
 - Well-known Port number : 1023번 이하 포트번호
	인터넷 표준기구에서 웰노운 포트번호 - 공식적으로 포트번호를 고정적으로 할당해둠
 	- Ex. FTP(20,21), SSH(22), Telnet(23), SMTP(25), POP3(110), HTTP(80), HTTPS(443)   12분23초
만약 동일한 IP를 사용한다면 물리적으로 불가능함 IP주소 충돌이 일어난다는 메세지를 받음
MAC 주소는 링크상에서 NIC를 구분하기위한 주소이기 때문에 동일한 주소를 사용할 수 없음 논리적으로는 동일한 MAC
주소를 가지고있을수없음 하지만 있을수도 있다
NIC는 물리주소이고 값이 바뀌지않는다



3장

네트워크의 종류, 단계 
WAN(Wide Area Network) 한 나라를 커버 가능
MAN(Metropolition Area Network) 한 도시정도 커버 가능
LAN(Local Area Network)
PAN(Personal Area Network) EX) 블루투스, 옆 사람에게 데이터 전송이나 네트워크 등등


IEEE 표준 (I 트리플 E)
이더넷이 IEEE 로 넘어오면서 LLC와 MAC 계층으로 나뉘어졌다는것 알아둬야함


3.1 유선 LAN(계속)
 - 이더넷 프레임 형식
	- 7개의 필드로 구성
		preamble(7bites) - SFD(1bites) - Destination address(6bites) - 
		Source address(6bites) - Length or type(2bites) - Data and padding(46~1500bites) - CRC(4bites)
	- 확인응답을 제공하지 않으므로 신뢰성 없음
		- 확인응답은 상위계층에서 제공해야 함

Preamble : 56bits of alternating Is and 0s.   7바이트
SFD : Start frame delimiter, flag(10101011)   1바이트
	preamble 을 7바이트를 하고 SFD를 마지막에 11을 넣음
	그래야 Destination 주소를 가기전 마지막 끝 자락을 알수있음

데이터의 길이가 가변적이니 Length 필드로 바뀜 하지만 기존 방식 타입 필드로 사용
IEEE가 정한건 Length 필드이지만 아직도 기존 Type 방식이 많이 사용되어
Length or Type 로 해석을 함 두 필드를 해석해야 하는데
Length/Type 값이 0x0600 이상이면 DIX2.0Type 으로 인식하고,              16진수
	           0x0600 미만이면 IEEE 802.3 Length 필드로 인식
값에따라 타입이 바뀜 그게 가장최근 이더넷 방식이다

Data and padding 
1500바이트를 MTU 라고 부름 - 최대 데이터 단위
46바이트가 최소 데이터 단위
46바이트를 맞춰야함 만약 41바이트라고하면 뒤에 000을 계속 붙여서
데이터를 추가함 그것을 Padding 이라고 한다

CRC (FCS (Frame Check Sequence) 라고도 부름) : 프레임 데이터에 에러를 체크하고, 검출하고, 정정하기위한 부가적 정보이다. @@@


3.1 유선 LAN (계속)
 - 프레임의 최소 및 최대 길이 제한
	- 최소길이 제한 이유?
충돌이 일어나도 계속 데이터를 보내고 있어야함
왜냐하면 충돌이 일어나도 다시 되돌아와서 재전송을 해야 하기때문
충돌했는데 이미 전송완료라고 한다면 다시 되돌아가서 재전송을 할 수 없기 때문. - 중요 
1. 충돌을 검출할만한 최소 길이를 보장해야하기 때문이다.
	- 최대길이 제한 이유?
		- MTU(Maximum Transmission Unit)
이더넷의 토폴로지 구조부터 생각해야한다 
예를들어 A가 1기가 영화를 다운로드 받는다고 해보자 이더넷 링크를 하나의 프레임으로 다 사용을 한다면
다른 노드들은 그 통로를 사용할수가 없다. 특정 노드에 채널독점을 막기 위함이다!
최대 데이터 양을 정해두지 않으면 램 카드가 저장해 둘수있는 버퍼공간이 정해져있기 때문에 용량의 한계 
1. 채널 독점 방지
2. Buffer - 용량한계 때문 


Unicast - 1대1 통신개념
Broadcast - 1대 다수
Multicast - 특정그룹에만


매체접근제어(MAC) : CSMA/CD
 - Carrier Sense Multiple Access / Collison Detection

 - Carrier Sense - A가 만약 프레임을 전송하는중에 B나 C가 데이터를 보낼수없음
		그래서 데이터를 전송하기전 캐리어를 센싱해야함
 - Multiple Access - 캐리어가 없다면 누구든 액세스가 가능 충돌 발생 가능성이 낮다 하지만
		  전파지연이 있기때문에 충돌이 일어날수밖에 없음
		   왜냐 A가 보내는 프레임이 D와 E까지 가지않아서 A쪽에서 보내는 데이터가
		  없는줄 안다 그래서 E가 데이터를 보내게되면 결국 A가보낸 데이터 E가보낸 데이터
		  가 어느지점에서 무조건 충돌을 하게 된다	
 - Collison Detection - A와E가 둘다 전송할때까지 충돌이 일어났음에도 불구하고 끝까지 계속 보냄	
		    그래서 전체적인 데이터기능이 떨어짐 
		    jamming 시그널 을 추가한다 충돌됐다는 신호를 강조해주는 것
	   	    불필요한 전송하는 시간을 아낌으로서 전체적인 신호를 향상시키자 가
		    CSMA/CD 이다

 - 전송지연 (transmission)     
	 - 일반적으로 속도가 빠르다고 느끼는것은 전송지연에서 느껴짐
	 - 데이터를 실어 올린다
	 - 아래로 쭉 내려가는게 데이터를 실어 올리면서 내려가는것(그래프상)
 - 전파지연 (propagation)
	 - 전파지연은 물리적으로 결정이 된다
	 - 케이블을 타고 이동하는속도?
	 - 옆으로 퍼지는게 전파지연


CSMA - 충돌된것을 검출할수있는 기능이 없어서 충돌이 되어도 계속 프레임 데이터를 보냄
	충돌되는 데이터의 양이 많음
CSMA/CD - 충돌되는 시그널이 검출되면 중복되는 구간이 CSMA보다 적다는것
	    충돌되는 데이터량이 적음 불필요한 데이터전송량이 적음
 - CSMA/CD : 통신방식 > 반이중이다
	      어떤 노드가 전송중일때 다른 노드가 전송해서 충돌해서 일어나는 상황을
	      제어하고 문제를 최소화하기위해 필요한것
 - 반이중 통신일때 CSMA/CD가 필요한것
 - 전이중 통신일때는 CSMA/CD가 필요하지 않다.

fr 딜레이의 전파하는 시간보다 t 시간의 2배이상이여야 그래야 충돌을 검출할수있다
끝까지 전파되는 프레임을 아직 전송하고 있어야 충돌을 검출하더라도 재전송할수있는 것

@ Jamming signal
	- 전송 중 충돌이 감지되면 데이터 전송을 멈추고
	  32bits의 길이의 01 반복 신호를 전송

 - 10Base-T
	- 허브에 UTP케이블을 연결해서 사용 100미터를 넘어가면 안됨
	  8개의 구리선, 줄무늬와 줄무늬가 없는 쌍으로 이루어져있음
	  트위스트 되어있다.


- MAC : CSMA/CA vs 유선랜에서는 CSMA/CD
 - Carrier sense Multiple Access with
	Collision Avoidance (충돌회피)
무선 상황에서는 유선상황에서보다 충돌을 검출하는것이 힘들다
망 제어 하는것 자체가 말이 안됨
처음부터 아예 충돌을 일어나지않도록, 회피하자 해서 만들어진게 CSMA/CA
충돌검출이 불가능한 이유는 송신자에게 다시 되돌아와서 충돌의 사실을 인지하는것 자체가 불가능

RTS - 보낼수있도록 허락해달라고 요청하는것이 RTS 수신자한테 확인을 받는것
CTS - 보내도 좋다고 응답하는것
충돌을 회피하기 위한 방법이다 이 두가지 방법이
1. RTS와 CTS를 교환하는것 채널의 상황이 유선보다 무선이 좋지않음 CSMA/CA 에서는 받는쪽에서 
2. 데이터를 다 받았다고 확인 응답 프레임을 보내게 되어있다 그것을 Ack 프레임이라 한다
CTS나 ACK 프레임이 오지않으면 문제가 발생한것으로 생각하여 다시 재전송을 해야함


CSMA/CA와 NAV
 - NAV (Network Allocation Vertor)
A가 B한테 RTS를 보낼때 자기의 데이터량이 얼마인지 알테니까
나는 너에게 앞으로 T라는 시간동안 전송할거야 라고 포함해서 보낸다
B는 그러면 그것을 OK를 함
T시간동안 불필요한 컴퓨팅 파워소모를 줄일수있다
T라는 시간동안 sensing 자체를 하지않음 다른 c와 d는


 - 연결장치와 OSI 모델 @@@
	- Repeater 
1계층 피지컬레이어에서 사용하는
	- Bridge (L2 Switch)
2계층까지 사용하는 1계층에서도 사용
	- Router (L3 Switch)
3계층까지 사용하는 네트워크 계층에 핵심되는 1,2계층 기능을 다 가지고있음
1,2계층에서도 동작함
	- Gateway
프로토콜 변환 기능까지 가지고있음 서로다른 프로토콜 스택간에 데이터를 교환하는 장비
7계층까지도 사용

 - 리피터(Repeater)(반복하다 는 뜻) cf.Hub
	- OSI 모델의 물리계층 기능을 수행하는 장치
	- 신호의 증폭 재생
계속 반복하다보니 신호가 약해진다 그래서 다시 증폭해서 재생한다 는 뜻
	- 필터링 기능X
필터링이라는 기능은 2계층 이상에서 사용되는 개념이다

 - 브리지(Bridge) / L2 스위치(Switch)  23분 14p
 	- OSI 모델의 물리계층과 데이터 링크 계층의 기능 수행
	- 필터링(Filtering), 포워딩(Forwarding), 학습(Learning) @@@
학습(Learning) : MAC 주소를 학습한다 그것을 맥 주소 테이블(MAC Address table)에 저장한다
브리지가 프레임을 수신할때 어떤 포트에 어떤 맥 주소가 있는지 모른다
학습이 되어있지 않아서
그래서 모든 포트로 다 보내버린다 프레임을 보내는것을 포팅이라고 한다
그래서 모든 포트로 다 보내는것을 Flooding 플로딩 이라고 한다
A의 맥 주소는 1번 포트에 연결되어있는것을 알게된다
1번의 송신자가 DA데이터에 학습이 됨

 - 라우터(Router) / L3 스위치(Switch)
	- OSI 모델의 물리, 데이터 링크, 네트워크 층의 기능 수행
라우터가 하는 일이 어떤 네트워크에서 다른 네트워크로 이어주는 역할을 하는것이 라우터
라우터는 서로 다른 네트워크를 이어주는 기능을 하는 것
관점에 따라서는 라우터의 기준에서 다른 네트워크를 나눈다고 얘기할수있음



4장


인터넷

인터넷은 여러개의 LAN+WAN 이다
인터넷은 그 구조를 알지못해도 사용자 데이터를 주고받을 수 있는 블랙박스와도 같다

라우터는 특정링크로 오는 데이터를 또 다른 링크로 교체해주는 그런 기능이 있다
네트워크에서 경로제어를 통해서 최적의 경로를 선택한 이후에 데이터를 스위칭해주는 장비

네트워크 대역폭 : 은 네트워크가 단위 시간 내 전달할 수 있는 최대 크기의 전달 용량


- 회선 교환(Circuit Switching)
	- 메세지 전달 전에 발신지와 목적지 사이에 물리회선(링크)
	  생성 후 메세지 전달
	- 메시지 전달 완료 후 네트워크에 통보 -> 연결해제
	- 대부분 물리계층에서 구현(네트워크 계층에서는 구현 안됨)
	- 회선교환망의 좋은 예: 초기 전화시스템-
전화기가 두 대가 있다고 해보자 그 사이에는 교환기들이 있다 그러면 각 링크마다 사용자 A와 B간의 실제 통화가 일어나기 전에
링크마다 일정 대역폭 대역폭은 타임슬롯 이 일어난다 이 연결을 위해서 물리적으로 할당을 하는 시간
그래서 처음 링크마다 물리적인 타임슬롯을 할당해 송신자와 수신자간의 전체적인 타임슬롯 대역폭을 할당하는데 걸리는 시간이 필요한 것
그래서 설킷 스위칭은 상대적으로 실제 통화하기 전에 접속을 하기위한 시간, 딜레이가 필요해서 상대적으로 접속지원이 크다 라고 설명가능


- 패킷 교환(Packet Switching)
	- 오늘날 인터넷의 네트워크 계층: 패킷 교환  cf. X25
	- 상위층으로부터 받은 메시지 패킷 단위로 분할
	- 발신지에서 목적지까지 패킷 단위로 전달
	- 패킷교환망은 패킷을 최종 목적지까지 전달 결정 -> 재조립
	- 사용방법: 연결형=데이터그램(gatagram), 비연결형=가상회선(virtual circuit)
오늘날의 인터넷을 패킷스위칭이다 라고 이해하면 될듯
두가지가 있는데 일반적으로는 송수신 양단간에 물리적인 회선 연결이 필요한게 아니라 패킷이라는 데이터를 보낸다
그러면 연결 과정없이 패킷이라고 하는 데이터를 보내면 이 중간 교환기 혹은 라우터 단에서 패킷을 축적 즉 저장하고 보내고 저장하고 보내고
이런 방식으로 간다 그래서 상대방의 수신 상태여부와 상관없이 송신자는 바로 데이터를 보낼수가 있게 되는 겁니다
따라서 패킷 스위칭은 서킷 스위칭에비해서 접속지연에 비해서는 상대적으로 적다
그렇지만 일단 한번 접속이 되고 나서는 데이터를 보내는데 걸리는 딜레이 즉, 전송지연이라는 관점에서 보면 서킷스위칭이 상대적으로 적다
왜냐하면 연결과정을 통해서 물리적인 타임슬롯을 확보해놨기 때문이다 그래서 그 다음에 보내는데이터는 큰 전송지연 없이 실시간으로 보낼수있는 장점이있다
그렇지만 패킷스위칭은 보내는 데이터마다 교환기, 라우터단에서 저장했다가 보내고 저장했다가 보내고 매번 타임슬롯을 새롭게 Bandwidth를 확보해서 보내는 과정이 일어나기 때문에
상대적으로 전송지연은 크다라고 얘기할수있다.

		C-S(설킷 스위칭)		P-S(패킷 스위칭)
접속지연		大					小
전송지연		小					大
회선사용효율	小					大
중간 교환기에서 	X(하지않음)		O
물리적, 연결형		 	   		     비연결형
				   			   연결형도 있음


4.3 패킷 교환 (Packet Switching)

- 비연결형(Connectionless) 서비스 = 데이터그램 서비스(방식)라고도 부름
= 목적지 주소 기반의 포워딩
목적지 주소를 가지고 라우팅 테이블로 검색하는 방법
	- @각 패킷을 상호 독립적으로 처리
		- @패킷마다 주소 필요, 독립된 전송 경로
패킷들 마다 목적지까지 도달하는 경로가 다를 수 있다는 얘기
패킷마다 전송되는것이 독립적으로 되기때문에 속도가 다를 수 있음
패킷의 순서가 보장이 되지않음
송신 순서와 수신 순서가 반드시 일치한다라고 할수없다. 하지만 일치 할수도있다
- 라우터(Router)가 교환기 역할
	- 목적지 주소를 기반으로 포워딩(Forwarding)
- 패킷 포워딩
패킷에는 송,수신 주소가 있음 네트워크 계층의 IP주소가 될 것
목적지마다 최적의 경로를 저장해둔 것을 라우팅테이블 이라고 한다
- 지연(Delay)

4.3 패킷 교환(Packet Switching)
- 연결 지향(Connection-oriented) 서비스
	- 연결 설정(Setup) -> 데이터 전송 -> 연결 해제(Teardown)
	- 메시지에 속한 모든 패킷 간에 상호 관계성 가짐
	- 가상회선(Virtual Circuit)@
		- 가상회선 식별자(Virtual circuit identifiier) : 흐름 레이블(Flow label)
	- 라우터 : 각 패킷의 Flow label에 기반하여 포워딩@
특정 송신자에서 특정 목적지까지 동일한 경로를 따라 흐르는 패킷의 흐름, 데이터의 흐름을 플로우라고 부르고,..레이블이라고 부른다 30분
동일한 경로이기 때문에 송신순서와 수신순서가 보장된다(먼저간게 먼저 도착)
라우터에서 패킷 포워딩을 결정할때 목적지 기반으로 사용하는 비연결형과 다르게
연결지향에서는 목적지 주소 기반이아닌 플로우를 정의한 레이블, 플로우 레이블을 기반으로
라우팅 테이블을 검색하는게 아니라 엑세스 한다
동일한 레이블이 있는 레이블을 바로 찾아간다
그래서 포워딩을 빠르게 찾아간다


- 각 라우터(Router)에서 제공되는 서비스
라우터는 링크 계층으로부터 데이터를 받아서 다시 또 다른 링크 계층으로 내보내는 장비
상위계층으로 데이터를 받는 송신자 컴퓨터와 달리
1. 라우터는 다르다 디캡으로 데이터를 받아 올림
네트워크 헤더정보를 보게되면 목적지 주소를 데스티네이션 어드레스에 해당하는
라우터 라우팅테이블을 통해서 주소를 찾는것
2. ip주소에 해당하는 맥 주소를 arp캐시 테이블을 통해 찾아온다
링크마다 mtu값이 다를 수 있음 그래서 해당되는 mtu값을보고 결정, 프레그멘테이션
1. 넥스트옵에 아이피주소를 찾는것
2. 그 아이주소에 해당하는 맵 주소를 ARP 캐시테이블로 찾는 과정
3. 네 스토어까지 전송하기 위한 그 링크에서 MTU값을보고 프레그맨테이션 과정을 하는것


- 목적지 컴퓨터에서 제공되는 서비스
링크 계층으로부터 데이터를 받아서 상위계층으로 올리는것
ip헤더를 디캡
패킷이란 ip헤더를 인캡되어있는 상태가 패킷
데이터 전송과정에서 프레그맨테이션이 여러가지로 나뉘어질수있다
각각의 단편들이 포워딩이 되어서 오니
그것들을 조합해서 상위계층으로 보내야함
그래서 모든 패킷이 도착할때까지 네트워크계층에서 기다려야함
모든 단편들이 도착하면 리어셈블(재조립)과정을 거쳐야함
원래의 하나의 패킷이 됨 그 다음 상위 계층으로 올리는 서비스를 하게 된다
리어셈블을 하기전에 이 정보들을 동일한 패킷에서 단편들이 된 것들을 모아둬야한다
그리고 기록해야함 도착한 단편들을 저장하는 곳이 리어셈블 테이블이라고 한다 


- 오류 제어(Error Control)
	- 훼손, 손실, 중복 데이터 그램 탐지 메커니즘
	- 네트워크 계층에는 오류제어 제공 안함 -> IP패킷 헤더 훼손만 검사

- 흐름 제어(Flow Control)
	- 수신자의 수신 능력을 초과하지 않도록 발신지에서 데이터 전송 양
  	  조절 -> 현, 네트워크 계층은 제공 안함
흐름제어란 송신자가 수신자에 데이터 수신능력을 초과하지않도록 송신량을 조절하는것
그렇지않다면 오버플로우 현상이 발생 데이터전체를 저장하지 못함

- 혼잡 제어(Congestion Control)
	- 혼잡 : 발신지 컴퓨터들이 송신한 데이터그램 수가 라우터 용량초과
	- 우선순위(Priority) cf.ICMP
실제로는 중간에 라우터단이 있는데 수신측에 버퍼가 여유가있어도
라우터에서 오버플로우가 발생한다면 오류가 발생
중간 노드에 버퍼 오버플로우 발생을 막기위해 송신량을 조절하는것



5장


IP 주소
- 네트워크 계층(IP 계층)에서 사용하는 논리주소
- 인터넷에 연결된 각 장치의 (인터페이스) 주소 -> 유일(Unique)
- IPv4 주소 공간 : 32bits ->2^32 or 4,294,967,296
- 표기법(Notation)
	- 2진 (Base2), @점 10진(Bae 256)@, 16진(Base 16) 표기법
점 10진 - 32비트를 8비트식 나눈것 10진수마다 점을찍어서 구분해놓은것


- IPv4 주소 구성
	- IPv4 주소 = Netid + Hostid
Netid = prefix (네트워크 아이디)
Hostid = suffix (호스트 아이디)
호스트한테 할당이 가능한 ip주소가 A,B,C 클래스이다
D클래스는 멀티캐스트 그룹에 할당이되는 그룹 ID로 사용됨
E클래스는 실험용이라던지 특정사용에 대해서 예약되지 않은 그런 용도로 사용하는것이 E클래스


- 네트워크 주소(Network address)
	- 패킷 포워딩(라우팅)은 네트워크 주소 기반
호스트ID를 ALL 0로 바꾼것이 네트워크 주소
1번 인터페이스로 패킷을 받음 - IP회도에는 소스IP주소와 송수신IP주소
목적지IP주소중에 네트워크 주소 기반으로 패킷 포워딩을 결정한다는것
목적지IP주소를 기반으로 라우팅 테이블을 결정한다는것

패킷의 목적지 주소를 조회를함 그 중에 네트워크 주소를 찾아낸다는것
그 네트워크 주소에 해당되는것을 라우팅테이블에서 조회를함

어떤IP주소가 있을때 네트워크 주소를 찾아내는것
네트워크 주소를 찾아내기 위해서 네트워크 마스크OR서브넷마스크 라는걸 사용해서
비트앤드라는것을 사용해서 네트워크 아이디를 찾게된다


- 네트워크 마스크(Network Mask) OR Subnet Mask
	- 목적지 주소의 네트워크 주소를 찾는데 사용
ex) 73.100.10.5 라는 IP주소가 있다고해보자
네트워크 주소는 73.0.0.0이 된다는것을 알고있다
네트워크ID = 73
호스트ID = 100.10.5

어떤 a의 ip주소를 봤을때 네트워크 주소를 만들고싶으면
네트워크 아이디 자리값만 1이고 나머지는 0니까 a클래스의 네트워크주소는
255.0.0.0 이 되는것이다@@@ Network Mask는 255.0.0.0 이 되는것이다!


서브네팅을 해보자
ex) 150.100.0.0/16  B클래스
디폴트 서브넷 마스크 = 255.255.0.0
	2진수는 = 11111111.11111111.00000000.00000000
전체 네트워크를 두 개로 나눠보자
나머지를 구분할수있는 2개의 아이디가 필요
그러면 2진수의 몇자리가 필요할까 그러면 2진수 한 자리가 필요
그래서 서브넷 마스크에서 1로 표현하는것이 네트워크id 0이 호스트id값이다
2개를 구분하기위한 비트는 한 비트가 필요하다
그러면 서브넷 마스크중에 한 비트를 빌려오는것
원래 호스트한테 할당이 되었던 비트를 네트워크id로 바꾸는것
그래서 호스트id 0이 네트워크id 1로 바꿔야함
그러면 11111111.11111111.10000000.00000000/17
이런식으로 바뀐다 그래서 프리픽스 길이도 17로 바뀜
서브넷 마스크를 10진수로 표현하면 255.255.128.0/17
이렇게 바뀐다
호스트id - 2^15-2


서브넷팅 예

C 클래스 서브넷팅
- C 클래스 주소 : netid(3바이트), hosid(1바이트)
- 주소공간(2^8-2 = 254)

예제 3
- C 클래스 주소를 가진 기관이 5개의 서브네트워크를 필요로 한다.
서브넷 마스크와 각 서브네트워크 구성을 찾아보라
- 풀이
   - 5개지만 7개필요(subnetid가 모두 1인것과 0인것 포함)
   - 서브넷 할당을 위한 최소 비트 수 : 3개(2^2<7<2^3)
   - 5개의 비트 hostid(2^5 = 32개), 실제는 30개
200.100.10.0/24 의 디폴트 서브넷 마스크는 
255.255.255.0/24
서브넷 아이디가 all 0,1 인것은 사용 불가능
산술적으로는 7개를 할당해야 두개를빼면 5개가 남으니까 그렇게 할당해야함
최소한 8개는 나눠야함 그러면 3비트를 나눠야하는거고
255.255.255.224가 됨 뒤에 3비트를 111로 바꿔서
필요한 서브넷 마스크는 무엇이냐 10진법으로 표현하라면 255.255.255.224/27가 되는것.
원래 200.100.10.0 의 주소의 범위는
200.100.10.1~200.100.10.255까지 총 256개의 ip주소 조합이 가능한것
200.100.10.0에서 255까지 중 이걸 32개로 나누면 =
1. 200.100.10.0~31		000 00000
2. 200.100.10.32~63	001 00000
3. 200.100.10.64~95	010 00000 - 마지막 주소
4. 200.100.10.96~127	011 00000 - 
5. 200.100.10.128~159	100 00000
6. 200.100.10.160~191	101 00000
7. 200.100.10.192~223	110 00000
8. 200.100.10.224~255	111 00000
까지 나눠짐
총 8개의 서브넷으로 구성이 된다
각 서브넷 호스트 아이디는 5비트가 남고 그 다섯비트가 호스트 아이디가 all 0인
주소를 네트워크 주소라고 한다 왼쪽에 1~8이 서브네트워크 주소가 됨!
31은 마지막 다섯비트가 all 1인경우
63,95 전부다 마지막 열에있는 8개의 주소가 호스트 아이디(5비트)가 all 1 인경우
서브넷 브로드캐스팅 주소다!
all 0 = 서브네트워크 주소
all 1 = 서브넷 브로드캐스팅 주소

서브넷팅을 할때 각 링크상에서 네트워크 속도는 올라간다 256개보다 30개씩 하는게
하지만 라우팅 테이블의 엔트리는 늘어남 엔트리를 찾는 시간이 늘어나는것
그래서 라우팅 테이블의 사이즈가 늘어난다
관리측면에서 용이하다, 링크속도는 높아지지만
단점은 라우팅 테이블 사이즈가 늘어난다
look up하는 시간이 늘어남
그래서 패킷 포워딩을 하는데 지연이 늘어날수있다!


서브넷팅 예제
ex) 200.100.10.0/24 서브네팅 네트워크
세 개의 네트워크로 나누고자 할때 필요한 서브넷마스크를 10진 표기법으로 나타내어라
sol) 세 개의 서브넷이니 몇개로 나눠야할까 최소한 4개로 나누어야함
서브넷 아이디 올0올1 다 사용 가능한 전재로
네 개로 구분하기위해서는 서브넷 아이디가 2비트가 필요 4개의 서브넷으로 나누어야 하니
그러면 프리픽스 26을 사용해야된다는 얘기
26은 8 8 8 2 이니 255.255.255.192
c클래스를 세 개의 서브넷으로 나누고자 할때는 네 개로 나눴을때 네트워크 서브넷 마스크는
255.255.255.192 가 된다
200.100.10.0이 c클래스이니 
200.100.10.0~200.100.10.255 이걸 64개씩 4등분하면
200.100.10.0~ 63
200.100.10.64~ 127
200.100.10.128~ 191
200.100.10.192~ 255
이런식으로 네 등분 할수있다
0,64,192,255 서브넷 주소가 되는것
실제 할당가능한 ip주소는1~63, 65~126,,,,, 등등이 될 것임


ex) 200.100.50.100/26
이 ip주소가 속한 -서브네트워크주소-와 -서브넷 브로드캐스팅 주소-를
10진 표기법으로 나타내어라
서브 네트워크 주소 = 시작 주소
브로드캐스팅 주소 = 마지막주소
결국 시작주소와 마지막주소를 구하라는 문제
sol) 8 8 8 2 
마지막 자리가 2비트만을 네트워크주소로 사용하겠다는것
200.100.50은 고정값
마지막 네 번째 2비트만 네트워크 아이디로 사용하고있다는것
마지막 자리를 네 등분 하겠다는 의미
256개 짜리를 64개씩 돌아가는것
그럼 마지막 자리가 0.64.128.192가 된다는것
앞에값은 똑같음
서브네트워크의 시작주소와 마지막주소니
아마 두 번째 네트워크에 속해있을것
200.100.50.100은 200.100.50.64~200.100.50.127 사이의 주소일것
결국 답은
시작주소 = 200.100.50.64
마지막 주소 = 200.100.50.127


슈퍼네팅 (Supernetting)
서브네팅과 반대되는 개념
서브네팅의 장점도있지만
라우팅 테이블의 엔트리가 늘어나는
룩업하는 찾는 과정에대한 시간이 많이 걸릴수있다


자 예시를 들어보자
R1이라는 라우터단이 있다
서브네팅을 했을수도있고 안했을수도있다
그런데 R1에 또 연결되어있는 라우터가있을수있는데
그걸 R2라고하자 R1입장에서는 어떤 패킷을 수신하고나서 
그 패킷의 목적지가 N1이냐 N2냐 N3냐 그걸 알고 포워딩을 해야하는데
각각에대한 라우팅테이블의 엔트리가 존재할것
R2입장에서는 어떤 패킷을 받았을때 N1~N4각각에 대해서
그 네개에 대해서 그 다음 전달경고라 달라집니까 아니죠
R2입장에서는 R1으로만 전달하면 된다는것
그러니까 N1~N4까지 4개의 엔트리로 구분할필요가 없다는것
그래서 R2입장에서는 N1~N4를 하나로 묶어서 하나의 엔트리로 표기하면 좋겠다고
하면 좋겠다는것 그게 슈퍼네팅 이다!
하나의 경로로 표기하자
슈퍼네팅을 루트 에그리게이션(Route Aggregation) 이라고도 얘기한다
혹은 루트 서머라이제이션(Route Summarigation) 이라고도 얘기한다
경로 요약이라고 한다
예를들면 200.100.32.0/24 짜리
200.100.33.0/24
200.100.34.0/24
200.100.35.0/24 이라는 네 개의 네트워크가 있다
네 개를 하나로 묶으면 슈터네팅이라고 하는거다
서브네팅은 나누는거지만
반면에 여러개의 네트워크를 하나의 네트워크로 묶는것을 슈퍼네팅 혹은 루트 에그리게이션이라고 하는것
저 네 개를 합치면 뭐가 되느냐
200.100.32.0 이 되는데
단지 프리픽스 길이가 달라지는것
4개를 합치기 위해서는 200.100.32.0/22 가 되는거다
이거를 10진수로 표현하면 8 8 6 0 이니까
서브넷 마스크로 표현하면 255.255.252.0 이 된다는것이다
바로 라우팅테이블의 사이즈를 줄여서 패킷 포워딩을 빨리 할수있도록 하기 위함이다@

예제
200.100.33.0/24
200.100.34.0/24
200.100.35.0/24
자 이 세개의 네트워크를 하나로 묶으라는 슈퍼네트워크를 하라고했다면
각각의 서브넷 마스크는 무엇일까요
슈퍼넷마스크 주소로 나눌때도 2,4,8,16 이런식으로 나눠야한다
이거를 3개를 묶으려면 최소한 4개로 묶어야한다
근데 3개를 묶어야하는데 4개를 묶는다면
3개로만 묶을수는 없으니까
거기에 200.100.32.0/24를 추가해서 묶거나
200.100.33.0~200.100.36.0/24로 네 개로 묶을수도 있다는것이다
32~35로 묶을거냐 33~36으로 묶을거냐
정답은 32~35까지를 묶어야한다
즉 33~36까지 네 개만 묶을수없다는것
슈퍼네트워크를 할때 묶어야하는 네트워크의 배수의 배수가 되어야한다는 얘기다
무슨 이야기냐면 지금 우리가 4개의 네트워크를 묶으려고하는데
그러면 4개의 네트워크를 합친 슈퍼네트워크 주소는 4의 배수가 되야한다는 뜻이다
자 그러면 33~36까지 묶었을때는 처음 주소는 200.100.33.0이되어야하는데
33은 4의 배수가 아니다
자 32~35가된다면 32는 4의배수가 맞으니
그래서 슈퍼네트워크 주소가 될수있다는것
200.100.32.0/22 가 되는것
22는 8 8 6 0 이져 이건 255.255.252.0 이라는 이야기다
세개를 묶으라고헀을때도 이런식으로 묶으면 된다는것


VLSM(Variable-length S.M)
프리픽스 길이에 의해서 어떤 네트워크의 사이즈가 수용가능한 호스트의 수가 결정되는것
어떤 클래스가 됬건 하나의 네트워크 주소가있다면 그걸 필요로 하는만큼
필요로하는 호스트의 수만큼 가변기 VLSM을 사용해서 그 해당되는 
네트워크 사이즈를 정해줄수있다는것


VLSM의 동작원리 or 사용원리에대해 설명
ex)14.24.74.0/24 의 시작주소를 갖는 하나의 주소 블록이 기관에게 할당되었다.
각각 120,60,10개의 주소를 갖는 3개의 부 블록을 구성하고자 한다.
네트워크 관리자가 어떻게 서브넷을 구성해줘야 할까요 하는 문제이다
전통적인 서브네팅 개념으로 플어보겠다
이것의 네트워크 주소범위는 14.24.74.0/24~14.24.74.255/24 이다 
세개의 서브넷으로 나눠달라고 했으니까 세개로 나눌려면 최소한 네개로 나눠야하지요
프리픽스 24를 네 개로나누면 26이되잖아요
그러면 8 8 8 2 니까 256을 4등분하면 64개씩 들어가지요
14.24.74.0/26 짜리 서브넷과
14.24.74.64/26
14.24.74.128/26
14.24.74.192/26
각각의 할당 가능한 호스트 id는 64개씩 사용가능한것
근데 여기에 120개 60개 10개로 나누라했는데
3개중에 하나는 120개짜리를 요구하는데 3개로 나누어서는 120개짜리를 수용할수없다
그러면 120개짜리를 나누기 위해서는 네트워크를 몇개로 나누어야 할까요
128개로 나누어야하겠죠
그러니까 120개를 수용하려면 네트워크 아이디로 14.24.74/25짜리와
14.24.74.128/25 이렇게 두개로 나누어야 128개씩 돌아간다는것
자 그럼 문제는 이렇게하니까 120개짜리는 수용해줄수있는데
128개짜리로 나누면 2개밖에 못하니까 3개로하라했으니 요구사항을 들어줄수없다
그래서 이 문제를 해결하기 위해서는
전통적인 서브넷팅으로는 문제를 해결할수없다는것
그래서 VLSM이라는 가변빌이블록으로 나누는것
------
먼저 120개짜리를 수용하려면 프리픽스 길이가 25짜리가 되여야한다
왜냐하면 120개짜리는 호스트밑으로 7비트가 있어야 128개를 구성하게 되니까
그러면 32에서 을뺴니까 25짜리가 있어야한다는것
그러면 일단
14.24.74.0 이라는 네트워크를 프리픽스 25짜리로 먼저 할당을 해줘야 된다는말
그럼 범위가 14.24.74.0~14.24.74.127까지 범위가 될것이다
그럼 안쓰고 남은것은 14.24.74.128 부터는 아직 할당하지 않은것
그러면 이제 그 다음 부블록을 할당해보자
그다음 필요한건 60개짜리니 최소한 64개를 할당해줘야한다
64개를 할당하려면 호스트id로 6비트가 필요하죠
그러니26짜리 부블록을 하나 빼줘야한다
그러면 14.24.74.128부터 시작해서
14.24.74.128부터 마지막은 64개니까
14.24.74.191까지가 되는것이다
14.24.74.192부터는 아직 할당하지않고 남아있는 ip주소이다
세 번째 부블록은 10개를 수용할수있는 사이즈를 빼달라는것
10개를 수용하려면 최소한 16개를 떼어줘야함
호스트 id로는 4비트가 필요
4비트가 필요하려면 반대로 프리픽스 길이는 28이 되어야한다
16을 뺴주기 위해서는 28짜리 블럭을 떼어줘야하고
주소의 범위는 14.24.74.192부터 16개니까
14.24.74.207까지가 될것이고
아직까지 할당하지 않은것은 14.24.74.208~255까지는 아직까지 할당하지 않은 ip주소라는것
자 이렇게 VLSM개념을 가지고 가변길이블록 프리픽스 길이가 전부 다 26짜리로 한다거나
전부다 25짜리를하는 전통적인 서브네팅이 아니라 가변적인 VLSM을 사용하면 이와같은 요구사항을 만족시킬수있다는것
14.24.74.0/25
14.24.74.128/26 
14.24.74.192/28


특수블록

- 32비트가 모두 1인 주소
   - Limited boreadcast address
라우터단에서 제한시키기 때문에 리미티드 인거
32비트가 모두 1인주소 255.255.255.255
목적지주소로만 사용됨
기본적으로 라우터가 리미티드 브로드캐스트 어드레스를 포워딩한 것을 제한하는것

- 32비트가 모드 0인 주소
   - This host on this network 디스호스트 온 디스 네트워크 주소
DHCP 서버 - 공유기에서 서버를 빌려옴 컴퓨터에
IP주소가 설정되어 있지 않기 때문
요청메세지에 IP주소를 적어야하는데 IP주소가 없음
그 주소가 0.0.0.0 이라는것

- 루프백 주소(Loopback address)
ip중 첫번째 자리가 127로 시작
이 주소는 링크계층 이하로 내려가지않음
랜선이 연결되어있지않아도 핑을 했을때 루프백 주소로 통신을하면 정상적으로 응답이 옴

- 사설 주소 (Private address)
내부주소라고도 불림
NAT서비스 나중에 나옴
사설 주소로 사용할수있는건 10으로 시작함
그리고 172.16~172.31.255
B클래스의 사설 주소
192.168은 C클래스 사설IP주소


블록에 속하는 특수 주소
- 네트워크 주소
   - 블록의 시작 주소 (Suffix가 모두 0인 주소)
- 직접 브로드캐스트 주소(Direct broadcast address)
자 예를 들면 200.100.10.0 이라고하는 네트워크는
200.100.10.255가 다이렉트 브로드캐스트 주소가 되는것
자 150.100.255.255는 150.100.0.0의 다이렉트 브로드캐스트 어드레스가 되는것


- 변환 테이블 (Translation table)
   - 하나의 IP주소 사용
   - IP 주소 풀(Pool) 사용 - 공인IP주소
   - IP 주소와 포트번호 사용
A,B,C가 있다고 해보자
A가 사설IP를 사용
라우터가 200.24.5.8이라는 주소를 가지고있음
A는 라우터를 통해서 외부네트워크 8.2.10에 접속하고자한다
그러면 라우터단에서 A의 사설IP주소를 변환해서 외부 네트워크로 접속
B는 라우터를 통해서 100.50.3.1이라는 원격지 호스트에 접속을했다
동일한 공인IP를 사용한다 사용은 가능함
주소 변환테이블을 잘 관리만하면
A는 어디에 B는 어디에 했는지 정보만 가지고있으면 됨
그러면 응답패킷도 다시 받아서 전달해줘야하기 때문
그래서 여러개의 사설IP를 사용을 하더라도
공인IP주소가 하나만 있어도 서비스가 된다는것!
하지만 문제가 있을수있다
만약 A나B가 다 동일한 원격지에 접속했다면 어떻게 될까
이럴경우 라우터가 A와 B 둘중에 어디에 보내야할지 모른다
그래서 NAT서비스가 불가능

그래서 공인IP주소를 여러개를 사용하는것
그러니까 A가 요청할때는 첫 번쨰 공인ip를 이용해서 보내고
B는 두번쨰 공인ip를 이용해서 보내는것
각각 응답해오는 패킷도 구분이 되는것!
이게 두번째 풀 기법이다

마지막 방법은 ip주소와 포트번호를 사용한다는것
만약 인터넷을 사용하고자 하는 사설ip가 공인ip는 10개가있는데
동시에 인터넷을 사용하고자하는 호스트가 동시에 50개라면
다 지원을 할수가없다 결국 50개를 동시에 할수가없다
ip는 10개라서 지원이 불가능
이떄는 어떻게 사설 호스트들을 구분하게 되느냐 하면
ip주소만 가지고 구분하는 것이 아니라 사설 호스트의 private address에 해당하는
포트번호를 설정한다
포트번호를 부가적으로 설정해서 두 개의 호스트를 구분하면
응답 패킷을 라우터가 구분해서 다시 사설 ip주소를 사용하는 호스트들한테 보내줄수있다는것
그래서 ip주소 만으로 모든 사설ip주소를 지원해주는것이 불가능함으로
포트번호까지 부여해서 사설호스트들을 구분하는 서비스를
PAT(Port address Translation)기능이라고도 부른다
