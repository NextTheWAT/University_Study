컴퓨터 네트워크 6주차 정리

서브넷팅 예

C 클래스 서브넷팅
- C 클래스 주소 : netid(3바이트), hosid(1바이트)
- 주소공간(2^8-2 = 254)

예제 3
- C 클래스 주소를 가진 기관이 5개의 서브네트워크를 필요로 한다.
서브넷 마스크와 각 서브네트워크 구성을 찾아보라
- 풀이
   - 5개지만 7개필요(subnetid가 모두 1인것과 0인것 포함)
   - 서브넷 할당을 위한 최소 비트 수 : 3개(2^2<7<2^3)
   - 5개의 비트 hostid(2^5 = 32개), 실제는 30개
200.100.10.0/24 의 디폴트 서브넷 마스크는 
255.255.255.0/24
서브넷 아이디가 all 0,1 인것은 사용 불가능
산술적으로는 7개를 할당해야 두개를빼면 5개가 남으니까 그렇게 할당해야함
최소한 8개는 나눠야함 그러면 3비트를 나눠야하는거고
255.255.255.224가 됨 뒤에 3비트를 111로 바꿔서
필요한 서브넷 마스크는 무엇이냐 10진법으로 표현하라면 255.255.255.224/27가 되는것.
원래 200.100.10.0 의 주소의 범위는
200.100.10.1~200.100.10.255까지 총 256개의 ip주소 조합이 가능한것
200.100.10.0에서 255까지 중 이걸 32개로 나누면 =
1. 200.100.10.0~31		000 00000
2. 200.100.10.32~63	001 00000
3. 200.100.10.64~95	010 00000 - 마지막 주소
4. 200.100.10.96~127	011 00000 - 
5. 200.100.10.128~159	100 00000
6. 200.100.10.160~191	101 00000
7. 200.100.10.192~223	110 00000
8. 200.100.10.224~255	111 00000
까지 나눠짐
총 8개의 서브넷으로 구성이 된다
각 서브넷 호스트 아이디는 5비트가 남고 그 다섯비트가 호스트 아이디가 all 0인
주소를 네트워크 주소라고 한다 왼쪽에 1~8이 서브네트워크 주소가 됨!
31은 마지막 다섯비트가 all 1인경우
63,95 전부다 마지막 열에있는 8개의 주소가 호스트 아이디(5비트)가 all 1 인경우
서브넷 브로드캐스팅 주소다!
all 0 = 서브네트워크 주소
all 1 = 서브넷 브로드캐스팅 주소

서브넷팅을 할때 각 링크상에서 네트워크 속도는 올라간다 256개보다 30개씩 하는게
하지만 라우팅 테이블의 엔트리는 늘어남 엔트리를 찾는 시간이 늘어나는것
그래서 라우팅 테이블의 사이즈가 늘어난다
관리측면에서 용이하다, 링크속도는 높아지지만
단점은 라우팅 테이블 사이즈가 늘어난다
look up하는 시간이 늘어남
그래서 패킷 포워딩을 하는데 지연이 늘어날수있다!



서브넷팅 예제
ex) 200.100.10.0/24 서브네팅 네트워크
세 개의 네트워크로 나누고자 할때 필요한 서브넷마스크를 10진 표기법으로 나타내어라
sol) 세 개의 서브넷이니 몇개로 나눠야할까 최소한 4개로 나누어야함
서브넷 아이디 올0올1 다 사용 가능한 전재로
네 개로 구분하기위해서는 서브넷 아이디가 2비트가 필요 4개의 서브넷으로 나누어야 하니
그러면 프리픽스 26을 사용해야된다는 얘기
26은 8 8 8 2 이니 255.255.255.192
c클래스를 세 개의 서브넷으로 나누고자 할때는 네 개로 나눴을때 네트워크 서브넷 마스크는
255.255.255.192 가 된다
200.100.10.0이 c클래스이니 
200.100.10.0~200.100.10.255 이걸 64개씩 4등분하면
200.100.10.0~ 63
200.100.10.64~ 127
200.100.10.128~ 191
200.100.10.192~ 255
이런식으로 네 등분 할수있다
0,64,192,255 서브넷 주소가 되는것
실제 할당가능한 ip주소는1~63, 65~126,,,,, 등등이 될 것임


ex) 200.100.50.100/26
이 ip주소가 속한 서브네트워크주소와 서브넷 브로드캐스팅 주소를
10진 표기법으로 나타내어라
서브 네트워크 주소를 네트워크의 시작 주소라고도 부름
브로드캐스팅 주소 = 마지막주소
결국 시작주소와 마지막주소를 구하라는 문제
sol) 8 8 8 2 
마지막 자리가 2비트만을 네트워크주소로 사용하겠다는것
200.100.50은 고정값
마지막 네 번째 2비트만 네트워크 아이디로 사용하고있다는것
마지막 자리를 네 등분 하겠다는 의미
256개 짜리를 64개씩 돌아가는것
그럼 마지막 자리가 0.64.128.192가 된다는것
앞에값은 똑같음
서브네트워크의 시작주소와 마지막주소니
아마 두 번째 네트워크에 속해있을것
200.100.50.100은 200.100.50.64~200.100.50.127 사이의 주소일것
결국 답은
시작주소 = 200.100.50.64
마지막 주소 = 200.100.50.127


B클래스의 서브넷팅
- B클래스의 주소 : netid(2바이트), hostid(2바이트)

예제2
- B클래스 주소를 가진 기관이 12개의 서브네트워크를 필요로한다.
  서브넷 마스크와 서브네트워크 구성을 찾아보아라
ex) 150.100.0.0/16
12개로 나눌려면 16개로 나누어야함 결국 4비트가 필요한것
프리픽스 길이는 /20이 될것
결국 8 8 4 0
바이너리로 표현하자면 11111111 11111111 00000000 00000000
서브넷을 구분하기위해 4비트를 가져온다 11111111 11111111 11110000 00000000
이거를 10진수로 표현하면 255.255.240.0 이될것
서브넷 마스크는 10진수로 표현하자면 255.255.240.0/20 답
각 서브넷당 2^12-2개의 서브넷을 할당가능한것
256나누기 16은 16개씩 들어감
그래서 3번째 자리가 16의 배수가 되는것


A클래스 서브넷팅
- A클래스 주소 : netid(1바이트), hostid(3바이트)
- 주소공간 : 2^24 - 2(16,777,214)

예제 1
- A클래스 주소를 가진 기관이 1000개의 서브넷을 필요로 한다. 서브넷 마스크와 서브넷 구성을 찾아보라
ex) 100.0.0.0/8
바이너리로 표현하면 11111111 00000000 00000000 00000000
자 이중에 서브넷을 천개로 나누려고한다 그러면 10비트를 빌려와야겠지요
900개를 나누건 800개를 나누건 10비트를 빌려와야함
자 10비트를 빌려온걸 10진수로 표현하면 255.255.192.0/18 이다 (답)
자 서브넷 마스크와 서브넷 구성도 찾아보자
100은 고정이고 c언어의 배열처럼 사용됨


ex) 150.100.100.9/19 라고하는 ip주소가있다고 가정하자
이 ip주소가 속한 서브넷의 서브네트워크주소와
서브넷브로드캐스팅 주소를 각각 10진법으로 표기하라
결국 시작주소와 마지막주소를 표기하라는문제
8 8 3 0 이니 150.100은 고정이니
3이니까 세번째 자리 256개자리를 3비트로 구분할수있는건 8등분하자는것
그럼 32개씩 돌아감 그러니 150.100.0.0 이되는것이니
그다음은 150.100.32.0 이라는얘기
0.32.64.96.128.160.192.244 가 된다는 얘기
100.9가 속한 네트워크는 150.100.96.0~ 인 네트워크가 될것
그러면 150.100.96.0이 시작주소
	150.100.127.255가 마지막 주소가되는것

제일 중요한건 프리픽스 길이가 중요함 A,B,C클래스는 무의미함

A클래스에대한 예제
ex) 100.50.90.5/18
8 8 2 0
결국 256을 4등분하라는것
100.50.0.0~
64.0
128.0
192.0
이 된다는것
결국 두 번째 서브넷에 속한것
시작주소는 100.50.64.0이되고
마지막주소는 100.50.127.255가 될것




슈퍼네팅 (Supernetting)
서브네팅과 반대되는 개념
서브네팅의 장점도있지만
라우팅 테이블의 엔트리가 늘어나는
룩업하는 찾는 과정에대한 시간이 많이 걸릴수있다
자 예시를 들어보자
R1이라는 라우터단이 있다
서브네팅을 했을수도있고 안했을수도있다
그런데 R1에 또 연결되어있는 라우터가있을수있는데
그걸 R2라고하자 R1입장에서는 어떤 패킷을 수신하고나서 
그 패킷의 목적지가 N1이냐 N2냐 N3냐 그걸 알고 포워딩을 해야하는데
각각에대한 라우팅테이블의 엔트리가 존재할것
R2입장에서는 어떤 패킷을 받았을때 N1~N4각각에 대해서
그 네개에 대해서 그 다음 전달경고라 달라집니까 아니죠
R2입장에서는 R1으로만 전달하면 된다는것
그러니까 N1~N4까지 4개의 엔트리로 구분할필요가 없다는것
그래서 R2입장에서는 N1~N4를 하나로 묶어서 하나의 엔트리로 표기하면 좋겠다고
하면 좋겠다는것 그게 슈퍼네팅 이다!
하나의 경로로 표기하자
슈퍼네팅을 루트 에그리게이션(Route Aggregation) 이라고도 얘기한다
혹은 루트 서머라이제이션(Route Summarigation) 이라고도 얘기한다
경로 요약이라고 한다
예를들면 200.100.32.0/24 짜리
200.100.33.0/24
200.100.34.0/24
200.100.35.0/24 이라는 네 개의 네트워크가 있다
네 개를 하나로 묶으면 슈터네팅이라고 하는거다
서브네팅은 나누는거지만
반면에 여러개의 네트워크를 하나의 네트워크로 묶는것을 슈퍼네팅 혹은 루트 에그리게이션이라고 하는것
저 네 개를 합치면 뭐가 되느냐
200.100.32.0 이 되는데
단지 프리픽스 길이가 달라지는것
4개를 합치기 위해서는 200.100.32.0/22 가 되는거다
이거를 10진수로 표현하면 8 8 6 0 이니까
서브넷 마스크로 표현하면 255.255.252.0 이 된다는것이다
바로 라우팅테이블의 사이즈를 줄여서 패킷 포워딩을 빨리 할수있도록 하기 위함이다@

- 슈퍼넷 마스크(Supernet Mask) -> Supernetworkl address
서브넷 마스크 /27 8개짜리니 3개로 나눠야하니까 3개가 추가된것
디폴트 마스크 /24
슈퍼넷 마스크 /21 

예제
200.100.33.0/24
200.100.34.0/24
200.100.35.0/24
자 이 세개의 네트워크를 하나로 묶으라는 슈퍼네트워크를 하라고했다면
각각의 서브넷 마스크는 무엇일까요
슈퍼넷마스크 주소로 나눌때도 2,4,8,16 이런식으로 나눠야한다
이거를 3개를 묶으려면 최소한 4개로 묶어야한다
근데 3개를 묶어야하는데 4개를 묶는다면
3개로만 묶을수는 없으니까
거기에 200.100.32.0/24를 추가해서 묶거나
200.100.33.0~200.100.36.0/24로 네 개로 묶을수도 있다는것이다
32~35로 묶을거냐 33~36으로 묶을거냐
정답은 32~35까지를 묶어야한다
즉 33~36까지 네 개만 묶을수없다는것
슈퍼네트워크를 할때 묶어야하는 네트워크의 배수의 배수가 되어야한다는 얘기다
무슨 이야기냐면 지금 우리가 4개의 네트워크를 묶으려고하는데
그러면 4개의 네트워크를 합친 슈퍼네트워크 주소는 4의 배수가 되야한다는 뜻이다
자 그러면 33~36까지 묶었을때는 처음 주소는 200.100.33.0이되어야하는데
33은 4의 배수가 아니다
자 32~35가된다면 32는 4의배수가 맞으니
그래서 슈퍼네트워크 주소가 될수있다는것
200.100.32.0/22 가 되는것
22는 8 8 6 0 이져 이건 255.255.252.0 이라는 이야기다
세개를 묶으라고헀을때도 이런식으로 묶으면 된다는것


Classless Addressing
- 1996년
- 가변 길이 블록(Variable-length blocks)
	- 각 기관에 2^n(0=<n=<32) 개의 주소를 갖는 블록을 할당
VLSM(Variable-length S.M)
프리픽스 길이에 의해서 어떤 네트워크의 사이즈가 수용가능한 호스트의 수가 결정되는것
어떤 클래스가 됬건 하나의 네트워크 주소가있다면 그걸 필요로 하는만큼
필요로하는 호스트의 수만큼 가변기 VLSM을 사용해서 그 해당되는 
네트워크 사이즈를 정해줄수있다는것

VLSM의 동작원리 or 사용원리에대해 설명
ex)14.24.74.0/24 의 시작주소를 갖는 하나의 주소 블록이 기관에게 할당되었다.
각각 120,60,10개의 주소를 갖는 3개의 부 블록을 구성하고자 한다.
네트워크 관리자가 어떻게 서브넷을 구성해줘야 할까요 하는 문제이다
전통적인 서브네팅 개념으로 플어보겠다
이것의 네트워크 주소범위는 14.24.74.0/24~14.24.74.255/24 이다 
세개의 서브넷으로 나눠달라고 했으니까 세개로 나눌려면 최소한 네개로 나눠야하지요
프리픽스 24를 네 개로나누면 26이되잖아요
그러면 8 8 8 2 니까 256을 4등분하면 64개씩 들어가지요
14.24.74.0/26 짜리 서브넷과
14.24.74.64/26
14.24.74.128/26
14.24.74.192/26
각각의 할당 가능한 호스트 id는 64개씩 사용가능한것
근데 여기에 120개 60개 10개로 나누라했는데
3개중에 하나는 120개짜리를 요구하는데 3개로 나누어서는 120개짜리를 수용할수없다
그러면 120개짜리를 나누기 위해서는 네트워크를 몇개로 나누어야 할까요
128개로 나누어야하겠죠
그러니까 120개를 수용하려면 네트워크 아이디로 14.24.74/25짜리와
14.24.74.128/25 이렇게 두개로 나누어야 128개씩 돌아간다는것
자 그럼 문제는 이렇게하니까 120개짜리는 수용해줄수있는데
128개짜리로 나누면 2개밖에 못하니까 3개로하라했으니 요구사항을 들어줄수없다
그래서 이 문제를 해결하기 위해서는
전통적인 서브넷팅으로는 문제를 해결할수없다는것
그래서 VLSM이라는 가변빌이블록으로 나누는것
------
먼저 120개짜리를 수용하려면 프리픽스 길이가 25짜리가 되여야한다
왜냐하면 120개짜리는 호스트밑으로 7비트가 있어야 128개를 구성하게 되니까
그러면 32에서 을뺴니까 25짜리가 있어야한다는것
그러면 일단
14.24.74.0 이라는 네트워크를 프리픽스 25짜리로 먼저 할당을 해줘야 된다는말
그럼 범위가 14.24.74.0~14.24.74.127까지 범위가 될것이다
그럼 안쓰고 남은것은 14.24.74.128 부터는 아직 할당하지 않은것
그러면 이제 그 다음 부블록을 할당해보자
그다음 필요한건 60개짜리니 최소한 64개를 할당해줘야한다
64개를 할당하려면 호스트id로 6비트가 필요하죠
그러니26짜리 부블록을 하나 빼줘야한다
그러면 14.24.74.128부터 시작해서
14.24.74.128부터 마지막은 64개니까
14.24.74.191까지가 되는것이다
14.24.74.192부터는 아직 할당하지않고 남아있는 ip주소이다
세 번째 부블록은 10개를 수용할수있는 사이즈를 빼달라는것
10개를 수용하려면 최소한 16개를 떼어줘야함
호스트 id로는 4비트가 필요
4비트가 필요하려면 반대로 프리픽스 길이는 28이 되어야한다
16을 뺴주기 위해서는 28짜리 블럭을 떼어줘야하고
주소의 범위는 14.24.74.192부터 16개니까
14.24.74.207까지가 될것이고
아직까지 할당하지 않은것은 14.24.74.208~255까지는 아직까지 할당하지 않은 ip주소라는것
자 이렇게 VLSM개념을 가지고 가변길이블록 프리픽스 길이가 전부 다 26짜리로 한다거나
전부다 25짜리를하는 전통적인 서브네팅이 아니라 가변적인 VLSM을 사용하면 이와같은 요구사항을 만족시킬수있다는것
14.24.74.0/25
14.24.74.128/26
14.24.74.192/28



































