자료구조 기말정리


선형 리스트의 연산과 알고리즘 시험에는 안나옴 너무 복잡해서@


선형 리스트에서 원소 삭제와 알고리즘
선형리스트 중간에서 원소가 삭제되면, 그 이후의 원소들은 한 자리씩 자리를 앞으로 이동하여 물리적 순서를 논리적 순서와 일치시킴


용어를 명확히 알아야함@


순차 자료구조의 문제점@@@
- 삽입 연산이나 삭제 연산 후에 연속적인 물리 주소를 유지하기 위해서 원소들을 이동시키는 추가 작업과 시간 소요 
- 순차 자료구조는 배열을 이용해 구현하기 때문에 배열이 갖고 있는 메모리 사용의 비효율성 문제를 그대로 가짐 


연결 자료구조Linked Data Structure  @@@

- 자료의 논리적인 순서와 물리적인 순서가 불일치
  - 각 원소에 저장되어 있는 다음 원소의 -주소-에 의해 순서가 연결되는 방식
    - 물리적인 순서를 맞추기 위한 오버헤드가 발생하지 않음 --
  - 여러 개의 작은 공간을 연결하여 하나의 전체 자료구조를 표현
    - 크기 변경이 유연하고 더 효율적으로 메모리를 사용 --
1. 논리적인 순서, 물리적인 순서 불일치
2. 순서를 맞추기 위한 오버헤드가 발생하지않음
3. 크기 변경이 유연함


- 연결 리스트
  - 리스트의 연결 자료구조로 표현


연결 리스트의 @@@노드@@@
- 연결 자료구조에서 -하나의 원소-를 표현하기 위한 -단위 구조-
배열은 데이터만 저장하지만 연결 리스트는 데이터와 주소(링크) 가 있다

- 데이터 필드data field
   - 원소의 값을 저장
 - 링크 필드link field  
   - 다음 노드의 주소를 저장


순차 자료구조 - 빈자리 없이 자료를 순서대로 연속하여 저장한다.
연결 자료구조 - 저장 위치의 순서와 상관업싱 노드의 링크 필드에 다음 자료의 주소를 저장한다.


프로그램 기법
순차 자료구조 - 배열을 이용한 구현@
연결 자료구조 - 포인터를 이용한 구현@
배열 자체의 문제점 알아두기 (순차 자료구조)


단순 연결 리스트singly linked list의 개념 4-14p
- 노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가짐


원형 연결 리스트의 개념
- 단순 연결 리스트에서 마지막 노드가 리스트의 첫 번째 노드를 가리키게 하여 리스트의 구조를 원형으로 만든 연결 리스트
검색할때 단순 연결보다 검색할때 용이하다.

단순연결 리스트가 중요하기때문에
원형연결 리스트가 나올 확률이 적음
하지만 리스트 첫 번째 노드 삽입하는 알고리즘 나올수있음


이중 연결 리스트의 개념 
- 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
- 이중 연결 리스트의 노드 구조와 구조체 정의
   - llink(left link) 필드 : 왼쪽 노드와 연결하는 포인터 
   - rlink(right link) 필드 : 오른쪽 노드와 연결하는 포인터 


스택(stack)
접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 형태의 자료구조

스택의 연산
스택에서의 삽입 연산 : push
스택에서의 삭제 연산 : pop

스택(stack)@@@ 그림도@그림은 연탄
스택에 저장된 원소는 top으로 정한 곳에서만 접근 가능
top의 위치에서만 원소를 삽입하므로, 먼저 삽입한 원소는 밑에 쌓이고, 
나중에 삽입한 원소는 위에 쌓이는 구조
마지막에 삽입(Last-In)한 원소는 맨 위에 쌓여 있다가 가장 먼저 삭제(First-Out)됨 ☞ @@후입선출@@ 구조 (LIFO, Last-In-First-Out)

스택 시험에 나옴 그림도 그려야함@@


순차 자료구조로 구현한 스택의 장점@
- 순차 자료구조인 1차원 배열을 사용하여 쉽게 구현

순차 자료구조로 구현한 스택의 단점
- 물리적으로 크기가 고정된 배열을 사용하므로 스택의 크기 변경 어려움
- 순차 자료구조의 단점을 가짐


수식의 표기법@@@ 시험에 나옴
전위표기법(prefix notation) 
- 연산자를 피연산자를 앞에 표기하는 방법 
  예) +AB 

중위표기법(infix notation) 
- 연산자를 피연산자의 가운데 표기하는 방법 
  예) A+B 

후위표기법(postfix notation) 
- 연산자를 피연산자 뒤에 표기하는 방법 
  예) AB+ 

(3x4) + (5x6) - (7/8)
((3x4) + (5x6)) - (7/8)
(((3x4) + (5x6)) - (7/8))
-(+(x(34) x (56) / ( 7 8 ))
이렇게 바뀐다
최종적으로
- + x 3 4 x 5 6 / 7 8
전위 표기법 이런식으로 시험에 나옴@@@ 40p


큐(Queue) @@@ 4p 그림도
- 스택과 비슷한 삽입과 삭제의 위치가 제한되어있는 유한 순서 리스트
- 큐는 뒤에서는 삽입만 하고, 앞에서는 삭제만 할 수 있는 구조
  - 삽입한 순서대로 원소가 나열되어 가장 먼저 삽입(First-In)한 원소는
    맨 앞에 있다가 가장 먼저 삭제(First-Out)됨
    ☞ -@@선입선출@@- 구조 (FIFO, First-In-First-Out)	


큐의 연산
- 삽입 : enQueue
- 삭제 : deQueue
5p 표 중요 외워두기 @@@


순차 큐@@
- 1차원 배열을 이용한 큐
  - 큐의 크기 = 배열의 크기
  - 변수 front : 저장된 첫 번째 원소의 인덱스 저장
  - 변수 rear : 저장된 마지막 원소의 인덱스 저장


상태 표현  @@@ 외우기
  - 초기 상태 : front = rear = -1
  - 공백 상태 : front = rear
  - 포화 상태 : rear = n-1  (n : 배열의 크기, n-1 : 배열의 마지막 인덱스)


10p 나올수있음@
11p@도
12p 알고리즘도 나올수있음@@
13p 도 @@
14p는 문제가 되는 것 그냥 알아두기


21p @
순차큐, 원형큐 나올수있음@
22p@
23p@


연결 큐
단순 연결 리스트를 이용한 큐

큐의 원소 : 단순 연결 리스트의 노드
큐의 원소의 순서 : 노드의 링크 포인터로 연결
변수 front : 첫 번째 노드를 가리키는 포인터 변수 
변수 rear : 마지막 노드를 가리키는 포인터 변수

상태 표현 @@
초기 상태와 공백 상태 : front = rear = null


29p 나올확률 적음
연결 큐는 포화상태가 없음 무한대임 계속 연결할 수 있으니까

30p 나올확률 큼@@

33p @ 나올수도


큐 물어보면 순서대로(선입선출) 꼭 들어가야함@@













