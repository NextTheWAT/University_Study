컴퓨터 구조 6주차 정리


Searching for Trend
인공신경망을 구성하고 학습시키는 과정을 돕는 @인공신경망@ 개발 프레임워크
수많은 데이터를 쉽게 모델에 입력할 수 있도록 하는 데이터 로더 모듈과 인공신경망을 구현할 때 자주 
쓰이는 연산들을 API 형태로 제공하여 연구자가 쉽게 모델을 작성할 수 있게 도우며 특히 병렬화에 대한 선행 지식이 없는 연구자도 높은 연산성능을 학습과정에 이용할 수 있도록 자동적인 병렬화 기능을 제공 Google 의 Tensorflow 와 Facebook 의 PyTorch 가 대부분 사용중

자연어(NLP) 처리 분야  워드임베딩 
여러분들의 인간들이 서로 말하고, 듣고, 쓰고, 문서로 작성하는 일반적으로 사용하는 언어자연어 (Natural language)
자연어 처리(NLP)자연어를 컴퓨터가 이해하고 데이터화해서 처리하는 방법을 연구하는 것
가장 보편적으로 사용되고 있으면서 간편하고 쉽게 접근할 수 있는 워드 임베딩 (Word embedding)
2013년, 구글의 미코로프는 word2vec 워드 임베딩 모델 발표.
단어(word)를 벡터로(to vector) 변환시켜주는 모델.


01  프로세서 구성과 동작

컴퓨터 기본 구조와 프로세서
- 컴퓨터의 3가지 핵심 장치 : 프로세서(Processor, CPU), 메모리, 입출력장치
- 버스(Bus) : 장치간에 주소, 데이터, 제어 신호를 전송하기 위한 연결 통로(연결선)

CPU : Central Processing Unit = 중앙처리장치 
  사람의 두뇌 (판단, 연산, 제어), 동작을 제어하고 명령을 실행
중앙처리장치 = ①제어(통제), ②연산(±×÷, 크다 작다, 참과 거짓 판단) 
                         ③ 레지스터 의 3부분으로 구성

버스(Bus) : 장치간에 주소, 데이터, 제어 신호를 전송하기 위한 연결 통로(연결선)
@- 내부버스(internal bus) : 프로세서 내부의 장치 연결
@- 시스템 버스(system bus) : 핵심 장치 및 주변장치 연결


프로세서 구성 요소
- 프로세서 3가지 구성 필수 구성요소 
   - 산술 논리 연산 장치(Arithmetic Logic Unit, ALU) : 산술 및 논리 연산 등 기본 연산을 수행
   - 제어 장치 (Control Unit, CU) : 메모리에서 명령어를 가져와 해독하고 실행에 필요한 장치들을 제어하는 신호를 발생 
   - 레지스터 세트(register set) : 프로세서 내에 존재하는 용량은 작지만 매우 
     빠른 메모리, ALU의 연산과 관련된 데이터를 일시 저장하거나 특정 제어 정보 저장
      - 목적에 따라 특수 레지스터와 범용 레지스터로 분류
메모리보다 더 빠른것
   - 현재는 온칩 캐시(on-chip cache), 비디오 컨트롤러(video controller), 실수보조연산 프로세서(FPU) 등 다양한 장치 포함


프로세서 기본 구조
- 레지스터 세트(일반적으로 1~32개)
- ALU : 산술 논리 연산 장치
- CU : 제어 장치
- 이들 장치를 연결하는
  버스로 구성

프로세서 명령 실행
- 프로세서는 각 명령을 더 작은 마이크로 명령(microinstruction)들로 나누어 실행
  1단계 다음에 실행할 명령어를 메모리에서 읽어 명령 레지스터(IR)로 가져온다.
  2단계 프로그램 카운터(PC)는 그 다음 명령어의 주소로 변경된다.
  3단계 방금 가져온 명령어를 해독(decode)하고 유형을 결정한다.
  4단계 명령어가 메모리에 있는 데이터를 사용하는 경우 그 위치를 결정한다.
  5단계 필요한 경우 데이터를 레지스터로 가져온다.
  6단계 명령어를 실행한다.
  7단계 1단계로 이동하여 다음 명령어 실행을 시작한다.
- 이 단계를 요약하면 @인출(fetch)-해독(decode)-실행(execute) 사이클로 구성 – 주 사이클(main cycle)@

산술연산 6-9p

Booth Algorithm 6-10p

논리 연산과 산술 시프트 연산 6-11p


03  레지스터

- 레지스터 동작
- 레지스터는 CPU가 사용하는 데이터와 명령어를 신속하게 읽어 오고 저장하고 전송하는 데 사용
- 레지스터는 메모리 계층의 최상위에 있으며 시스템에서 가장 빠른 메모리
- 매우 단순한 마이크로프로세서는 누산기(AC) 레지스터 1개로만 구성 가능
- 레지스터 용도에 따른 종류
   - 누산기(Accumulator, AC)
   - 프로그램 카운터(Program Counter, PC)
   - 명령 레지스터(Instruction Register, IR)
   - 인덱스 레지스터(Index Register, IX)
   - 스택 포인터(Stack Pointer, SP)
   - 메모리 데이터 레지스터(Memory Data Register : MDR, Memory Buffer Register : MBR) 
   - 메모리 주소 레지스터(Memory Address Register, MAR)
- 데이터(범용) 레지스터는 보통 8~32개 정도, 많으면 128개 이상인 경우도 있음
- 특수 레지스터는 8~16개 정도

레지스터 종류
- 메모리 주소 레지스터(Memory Address Register, MAR)
   - CPU가 읽고 쓰기 위한 데이터의 메모리 주소 저장
   - 메모리에 데이터를 저장하거나 읽을 때 필요한 메모리 위치의 주소를 MAR로 전송
- 메모리 버퍼 레지스터(Memory Buffer Register, MBR, MDR)
   - 메모리에서 데이터를 읽거나 메모리에 저장될 명령의 데이터를 일시적 저장
   - 명령어 내용은 명령 레지스터로 전송되고, 데이터 내용은 누산기 또는 I/O 레지스터로 전송
- 입출력 주소 레지스터(I/O Address Register, I/O AR)
   - 특정 I/O 장치의 주소를 지정하는 데 사용
- 입출력 버퍼 레지스터(I/O Buffer Register, I/O BR)
   - I/O 모듈과 프로세서 간에 데이터를 교환하는 데 사용

- 프로그램 카운터(PC)
   - 명령 포인터 레지스터라고도 하며, 실행을 위해 인출(fetch)할 다음 명령의 주소를 저장하는데 사용
   - 명령어가 인출되면 PC 값이 단위 길이(명령 크기)만큼 증가
   - 항상 가져올 다음 명령의 주소 유지
- 명령 레지스터(Instruction Register, IR)
   - 주기억 장치에서 인출한 명령어 저장
   - 제어 장치는 IR에서 명령어를 읽어 와서 해독하고 명령을 수행하기 위해 컴퓨터의 각 장치에 제어신호 전송
- 누산기(ACcumulator register, AC)
   - ALU 내부에 위치하며, ALU의 산술 연산과 논리 연산 과정에 사용
   - 제어 장치는 주기억 장치에서 인출된 데이터 값을 산술 연산 또는 논리 연산을 위해 누산기에 저장
   - 이 레지스터는 연산할 초기 데이터, 중간 결과 및 최종 연산 결과 저장
   - 최종 결과는 목적지 레지스터나 MBR을 이용하여 주기억 장치로 전송

- 스택 제어 레지스터(Stack Control Register, Stack Pointer)
   - 메모리의 한 블록이며, 데이터는 후입 선출(Last In-First Out, LIFO)로 검색
FIFO - ex)먼저 들어온사람이 먼저 나가는것
LIFO - ex)맨 마지막으로 들어온 사람이 먼저 나가는것
   - 메모리 스택을 관리하는 데 사용
   - 크기는 2 또는 4바이트
- 플래그 레지스터(Flag Register, FR)
   - CPU가 작동하는 동안 특정 조건의 발생을 표시하는 데 사용
   - 1바이트 또는 2바이트인 특수 목적 레지스터
   - 예를 들어 산술 연산 또는 비교 결과로 제로 값이 누산기에 입력되면 제로 플래그를 1로 설정
- 상태 레지스터(Status Register, SR), 프로그램 상태 워드(Program Status Word, PSW)라고도 함
   - 데이터 레지스터(Data Register, 범용 레지스터)
   - CPU내의 데이터를 일시적으로 저장하기 위한 레지스터
   - 고정 소수, 부동 소수로 구분하여 따로 저장하는 경우도 있으며, 
   - 어떤 프로세서는 상수 0 또는 1을 저장할 수 있도록 하는 레지스터도 있다.

레지스터 전송(LOAD, STORE, MOVE 명령 등)  6-17p
- 3가지 레지스터 전송 명령 : LOAD, STORE, MOVE 
- 인텔 프로세서는 이 세 가지를 MOVE 명령으로 모두 처리한다.
- MOVE 명령어를 사용하여 데이터 교환이나 데이터형 변환이 가능하다.


04  컴퓨터 명령어

명령어 형식
- 연산 코드(opcode), 오퍼랜드(operand), 피연산자 위치, 
  연산 결과의 저장 위치 등 여러 가지 정보로 구성
- 0-주소 명령어
- 연산에 필요한 오퍼랜드 및 결과의 저장 장소가 묵시적으로 지정된 경우 : 스택(stack)을 갖는 구조(PUSH, POP) 
- 스택 구조 컴퓨터에서 수식 계산 : 역 표현 (reverse polish)

1-주소 명령어 
- 연산 대상이 되는 2개 중 하나만 표현하고 나머지 하나는 묵시적으로 지정: 누산기(AC)
- 기억 장치 내의 데이터와 AC 내의 데이터로 연산
- 연산 결과는 AC에 저장
- 다음은 기억 장치 X번지의 내용과 누산기의 내용을 더하여 결과를 다시 누산기에 저장
        ADD X	     ; AC ← AC + M[X]
- 오퍼랜드 필드의 모든 비트가 주소 지정에 사용: 보다 넓은 영역의 주소 지정
- 명령워드 : 16비트, Opcode: 5비트, 오퍼랜드(addr):  11비트  32(=25)가지의 연산 가능, 2048(=211)개 주소 지정 가능

2-주소 명령어
- 연산에 필요한 두 오퍼랜드 중 하나가 결과 값 저장
- 레지스터 R1과 R2의 내용을 더하고 그 결과를 레지스터 R1에 저장
- R1 레지스터의 기존 내용은 지워짐
       ADD R1, R2 		; R1 ← R1 + R2

3-주소 명령어
- 연산에 필요한 오퍼랜드 2개와 결과 값의 저장 장소가 모두 다름
- 레지스터 R2와 R3의 내용을 더하고 그 결과 값을 레지스터 R1에 저장하는 명령어다.
- 연산 후에도 입력 데이터 보존
- 프로그램이 짧아짐
- 명령어 해독 과정이 복잡해짐
     ADD R1, R2, R3   	; R1 ← R2 + R3

명령어 형식 설계 기준명령어 형식
1. 첫 번째 설계 기준 : 명령어 길이
- 메모리 공간 차지 비율 감소
- 명령어 길이를 최소화하려면 명령어 해독과 실행 시간에 비중을 둠
- 짧은 명령어는 더 빠른 프로세서를 의미: 최신 프로세서는 동시에 여러 개의 명령을 실행하므로 클록 주기당 명령어를 여러 개 가져오는 것이 중요
2. 두 번째 설계 기준 : 명령어 형식의 공간
- 2n개를 연산하는 시스템에서 모든 명령어가 n비트보다 크다.
- 향후 명령어 세트에 추가할 수 있도록 opcode를 위한 공간을 남겨 두지 않음
3. 세 번째 설계 기준 : 주소 필드의 비트 수
- 8비트 문자를 사용하고, 주기억 장치가 232개
- 메모리의 기본 단위
   - 4바이트(32비트)로 해야 한다고 주장하는 팀 : 0, 1, 2, 3, ..., 4,294,967,295인 232바이트 메모리 제안
   - 30비트로 해야 한다고 주장하는 팀: 0, 1, 2, 3, ...,1,073,741,823인 230워드 메모리 제안

확장 opcode
- 8비트 연산 코드와 24비트 주소를 가진 32비트 명령어
   - 이 명령어는 연산 28(=256)개와 주소 지정 224(=16M)개 메모리
- 7비트 연산 코드와 25비트 주소를 가진 32비트 명령어
   - 명령어 개수는 절반인 128개이지만 메모리는 2배인 225(=32M)개
- 9비트 연산 코드와 23비트 주소일 때
   - 명령어 개수는 2배(256), 주소는 절반인 223(=8M)개 메모리

- 명령어 길이 16비트, 오퍼랜드 4비트 시스템
   - 모든 산술 연산이 레지스터(따라서 4비트 레지스터 주소) 16개에서 수행되는 시스템
   - 한 가지 설계 방법은 4비트 연산 코드와 오퍼랜드가 3개 있는 3-주소 명령어를 16개 가지는 것

코어 i7 명령어 형식           참고로만 알아둘것 중요x
- 코어 i7 명령어 형식은 매우 복잡하고 불규칙
- 가변 길이 필드가 최대 6개 있으며 그 중 5개는 선택적
- CPU 구조가 여러 세대에 걸쳐 발전했고 초기의 잘못된 선택 때문
- 이전 버전과 호환성 고려로 되돌릴 수 없는 결과 발생

명령어 종류
- ISA(Instruction Set Architecture) 컴퓨터의 명령어 : 6개의 그룹
   - 컴퓨터에는 이전 모델과 호환성을 위해 추가된 몇 가지 특이한 명령어
   - 설계자의 좋은 아이디어 추가
   - 특정 기관에서 비용을 지불하고 명령어 추가

1. 데이터 이동 명령
2. 2항 연산
3. 단항 연산
4. 비교와 조건 분기 명령
5. 프로시저 호출 명령
6. 루프 제어 명령

데이터 이동 명령 @
- 가장 기본이 되는 작업 : 원본과 동일한 새로운 객체를 만드는 복사
- 원래 위치에 그대로 두고 다른 장소에 복사본 생성
데이터를 복사하는 이유
1. 변수에 값 할당 : A=B는 메모리 주소 B의 값(데이터)을 A 장소로 복사한다는 의미다. 
2. 데이터의 효율적인 액세스 및 사용: 메모리와 레지스터 간에 데이터를 이동하여 프로그램 실행을 효율적으로 수행하기 위해서다. 
   - LOAD 명령 : 메모리에서 레지스터로 이동
   - STORE 명령 : 레지스터에서 메모리로 이동  
   - MOVE 명령 : 하나의 레지스터에서 다른 레지스터로 이동
단, @메모리 간 이동은 일반적으로 사용하지 않음@

회전 연산은 워드의 모든 비트 테스트할 경우
- 한 번에 1비트씩 워드를 회전하면 각 비트를 MSB에 순서대로 배치하여 쉽게 테스트 가능
- 모든 비트가 테스트된 후에는 워드가 원래 값으로 복원
- 또는 레지스터 값을 직렬화할 때도 유용함

다른 단항 연산은 INC(1 증가), DEC(1 감소), NEG(2의 보수), NOT(비트 반전) 등
- NEG는 비트를 반전한 후 1을 더한 2의 보수
- NOT은 단순한 비트 반전으로 1의 보수

----------------------------여기까지 5강 복습----------------------------

04  컴퓨터 명령어

비교와 조건 분기 명령
- 조건이 충족되면 특정 메모리 주소로 분기
   - 검사에 사용되는 일반적인 방법 : 특정 비트가 0인지 확인
   - 음수인지 알아보기 위해 부호 비트 검사 : 1이면 분기
- 상태 코드 비트
   - 특정 조건 표시
- 오버플로 비트: 
   - 산술 연산의 결과 데이터가 표현 범위를 벗어났을 때 1로 설정
   - 오버플로 발생 : 에러 루틴 및 수정 조치
- 캐리 비트
   - 맨 왼쪽 비트에서 데이터가 넘칠 때 세트
   - 가장 왼쪽 비트의 캐리는 정상 연산에서도 발생하므로 오버플로와 혼동하면 안됨
   - 다중 비트 연산: 정수가 워드 2개 이상으로 표현되는 경우 연산을 수행하려면 캐리 비트 점검

0 검사
- 루프 및 기타 여러 용도 유용
- 1이 하나라도 들어 있는지를 나타내는 비트를 제공하기 위해 OR 회로를 사용
- Z 비트는 ALU의 모든 출력 비트를 OR한 후 반전
두 수의 비교
- 두 워드나 문자 비교: 같은지, 아닌지 또는 그렇지 않은 경우 어떤 단어가 더 큰지 확인
- 정렬(sorting)할 때 중요
- 주소 3개 필요 : 2개는 데이터 항목, 1개는 조건이 참일 경우 분기할 주소
- 두 정수가 같은지 비교하려면 XOR 사용
- 어떤 수가 큰지 작은지를 비교: 뺄셈을 사용 가능하지만, 아주 큰 양수와 음수를 비교할 때 두 수를 뺄셈하면 그 결과는 오버플로됨
- 비교 명령 : 테스트 충족 여부 결정 및 오버플로가 발생하지 않는 정확한 답 반환 해야 함

프로시저 호출(procedure call) 명령
- 특정 작업을 수행하는 명령 그룹: 프로그램 내 어디서든 호출 가능
- 어셈블리에서는 서브루틴(subroutine), C 언어에서는 함수(function), 자바에서는 메서드(method)라고 함
- 프로시저가 작업을 완료하면 호출 명령 바로 다음 명령으로 복귀
   - 복귀 주소를 프로시저에 전송하거나 복귀할 때 찾을 수 있도록 어딘가에 저장
   - 복귀 주소: 메모리, 레지스터, 스택 세 군데에 배치 가능  
   - 프로시저는 여러 번 호출 가능하므로 프로시저 여러 개가 직접 또는 간접적으로 다중 호출되어도 프로그램이 정상 순서로 수행되어야 함
   - 프로시저를 반복할 경우, 복귀 주소를 호출할 때마다 다른 위치에 두어야 함
   - 프로시저 호출 명령이 복귀 주소와 함께하는 가장 좋은 방법은 스택
	- 프로시저가 끝나면 스택에서 반환 주소를 꺼내 프로그램 카운터 저장
	- 프로시저가 자기 자신 호출 기능 : 재귀(recursion), 스택을 사용하면 재귀 기능 정상 동작
	- 복귀 주소는 이전 복귀 주소가 파손되지 않도록 자동 저장

루프 제어 명령
- 명령 그룹을 정해진 횟수만큼 실행해야 하는 경우
- 루프(loop)를 통해 매번 일정하게 증가 시 또는 감소시키는 카운터 소유
   - 루프를 반복할 때마다 종료 조건을 만족하는지 검사
   - 보통 루프 밖에서 카운터를 초기화한 후 루프 코드 실행 시작
   - 루프의 마지막 명령에서 카운터 업데이트
   - 종료 조건을 아직 만족하지 않으면 루프의 첫 번째 명령으로 분기
   - 반면 종료 조건이 만족되면 루프 종료, 루프를 벗어난 첫 번째 명령이 실행

루프 제어 명령
- 종점 테스트(test-at-the-end 또는 post-test)
   - 조건이 루프의 끝에서 이루어지므로 루프가 무조건 한 번 이상 실행
- 종료 검사를 사전에 수행하도록 루프 구성: 루프의 시작 시점에서 검사
   - 처음부터 조건 만족 : 루프에 포함된 내용을 한 번도 실행하지 않음
- C 언어의 for 처럼 정해진 횟수만큼 반복 루프 가능
- 모든 루프는 한 가지로 표현 가능
   - 용도에 맞는 형태로 사용
 
입출력 명령
- 입출력 장치 다양한 만큼 입출력 명령도 다양
- 개인용 컴퓨터 : 세 가지 입출력 방식 사용
   - 프로그래밍에 의한 입출력  
   - 인터럽트 구동interrupt-driven 입출력
   - DMA 입출력

프로그래밍에 의한 입출력
- 가장 단순함
- 임베디드 시스템 또는 실시간 시스템 같은 저사양 마이크로프로세서에서 일반적으로 사용
- 주요 단점 : 장치가 준비되기를 기다리는 긴 시간을 CPU가 낭비하게 됨
   - 사용 대기(busy waiting)라 함
   - CPU가 할 일이 하나밖에 없다면 문제되지 않음
   - 단, 여러 개의 이벤트 동시 모니터링할 경우 낭비되므로 다른 입출력 방법이 적용

인터럽트 구동 입출력
- 프로세서가 입출력 장치에 작업을 지시하고 완료되면 인터럽트를 생성하도록 명령
- 장치 레지스터에 인터럽트 활성화 비트를 설정 : 입출력이 완료되면 하드웨어가 신호를 제공하도록 요청
- 프로그래밍 입출력보다 개선: 완벽하지 않음
   - 전송된 모든 문자에 인터럽트가 필요하므로 처리 비용이 많이 듦
   - 인터럽트의 많은 부분을 제거하는 방법이 요구됨

DMA(Direct Memory Access) 입출력
- 버스에 직접 액세스할 수 있는 방법: 시스템에 DMA 제어기 추가
- DMA 칩은 내부에 레지스터 최소 4개 보유 : 프로세서에서 실행되는 소프트웨어로 로드 가능
1. 첫 번째는 읽거나 쓸 메모리 주소 포함
2. 두 번째는 얼마나 많은 바이트(또는 워드)가 전송되는지 계산
3. 세 번째는 사용할 장치 번호 또는 입출력 공간 주소를 지정
4. 네 번째는 입출력 장치에서 데이터를 읽거나 쓰는 여부를 지정
- 프로세서 입출력의 부담을 크게 덜어 줌 : 여전히 완전히 자유롭지 못함
- 디스크 같은 고속 장치가 DMA로 실행되는 경우 메모리 참조 및 장치 참조를 위한 버스 사이클이 많이 필요: 이 사이클 동안 CPU는 대기(입출력 장치는 종종 지연을 용인할 수 없으므로 DMA는 항상 CPU보다 높은 버스 우선순위를 가짐)
- @사이클 스틸링(cycle stealing) : DMA 제어기가 CPU에서 버스 사이클을 제거
   - 사이클 스틸링으로 인한 이득이 인터럽트로 인한 손실 보다 큼


05  주소 지정 방식

즉시 주소 지정(immediate addressing mode, 즉치 주소 지정)
- 오퍼랜드를 지정하는 가장 간단한 방법
   - 명령어 자체에 오퍼랜드를 포함
   - 오퍼랜드가 포함되어 명령어가 인출될 때 오퍼랜드도 자동으로 인출
   - 즉시(즉치) 오퍼랜드 : 즉시 사용 가능
- 레지스터 R1에 상수 4를 저장하는 즉시 주소 지정 명령어의 예
- 장점 : 오퍼랜드를 인출을 위한 메모리 참조가 필요 없음
- 단점 : 상수만 가능, 상수 값의 크기가 필드 크기로 제한
- 작은 값의 정수를 지정하는 데 많이 사용

직접 주소 지정(direct addressing mode)
- 메모리에 위치한 오퍼랜드의 전체 주소 지정
- 직접 주소 지정도 즉시 주소 지정처럼 사용 제한
   - 명령어는 항상 정확히 동일한 메모리 위치 액세스
   - 값이 변할 수는 있지만 위치는 변할 수 없음
   - 컴파일할 때 알려진 주소의 전역 변수에 액세스하는 데만 사용 가능

@레지스터 주소 지정(register addressing mode)
- 직접 주소 지정과 개념은 같고 그 위치가 메모리 대신 레지스터
- 가장 일반적인 주소 지정 방식: 
   - 레지스터는 액세스가 빠르고 주소가 짧기 때문
   - 대부분의 컴파일러는 루프 인덱스처럼 가장 자주 액세스할 변수를 레지스터에 넣기 위해 많은 노력을 기울임
- 많은 프로세서에서 사용
- RISC 등에서는 LOAD, STORE 명령을 
  제외하고 대부분의 명령어에서
  레지스터 주소 지정 방식만 사용
- LOAD나 STORE 명령어
   - 한 오퍼랜드는 레지스터고, 
     다른 한 오퍼랜드는 메모리 주소

@레지스터 간접 주소 지정(register indirect addressing mode)
- 직접 주소를 명령어에는 포함하지 않음
   - 메모리의 주소는 레지스터에 저장: 포인터(pointer)
   - 레지스터 간접 주소 지정의 가장 큰 장점 : 명령어에 전체 메모리 주소가 없어도 메모리 참조가능

- 레지스터 R1에 있는 요소의 합계 계산 예
  요소가 100개인 1차원 정수 배열의 요소를 단계별로 설명하는 루프를 생각해 보자. 
  루프 외부에서는 R2 같은 다른 레지스터를 배열의 첫 번째 요소를 가리키도록 설정할 수 있으며 
  다른 레지스터, 예를 들어 R3은 배열을 벗어나는 첫 번째 주소를 가리키도록 설정할 수 있다. 
  배열이 4바이트(32비트 정수)인 정수 100개가 있는 경우 배열이 A에서 시작하면 배열을 벗어나는 첫 번째 주소는 A+400이 된다. 
  이 계산을 수행하는 일반적인 어셈블리 코드는 다음과 같다.
- 여러 주소 지정 방식 사용
   - 첫 번째 명령어에서 오퍼랜드(목적지) 하나는 레지스터 주소 지정이고, 다른 오퍼랜드는 즉시 주소 지정(상수) 
   - 두 번째 명령어는 A의 주소를 R2에 저장
   - 세 번째 명령어는 배열 A를 벗어나 나타나는 첫 번째 워드 주소   
   - 특이한 점 : 루프 자체에 메모리 주소가 포함되지 않음  
   - 네 번째 명령어 : 레지스터 주소 지정과 레지스터 간접 주소 지정
   - 다섯 번째 명령어 : 레지스터 주소 지정과 즉시 주소 지정을
   - 여섯 번째 명령어 : 둘 다 레지스터 주소 지정
- BLT(Branch Less Than) : 메모리 주소를 사용 가능하지만, BLT 명령어 자체에 상대적인 8비트 변위로 분기할 주소를 지정할 때가 많음
- 메모리 주소의 사용을 완전히 피함으로써 짧고 빠른 루프 가능

변위 주소 지정(displacement addressing mode)
- 특정 레지스터에 저장된 주소에 변위(offset: 오프셋)을 더해 실제 오퍼랜드가 저장된 메모리 위치 지정
- 특정 레지스터가 무엇인지에 따라 여러 주소 지정 방식 가능
- 예 : 인덱스 주소 지정 방식은 인덱스 레지스터가 되고, 상대 주소 지정 방식에서는 PC가 특정 레지스터로 지정



