컴퓨터구조 5주차 정리
5주차는 그렇게 중요한것은 없음


4주차에 대한 복습
- 컴퓨터구조의 개념과 특징을 이해하고, 컴퓨터구조를 활용한 시스템 설계.  
- 논리 게이트의 동작 원리와 진리표, 게이트 기호를 이해하고 이를 활용할 수 있다. 
- 곱의 합과 최소항, 합의 곱과 최대항의 개념을 이해하고 이를 활용할 수 있다.
- 여러 가지 조합 논리 회로의 동작 원리를 이해하고 응용 회로를 설계할 수 있다. 
- 여러 가지 순서 논리 회로의 동작 원리를 이해하고 응용 회로를 설계할 수 있다. 


논리 연산순위 1번째 : ( ) @@

- NOT 게이트 논리 연산순위 2번째 : NOT @
한 개의 입력과 한 개의 출력을 갖는 게이트로 논리 부정을 나타낸다. 

- AND 게이트 논리 연산순위 3번째  @
입력이 모두 1인 경우에만 출력이 1이고, 입력 중 0이 하나라도 있으면 출력은 0이 되는 논리곱이다.

- NAND 게이트   AND의 부정 
입력이 모두 1인 경우에만 출력이 0이고, 입력에 0이 하나라도 있는 경우는 모두 출력이 1이다.
AND 게이트와 반대로 동작하여 NOT-AND의 의미로 NAND 게이트라고 한다. 

- OR 게이트 논리 연산순위 4번째 @
입력이 모두 0인 경우에만 출력이 0이고, 입력 중 1이 하나라도 있으면 출력은 1이 되는 논리합이다. 

- NOR 게이트
입력이 모두 0인 경우에만 출력이 1이고, 입력에 1이 하나라도 있는 경우는 모두 출력이 0이다. 
OR 게이트와 반대로 동작하여 NOT-OR의 의미로 NOR 게이트라고 한다. 

- XOR 게이트 (eXclusive OR gate)
입력에 1이 홀수 개이면 출력이 1이고, 짝수 개이면 출력이 0이다.
2입력 XOR 게이트는 두 입력 중 하나가 1이면 출력이 1이고, 두 입력 모두 0이거나 1인 경우에만 출력이 0이 되는 것이다. 

- XNOR 게이트 (eXclusive NOR gate) = XOR 의 부정
입력에 1이 짝수 개이면 출력이 1이고, 홀수 개이면 출력이 0이다.       XOR 게이트에 NOT 게이트를 연결한 것과 출력이 같으므로 XOR 게이트와 반대다. 
2입력 XNOR 게이트는 두 입력이 다르면 출력이 0이고, 두 입력이 같으면 출력이 1이라고 생각하면 쉽다. 


불 대수 5-4p @

- 기본적인 불 대수식은 AND, OR, NOT을 이용하여 표현 
- AND식은 곱셈의 형식으로 표현하고, OR 식은 덧셈의 형식으로 표현
- NOT식은 "A"  ̅ 또는 Aˊ 로 표현
- 완전한 논리식은 입력 항목들의 상태에 따른 출력을 결정하는 식

불 대수 법칙 5-5p
- 불 대수의 모든 항은 0 또는 1을 갖는다. 
- [표 3-1]은 증명 없이 사용하기로 한 AND와 OR의 불 대수 공리다.

불 대수의 기본 법칙 5-6p @
드모르간의 정리 5-7 @


순서 논리 회로의 개요
- 조합 논리 회로(combinational logic circuit) : 이전 입력 값에 관계없이 현재 입력 값에 따라 출력이 결정
- 순서 논리 회로(sequential logic circuit) : 현재의 입력 값과 이전 출력 상태에 따라 출력 값이 결정


플립플롭의 종류
- 플립플롭의 특징
   - 플립플롭은 1비트의 정보를 기억할 수 있는 기억 소자다.
   - 플립플롭은 제어 입력인 클록 펄스가 있으며 다음 클록 펄스가 들어올 때까지 현재 상태를 유지한다.
   - 플립플롭은 Q와 "Q"  ̅로 표시된 출력이 2개 있으며 Q와 "Q"  ̅  의 상태는 서로 보수가 되어야 정상 상태가 된다.
   - 플립플롭은 RAM의 구성 요소로도 사용된다.
   - 플립플롭에는 SR 플립플롭, JK 플립플롭, D 플립플롭, T 플립플롭이 있다.


SR 플립플롭
- SR 플립플롭 : 클록 펄스가 있을 때만 동작하는 SR 래치를 의미
- 클록 펄스는 상승 에지 트리거 신호가 입력된 경우다.

D 플립플롭
- SR 플립플롭에서 원하지 않는 상태(S=R=1)를 제거하는 한 가지 방법
- SR 플립플롭을 변형한 것
- 입력신호 D가 CP에 동기되어 그대로 출력에 전달되는 특성을 가지고 있음 
- D 플립플롭이라는 이름은 데이터(Data)를 전달하는 것과 지연(Delay)하는 역할에서 유래

JK 플립플롭
진리표 5-14

T 플립플롭
- JK 플립플롭의 J와 K 입력을 묶어서 하나의 입력신호 T로 동작시키는 플립플롭
- T 플립플롭의 입력 T=0이면, T 플립플롭은 J=0, K=0인 JK 플립플롭과 같이 동작하므로 출력은 
  변하지 않는다. T=1이면,  J=1, K=1인 JK 플립플롭과 같이 동작하므로 출력은 보수가 된다.

05  집적 회로
- 집적 회로(Integrated Circuit, IC)는 작은 실리콘 칩에 저항, 커패시터, 다이오드,
   트랜지스터 등 전자 부품을 여러 공정을 거쳐 내부적으로 상호 연결한 것
- 칩(chip)은 실리콘 반도체로 세라믹 또는 플라스틱 기판에 부착하여 외부 핀에 연결한다.

집적 회로의 분류 5-17

디지털 시스템의 장점
- 디지털 시스템의 소형화 및 경량화
- 생산 가격의 저렴화
- 소비 전력의 감소
- 동작 속도의 고속화
- 디지털 시스템의 신뢰도 향상

IC 패키지
- PCB에 장착하는 방법에 따라 @삽입 장착형(through-hole mounted)과 @표면 실장형(Surface-Mounted Device, SMD)으로 구분
- 삽입 장착형 IC는 @DIP(Dual-In-line Package) 형태 
- 표면 실장형 IC로는 @SOIC(Small Outline Integrated Circuit), @QFP(Quad Flat Package), @PLCC(Plastic Leaded Chip Carrier) 등이 있다.




5주차 학습목표 및 주요 내용 

학습목표
• 컴퓨터 프로세서의 기본 구조와 명령 실행 과정을 이해한다.
• ALU 구조를 이해하고 프로세서에서의 산술 및 논리 연산을 학습한다.
• 프로세서 내의 레지스터의 종류와 용도를 이해한다.
• 프로세서 명령어 형식의 종류를 구분하고 명령의 동작을 이해한다.
• 명령의 주소 지정 방식을 이해하고 동작 원리를 학습한다.

내용 
01 프로세서 구성과 동작
02 산술 논리 연산 장치
03 레지스터
04 컴퓨터 명령어
05 주소 지정 방식
06 CISC와 RISC


01  프로세서 구성과 동작

컴퓨터 기본 구조와 프로세서
- 컴퓨터의 3가지 핵심 장치 : 프로세서(Processor, CPU), 메모리, 입출력장치@
- 버스(Bus) : 장치간에 주소, 데이터, 제어 신호를 전송하기 위한 연결 통로(연결선)@
CPU : Central Processing Unit = 중앙처리장치 
  사람의 두뇌 (판단, 연산, 제어), 동작을 제어하고 명령을 실행
중앙처리장치 = ①제어(통제), ②연산(±×÷, 크다 작다, 참과 거짓 판단) 
                         ③ 레지스터 의 3부분으로 구성

버스(Bus) : 장치간에 주소, 데이터, 제어 신호를 전송하기 위한 연결 통로(연결선)@@
- 내부버스(internal bus) : 프로세서 내부의 장치 연결@@
- 시스템 버스(system bus) : 핵심 장치 및 주변장치 연결@@

프로세서 구성 요소
- 프로세서 3가지 구성 필수 구성요소
 - 산술 논리 연산 장치(Arithmetic Logic Unit, ALU) : 산술 및 논리 연산 등 기본 연산을 수행
 - 제어 장치 (Control Unit, CU) : 메모리에서 명령어를 가져와 해독하고 실행에 필요한 장치들을 제어하는 신호를 발생
 - 레지스터 세트(register set) : 프로세서 내에 존재하는 용량은 작지만 매우 빠른 메모리, 
   ALU의 연산과 관련된 데이터를 일시 저장하거나 특정 제어 정보 저장
       - 목적에 따라 특수 레지스터와 범용 레지스터로 분류
 - 현재는 온칩 캐시(on-chip cache), 비디오 컨트롤러(video controller), 실수보조연산 프로세서(FPU) 등 다양한 장치 포함

REGISTER 레지스터 = 중앙처리장치의 성능을 나타내는 단위 
 - CPU 내부에서 처리할 명령어, 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억 장소 
 - 플립플롭 혹은 래치 들을 연결하여 구성 
 - 메모리 중에서 가장 속도가 빠름
 - 크기는 컴퓨터가 한 번에 처리할 수 있는 데이터의 크기를 의미 

** 플립플롭 = 기억장치를 구성하는 전자회로, 1비트의 정보 (0 혹은 1)을 기억하는 능력 
** 래치 = 1비트 이상의 입력값을 다음 입력이 오기 전까지 그대로 유지하는 전자회로 


프로세서 기본 구조    5-23
- 레지스터 세트(일반적으로 1~32개)
- ALU
- CU
- 이들 장치를 연결하는
   버스로 구성

ALU
- 덧셈, 뺄셈 등 연산을 수행하고, 그 결과를 누산기(Accumulator, AC)에 저장
프로세서 명령 분류 5-24

프로세서 명령 실행
- 프로세서는 각 명령을 더 작은 마이크로 명령(microinstruction)들로 나누어 실행
	1단계 다음에 실행할 명령어를 메모리에서 읽어 명령 레지스터(IR)로 가져온다.
	2단계 프로그램 카운터(PC)는 그 다음 명령어의 주소로 변경된다.
	3단계 방금 가져온 명령어를 해독(decode)하고 유형을 결정한다.
	4단계 명령어가 메모리에 있는 데이터를 사용하는 경우 그 위치를 결정한다.
	5단계 필요한 경우 데이터를 레지스터로 가져온다.
	6단계 명령어를 실행한다.
	7단계 1단계로 이동하여 다음 명령어 실행을 시작한다.
- 이 단계를 요약하면 인출(fetch)-해독(decode)-실행(execute) 사이클로 구성 – 주 사이클(main cycle)

해독기(microprogrammed control) : 하드웨어를 소프트웨어로 대체
- 고가의 고성능 컴퓨터는 하드웨어 추가 비용이 크게 부담되지 않아 저가 컴퓨터보다 많은 명령어를 갖게 됨
- 고가인 고성능 컴퓨터의 복잡한 명령어를 저가 컴퓨터에서 실행할 수 있게 하기 위함
- 모리스 윌크스(Maurice Wilkes)가 제안(1951년)
   - 1957년 SDSAC 1.5에 적용
- 1970년대 설계된 거의 모든 컴퓨터가 해독기를 기반
   - Cray-1 같은 매우 고가의 고성능 모델을 제외하고는 1970년대 후반에 해독기를 운영하는 프로세서가 보편적으로 보급
   - 복잡한 명령어에 대한 비용 절감, 훨씬 더 복잡한 명령어 연구
- 제어 기억 장치(control memory)라는 빠른 읽기 전용 메모리





산술 논리 연산 장치
- 산술 논리 연산 장치(Arithmetic Logic Unit, ALU) : 산술 연산과 논리 연산
   - 주로 정수 연산을 처리
   - 부동 소수(Floating-point Number) 연산 : FPU(Floating-Point Unit)
   - 최근에는 ALU가 부동 소수 연산까지 처리
- 산술 연산 : 덧셈, 뺄셈, 곱셈, 나눗셈, 증가, 감소, 보수
- 논리 연산 : AND, OR, NOT, XOR, 시프트(shift)


산술 연산 
표 5-2-3

Booth Algorithm 5-2-4
부쓰 알고리즘

논리 연산과 산술 시프트 연산 5-2-7
논리연산 표@
LSR까지?

논리 연산 예 1 : A=46=00101110(2), B=-75=10110101(2)   5-2-8

논리 연산 예 2 5-2-9

시프트 연산 예 5-2-10


레지스터 동작
- 레지스터는 CPU가 사용하는 데이터와 명령어를 신속하게 읽어 오고 저장하고 전송하는 데 사용
- 레지스터는 메모리 계층의 최상위에 있으며 시스템에서 가장 빠른 메모리
- 매우 단순한 마이크로프로세서는 누산기(AC) 레지스터 1개로만 구성 가능
- 레지스터 용도에 따른 종류@
   - 누산기(Accumulator, AC)
   - 프로그램 카운터(Program Counter, PC)
   - 명령 레지스터(Instruction Register, IR)
   - 인덱스 레지스터(Index Register, IX)
   - 스택 포인터(Stack Pointer, SP)
   - 메모리 데이터 레지스터(Memory Data Register : MDR, Memory Buffer Register : MBR) 
   - 메모리 주소 레지스터(Memory Address Register, MAR)
- 데이터(범용) 레지스터는 보통 8~32개 정도, 많으면 128개 이상인 경우도 있음
- 특수 레지스터는 8~16개 정도

레지스터 동작 개념 5-2-12

레지스터 종류
- 메모리 주소 레지스터(Memory Address Register, MAR)@
   - CPU가 읽고 쓰기 위한 데이터의 메모리 주소 저장
   - 메모리에 데이터를 저장하거나 읽을 때 필요한 메모리 위치의 주소를 MAR로 전송
- 메모리 버퍼 레지스터(Memory Buffer Register, MBR, MDR)@
   - 메모리에서 데이터를 읽거나 메모리에 저장될 명령의 데이터를 일시적 저장
   - 명령어 내용은 명령 레지스터로 전송되고, 데이터 내용은 누산기 또는 I/O 레지스터로 전송
- 입출력 주소 레지스터(I/O Address Register, I/O AR)@
   - 특정 I/O 장치의 주소를 지정하는 데 사용
- 입출력 버퍼 레지스터(I/O Buffer Register, I/O BR)@
   - I/O 모듈과 프로세서 간에 데이터를 교환하는 데 사용

- 프로그램 카운터(PC)@
   - 명령 포인터 레지스터라고도 하며, 실행을 위해 인출(fetch)할 다음 명령의 주소를 저장하는데 사용
   - 명령어가 인출되면 PC 값이 단위 길이(명령 크기)만큼 증가
   - 항상 가져올 다음 명령의 주소 유지
- 명령 레지스터(Instruction Register, IR)@
   - 주기억 장치에서 인출한 명령어 저장
   - 제어 장치는 IR에서 명령어를 읽어 와서 해독하고 명령을 수행하기 위해 컴퓨터의 각 장치에 제어신호 전송
- 누산기(ACcumulator register, AC)@
   - ALU 내부에 위치하며, ALU의 산술 연산과 논리 연산 과정에 사용
   - 제어 장치는 주기억 장치에서 인출된 데이터 값을 산술 연산 또는 논리 연산을 위해 누산기에 저장
   - 이 레지스터는 연산할 초기 데이터, 중간 결과 및 최종 연산 결과 저장
   - 최종 결과는 목적지 레지스터나 MBR을 이용하여 주기억 장치로 전송

- 스택 제어 레지스터(Stack Control Register, Stack Pointer)@
   - 메모리의 한 블록이며, 데이터는 후입 선출(Last In-First Out, LIFO)로 검색
   - 메모리 스택을 관리하는 데 사용
   - 크기는 2 또는 4바이트
- 플래그 레지스터(Flag Register, FR)@
   - CPU가 작동하는 동안 특정 조건의 발생을 표시하는 데 사용
   - 1바이트 또는 2바이트인 특수 목적 레지스터
   - 예를 들어 산술 연산 또는 비교 결과로 제로 값이 누산기에 입력되면 제로 플래그를 1로 설정
   - 상태 레지스터(Status Register, SR), 프로그램 상태 워드(Program Status Word, PSW)라고도 함
- 데이터 레지스터(Data Register, 범용 레지스터)@
   - CPU내의 데이터를 일시적으로 저장하기 위한 레지스터
   - 고정 소수, 부동 소수로 구분하여 따로 저장하는 경우도 있으며, 
   - 어떤 프로세서는 상수 0 또는 1을 저장할 수 있도록 하는 레지스터도 있다.

인텔 x86 레지스터 종류 5-2-16

- 레지스터 전송(LOAD, STORE, MOVE 명령 등)
   - 3가지 레지스터 전송 명령 : LOAD, STORE, MOVE 

   - 인텔 프로세서는 이 세 가지를 MOVE 명령으로 모두 처리한다.
   - MOVE 명령어를 사용하여 데이터 교환이나 데이터형 변환이 가능하다


데이터 교환
- MOVE 명령을 세 번 사용하여 두 오퍼랜드를 교환할 수 있다. 
- 바이트 교환을 이용하여 빅 엔디안을 리틀 엔디안으로 또는 그 반대로 만들 수 있다.

데이터형 변환
- 크기가 작은 레지스터에 저장된 정수를 큰 레지스터로 이동하여 데이터형을 변환한다.
- 8비트→16비트, 16비트→32비트, 32비트→64비트 등


04  컴퓨터 명령어

- 명령어 형식
   - 연산 코드(opcode), 오퍼랜드(operand), 피연산자 위치, 연산 결과의 저장 위치 등 여러 가지 정보로 구성
- 0-주소 명령어
   - 연산에 필요한 오퍼랜드 및 결과의 저장 장소가 묵시적으로 지정된 경우 : 스택(stack)을 갖는 구조(PUSH, POP) 
   - 스택 구조 컴퓨터에서 수식 계산 : 역 표현 (reverse polish)

1-주소 명령어 
- 연산 대상이 되는 2개 중 하나만 표현하고 나머지 하나는 묵시적으로 지정: 누산기(AC)
- 기억 장치 내의 데이터와 AC 내의 데이터로 연산
- 연산 결과는 AC에 저장
- 다음은 기억 장치 X번지의 내용과 누산기의 내용을 더하여 결과를 다시 누산기에 저장
       ADD X	 ; AC ← AC + M[X]
- 오퍼랜드 필드의 모든 비트가 주소 지정에 사용: 보다 넓은 영역의 주소 지정
- 명령워드 : 16비트, Opcode: 5비트, 오퍼랜드(addr):  11비트  32(=25)가지의 연산 가능, 2048(=211)개 주소 지정 가능

2-주소 명령어
- 연산에 필요한 두 오퍼랜드 중 하나가 결과 값 저장
- 레지스터 R1과 R2의 내용을 더하고 그 결과를 레지스터 R1에 저장
- R1 레지스터의 기존 내용은 지워짐
      ADD R1, R2 		; R1 ← R1 + R2

3-주소 명령어
- 연산에 필요한 오퍼랜드 2개와 결과 값의 저장 장소가 모두 다름
- 레지스터 R2와 R3의 내용을 더하고 그 결과 값을 레지스터 R1에 저장하는 명령어다.
- 연산 후에도 입력 데이터 보존
- 프로그램이 짧아짐
- 명령어 해독 과정이 복잡해짐
      ADD R1, R2, R3 	; R1 ← R2 + R3

0-주소, 1-주소, 2-주소, 3-주소 명령을 사용하여 Z=(B+C)×A를 구현한 예
- 니모닉(mnemonic)   5-2-23
	ADD : 덧셈
	MUL : 곱셈
	MOV : 데이터 이동(레지스터와 기억 장치 간)
	LOAD : 기억 장치에서 데이터를 읽어 누산기에 저장
	STOR : AC의 내용을 기억 장치에 저장

명령어 형식 설계 기준명령어 형식
- 첫 번째 설계 기준 : 명령어 길이
   - 메모리 공간 차지 비율 감소
   - 명령어 길이를 최소화하려면 명령어 해독과 실행 시간에 비중을 둠
   - 짧은 명령어는 더 빠른 프로세서를 의미: 최신 프로세서는 동시에 여러 개의 명령을 실행하므로 클록 주기당 명령어를 여러 개 가져오는 것이 중요
- 두 번째 설계 기준 : 명령어 형식의 공간
   - 2^n개를 연산하는 시스템에서 모든 명령어가 n비트보다 크다.
   - 향후 명령어 세트에 추가할 수 있도록 opcode를 위한 공간을 남겨 두지 않음
- 세 번째 설계 기준 : 주소 필드의 비트 수
   - 8비트 문자를 사용하고, 주기억 장치가 232개
   - 메모리의 기본 단위
	- 4바이트(32비트)로 해야 한다고 주장하는 팀 : 0, 1, 2, 3, ..., 4,294,967,295인 232바이트 메모리 제안
	- 30비트로 해야 한다고 주장하는 팀: 0, 1, 2, 3, ...,1,073,741,823인 230워드 메모리 제안

확장 opcode    X
- 8비트 연산 코드와 24비트 주소를 가진 32비트 명령어
   - 이 명령어는 연산 28(=256)개와 주소 지정 224(=16M)개 메모리
- 7비트 연산 코드와 25비트 주소를 가진 32비트 명령어
   - 명령어 개수는 절반인 128개이지만 메모리는 2배인 225(=32M)개
- 9비트 연산 코드와 23비트 주소일 때
   - 명령어 개수는 2배(256), 주소는 절반인 2^23(=8M)개 메모리

명령어 길이 16비트, 오퍼랜드 4비트 시스템
- 모든 산술 연산이 레지스터(따라서 4비트 레지스터 주소) 16개에서 수행되는 시스템
- 한 가지 설계 방법은 4비트 연산 코드와 오퍼랜드가 3개 있는 3-주소 명령어를 16개 가지는 것


1. 3-주소 명령어는 14개, 2-주소 명령어는 30개, 1-주소 명령어는 31개, 0-주소 명령어는 16개가 필요하다면
   - [그림 4-11]과 같이 3-주소 명령어로 opcode 0~13을 사용
2. opcode 14~15를 다르게 해석
   - opcode 14와 opcode 15는 opcode 비트가 12~15(4비트)가 아닌 8~15(8비트)를 의미
   - 비트 0~3과 비트 4~7은 오퍼랜드(주소)를 2개 지정
   - 2-주소 명령어 30개는 왼쪽 4비트가 1110일 때, 비트 8~11은 
     0000에서 1111까지의 숫자를 지정하고, 왼쪽 4비트가 1111일 때는 비트 8~11은 0000에서 1101까지의 숫자 지정

3. 가장 왼쪽 4비트가 1111이고, 비트 8~11이 1110 또는 1111인 1주소 명령어
   - 비트 4~15가 opcode(12비트)임
   - 12비트인 opcode가 32개가 가능하지만 12비트 모두가 1인 1111 1111 1111은 또 다른 명령어로 지정
4. 상위 12비트가 모두 1인 명령어 16개를 0-주소 명령어로 지정  이 방법에서는 opcode가 계속해서 길어짐
   - 3-주소 명령어는 4비트 opcode
   - 2-주소 명령어는 8비트 opcode
   - 1-주소 명령어는 12비트 opcode
   - 0-주소 명령어는 16비트 opcode

- 확장 opcode는 opcode 공간과 다른 정보 공간 간의 균형을 보여 줌
- opcode를 확장하는 것이 예처럼 명확하고 규칙적이지 않음
- 다양한 크기의 opcode를 사용하는 기능은 두 가지 방법 중 하나로 활용
   - 첫째, 명령어 길이를 일정하게 유지 가능 
   - 둘째, 일반 명령어는 가장 짧은 opcode를, 잘 사용되지 않는 명령어는 가장 긴 opcode를 선택
- 장점 : 평균 명령어 길이 최소화
- 단점 : 다양한 크기의 명령어를 초래하여 신속한 해독이 불가하거나 또 다른 역효과 

코어 i7 명령어 형식 x
- 코어 i7 명령어 형식은 매우 복잡하고 불규칙
- 가변 길이 필드가 최대 6개 있으며 그 중 5개는 선택적
- CPU 구조가 여러 세대에 걸쳐 발전했고 초기의 잘못된 선택 때문
- 이전 버전과 호환성 고려로 되돌릴 수 없는 결과 발생


명령어 종류
- ISA(Instruction Set Architecture) 컴퓨터의 명령어 : 6개의 그룹
   - 컴퓨터에는 이전 모델과 호환성을 위해 추가된 몇 가지 특이한 명령어
   - 설계자의 좋은 아이디어 추가
   - 특정 기관에서 비용을 지불하고 명령어 추가

1. 데이터 이동 명령
2. 2항 연산
3. 단항 연산
4. 비교와 조건 분기 명령
5. 프로시저 호출 명령
6. 루프 제어 명령


데이터 이동 명령
- 가장 기본이 되는 작업 : 원본과 동일한 새로운 객체를 만드는 복사
- 원래 위치에 그대로 두고 다른 장소에 복사본 생성

 데이터를 복사하는 이유
1. 변수에 값 할당 : A=B는 메모리 주소 B의 값(데이터)을 A 장소로 복사한다는 의미다. 
2. 데이터의 효율적인 액세스 및 사용: 메모리와 레지스터 간에 데이터를 이동하여 프로그램 실행을 효율적으로 수행하기 위해서다. 
   - LOAD 명령 : 메모리에서 레지스터로 이동
   - STORE 명령 : 레지스터에서 메모리로 이동
   - MOVE 명령 : 하나의 레지스터에서 다른 레지스터로 이동
   단, 메모리 간 이동은 일반적으로 사용하지 않음


2항 연산
- 2항 연산은 오퍼랜드 2개를 결합하여 결과 생성
- 산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈) 및 논리 연산(AND, OR, XOR, NOR, NAND 등)
AND 연산 
- 워드에서 특정 비트를 추출하는 용도로 사용
- 예를 들어 8비트 문자가 4개 저장된 32비트 워드에서 3번째 문자(11010110) 만 남기고 나머지 세 문자를 제거하고 오른쪽으로 8비트 시프트
   - 먼저 3번째 문자(11010110)를 추출: 마스크 상수와 AND 연산
   - 단어의 오른쪽 끝에 추출할 문자를 분리: 오른쪽으로 8비트 시프트

OR를 마스크 연산과 함께 사용하여 원하는 위치에 값 교체 : 예를 들어 상위 24비트는 그대로 두고 하위 8비트 변경
- 필요 없는 8비트를 마스크 처리하여 없애고 새 문자를 OR 연산

- AND 연산은 1을 제거하는 마스크 연산
- OR 연산은 1을 삽입하는 연산
- XOR 연산은 대칭적이며, 어떤 값을 1로 XOR하면 반대(대칭) 값을 생성
   - 0과 1에 대칭적이라는 것은 때로 유용: 의사 난수 생성에 사용


단항 연산
- 단항 연산 : 오퍼랜드가 1개, 결과도 1개
- 2항 연산보다 명령이 짧지만, 명령에 다른 정보를 지정해야 할 때가 많음
시프트(shift)
- 비트를 왼쪽이나 오른쪽으로 이동하는 작업
- 워드의 끝부분에서 비트 손실 발생
회전(rotation)
- 한쪽 끝에서 밀린 비트가 다른 쪽 끝에서 다시 나타나는 이동
- 시프트와 회전의 차이


오른쪽 시프트는 흔히 부호와 함께 수행
- 즉, 워드의 MSB 부호는 그대로 유지한 채 오른쪽으로 시트프
- 특히 음수인 경우 그대로 음수 유지
- 2비트 오른쪽 시프트 예

시프트의 중요한 용도
- 2의 제곱수를 곱하는 것과 나누는 것
- 양의 정수가 왼쪽으로 k비트 시프트되었을 때 오버플로가 발생하지 않았다면 원래 수에 2k을 곱한 것
- 양의 정수를 오른쪽으로 k 비트 시프트했을 때 결과는 원래 수를 2k 로 나눈 것


시프트는 특정 산술 연산의 속도를 높이는 데 사용
- 예를 들어 어떤 양의 정수 n에 대해 24×n 을 계산
- 24×n =(16+8)×n =24×n +23×n 이므로, 
- n을 4비트 왼쪽으로 시프트하면 16×n이 되고, 
- n을 왼쪽으로 3비트 시프트하면 8×n
- 두 값의 합이 24×n
- 시프트 두 번 과 덧셈으로 계산되므로 곱셈보다 빠름

음수를 시프트하면 다른 결과가 됨   5-2-39
  -1의 2의 보수: 부호 확장을 사용하여 오른쪽으로 6비트 시프트하면 그대로 -1
  -1은 더 이상 오른쪽으로 시트프할 수 없음
  왼쪽 시프트는 한 비트씩 이동할 때마다 2를 곱한 결과


회전 연산은 워드의 모든 비트 테스트할 경우
- 한 번에 1비트씩 워드를 회전하면 각 비트를 MSB에 순서대로 배치하여 쉽게 테스트 가능
- 모든 비트가 테스트된 후에는 워드가 원래 값으로 복원
- 또는 레지스터 값을 직렬화할 때도 유용함

다른 단항 연산은 INC(1 증가), DEC(1 감소), NEG(2의 보수), NOT(비트 반전) 등
- NEG는 비트를 반전한 후 1을 더한 2의 보수
- NOT은 단순한 비트 반전으로 1의 보수












