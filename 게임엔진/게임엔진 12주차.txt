게임엔진 12주차



11.적 캐릭터 제작(1)

7,8번 9,10번 12,13,15번 다 중요
15번 특히 중요

개요

적 캐릭터 제작
자신만의 인공지능(AI)를 가지고 있어야 현실감 있는 게임

NPC의 인공지능 구현 @@ 시험에 나옴
FSM(Finite State Machine : 유한상태머신)
적 캐릭터가 스스로 알아서 주변환경에 적응, 들어오는 반응에 적절하게 반작용 하는 상태
생성되면 주변 순찰 - 플레이어를 만나면 추적 시작 - 사정거리 내에 근접하면 공격 시작 - 데미지를 입고 생명이 다하면 사망 

FSM의 단점
상태가 많아질 수록 상태와 상태간의 연결(Transition)이 복잡해 짐
코드의 확장과 유지 보수가 어려워짐
이러한 점을 보완히기 위해 계층적 유한상태 머신( HFSM : Hierarchical Finite State Machine)
행동 트리 (BT : Behavior Tree) 방식 개발 이루어짐
알고있으면 좋음


1. 메카님

메카님@@ 정의 중요
유니티의 애니메이션 상태머신 시스템, 애니메이션 미들웨어 엔진
FSM 상태에 따라 적절한 애니메이션 조작을 메카님을 이용하여 구현함
시각적인 설계방식을 제공함
Humanoid Type vs Generic Type
Humanoid : 팔(2개), 다리(2개), 머리(1개)를 가진 인간형 캐릭터 -> 리타겟팅(ReTargetting)시스템@@@을 사용하여 애니메이션을 공유 할 수 있음
예) 오크/ 엘프/ 사람 … 같은 애니메이션 공유
Generic : 인간형을 제외한 4족 보행동물, 슬라임과 같은 기타 메시등을 일컬음
리타겟팅 기능이 제공되지 않고 메카님을 이용하여 애니메이션 처리

Humanoid, Generic 타입 알아두기@@

idle 스테이트에서 walk스테이트 화살표 연결해주기
상방간에 화살표 만들어서 서로 연결해서 사용@
항상 사용
하지만 그럴려면 파라미터가 필요하다
Bool과 Trigger가 많이 사용된다

Bool로 isTrace로 만들어주고
True가 되면 walk가 되는것
isTrace를 코드에서 사용한다.

그리고 Has Exit Time을 체크해제 해준다
체크하면 - 프레임이 끝난다음에 다른 애니메이션으로 연출
체크해제 - 바로 애니메이션이 멈춤 realtime 애니메이션으로 해줘야함

Transition Duration 0.25 - 프레임이 다 끝나지않고 25%된 상태에서 Transition을 하겠다는소리


스테이트 전이와 파라미터

상태 전이 (idle -> Walk) 구현
walk 상태 노드를 위치시킨 후 idle 노드에서 오른쪽 마우스 클릭, Make Transition 선택
왼쪽의 Parameter탭에서 Bool 타입의 변수 생성(변수명 ; IsTrace) 
IsTrace (true) : idle ->walk 로 전이
IsTrace (false) : walk -> idle 로 전이


4. 애니메이터 컨트롤러

Has Exit Time 속성
속성이 체크되면 즉각적인 상태 전이가 일어나지 않고 애니메이션이 다 끝난 다음 다음 상태로 변경 됨, 화살표를 클릭하면 Inspector창에서 확인 가능함
Conditions속성에서 IsTrace 변수에 true로 설정
IsTrace 변숫값이 true가 되면 바로 전이를 발생시키기 위해 Has Exit Time 속성을 언체크 함


네비게이션 - 몬스터 추적 루틴

네비게이션 기능 
기존의 길찾기 알고리즘(Path Finding, A*)을 대처, 유니티에서 독자적으로 제공
3D 메쉬정보를 분석해 걸어갈수 있는 영역과 지나갈 수 없는 영역으로 구분한 정보를 바탕으로 런타임시 그 정보를 활용하여 최단거리 를 계산해 추적할 수 있게 하는 기능
네비게이션 설정 및 베이크 (미리 만들어 놓음)
네비게이션을 베이크 하려면 Floor의 Static 옵션을 Navigation Static으로 바꿈(모두 static 으로 바꾸는 것이 아님) -> Navigation Flag 설정


유한상태머신 - 적캐릭터의 상태 체크

FSM 은 자신의 상태 값을 갖고 있어야 하며 현재 어떤 상태인지 갱신하고 해당 상태에 맞는 행동을 취해야 한다. 
적 캐릭터의 상태를 순찰(Idle)/추적(Trace)/공격(Attack)/사망(Die) 으로 정의한다. 


While(1){} 을 감싸주면 코루틴과 쓰레드가 관리해주는 역할이다





using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MonsterCtrl2 : MonoBehaviour
{
    private Transform monsterTr;
    private Transform playerTr;
    private UnityEngine.AI.NavMeshAgent nvAgent;

    public enum State { IDEL, PATROL, TRACE, ATTACK, DIE }

    //몬스터의 현재 상태
    public State state = State.IDEL;
    //추적 사정거리
    public float traceDist = 10.0f;
    //공격 사정 거리
    public float attackDist = 2.0f;
    //몬스터의 사망 여부
    public bool isDie = false;

    void Start()
    {
        //몬스터의 Transform 할당
        monsterTr = this.gameObject.GetComponent<Transform>();
        //추적 대상인 Player의 Transform 할당
        playerTr = GameObject.FindWithTag("Player").GetComponent<Transform>();

        //NavMeshagent 할당
        nvAgent = this.gameObject.GetComponent<UnityEngine.AI.NavMeshAgent>();

        //추적 대사으이 위치를 설정하면 바로 추적 시작
        //nvAgent.destination = playerTr.position;
        //nvAgent.SetDestination(PlayerTr.posiiton)

        //몬스터의 상태를 체크하는 코루틴 함수
        StartCoroutine(checkMonsterState());
    }

    IEnumerator checkMonsterState()
    {
        while (!isDie)
        {
            yield return new WaitForSeconds(0.3f);  //while문을 빠져나가는걸 만들어줘야함 아니면 유니티 멈춤
                                                    //0.3초 동안 중지(대기) 하는 동안 제어권을 메세지 루프에게 전달

            //몬스터와 주인공 캐릭터 사이의 거리 측정
            float distance = Vector3.Distance(playerTr.position, monsterTr.position);

            //공격 사정거리 안으로 들어왔는지 확인
            if(distance <= attackDist)      //2
            {
                state = State.ATTACK;       //상태 전환 -> 공격 상태
            }
            //추적 사정거리의 범위로 들어왔는지 확인
            else if(distance <= traceDist)  //10
            {
                state = State.TRACE;    //추적 상태
            }
            else
            {
                state = State.IDEL;     //IDEL 상태
            }
        }
    }

    void OnDrawGizmos()
    {
        //추적 사정거리 표시
        if(state == State.TRACE)
        {
            Gizmos.color = Color.blue;
            Gizmos.DrawWireSphere(transform.position, traceDist);
        }
        //공격 사정거리 표시
        if(state == State.ATTACK)
        {
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(transform.position, attackDist);
        }
    }

    // Update is called once per frame
    void Update()
    {

    }
}
State 상태변환 굉장히 중요 @@ 재밌어보인다.




    IEnumerator MonsterAction()
    {
        while (!isDie)
        {
            switch (state)
            {
                case State.IDEL:    //IDEL 상태
                    nvAgent.isStopped = true;   //추적 중지
                    break;
                case State.TRACE:   //TRACE(추적) 상태
                    nvAgent.SetDestination(playerTr.position);  //추적 대상의 좌표로 이동 시작 (위치 갱신)
                    nvAgent.isStopped = false;  //따라가기 시작
                    break;
                case State.ATTACK:  //공격 상태
                    break;
                case State.DIE:     //사망 상태 
                    break;
            }

            yield return new WaitForSeconds(0.3f);  //while문을 빠져나가는걸 만들어줘야함 아니면 유니티 멈춤
        }
    }
이 상태 잘 알아두기 시험에 나옴@@@



using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class MonsterCtrl2 : MonoBehaviour
{
    //컴포넌트 캐쉬를 처리할 변수
    private Transform monsterTr;
    private Transform playerTr;
    private UnityEngine.AI.NavMeshAgent nvAgent;
    private Animator anim;

    public enum State { IDLE, PATROL, TRACE, ATTACK, DIE }

    //몬스터의 현재 상태
    public State state = State.IDLE;
    //추적 사정거리
    public float traceDist = 10.0f;
    //공격 사정 거리
    public float attackDist = 2.0f;
    //몬스터의 사망 여부
    public bool isDie = false;


    void Start()
    {
        //몬스터의 Transform 할당
        monsterTr = this.gameObject.GetComponent<Transform>();
        //추적 대상인 Player의 Transform 할당
        playerTr = GameObject.FindWithTag("Player").GetComponent<Transform>();

        //NavMeshagent 할당
        nvAgent = this.gameObject.GetComponent<UnityEngine.AI.NavMeshAgent>();

        //추적 대사으이 위치를 설정하면 바로 추적 시작
        //nvAgent.destination = playerTr.position;
        //nvAgent.SetDestination(PlayerTr.posiiton)

        //동시에 실행 (1개는 상태를 조사, 1개는 액션처리-애니메이션, 따라가기)
        //몬스터의 상태를 체크하는 코루틴 함수
        StartCoroutine(checkMonsterState());
        //상태에 따라 몬스터의 행동을 수행하는 코루틴 함수 호출
        StartCoroutine(MonsterAction());

        anim = GetComponent<Animator>();
    }

    IEnumerator checkMonsterState()
    {
        while (!isDie)
        {
            yield return new WaitForSeconds(0.3f);  //while문을 빠져나가는걸 만들어줘야함 아니면 유니티 멈춤
                                                    //0.3초 동안 중지(대기) 하는 동안 제어권을 메세지 루프에게 전달

            //몬스터와 주인공 캐릭터 사이의 거리 측정
            float distance = Vector3.Distance(playerTr.position, monsterTr.position);

            //공격 사정거리 안으로 들어왔는지 확인
            if(distance <= attackDist)      //2
            {
                state = State.ATTACK;       //상태 전환 -> 공격 상태
            }
            //추적 사정거리의 범위로 들어왔는지 확인
            else if(distance <= traceDist)  //10
            {
                state = State.TRACE;    //추적 상태
            }
            else
            {
                state = State.IDLE;     //IDLE 상태
            }
        }
    }
    IEnumerator MonsterAction()
    {
        while (!isDie)
        {
            switch (state)
            {
                case State.IDLE:    //IDLE 상태
                    nvAgent.isStopped = true;   //추적 중지
                    //Animator의 IsTrace 변수를 false로 설정
                    anim.SetBool("IsTrace", false); //추적 -> 아이들 상태
                    break;
                case State.TRACE:   //TRACE(추적) 상태
                    nvAgent.SetDestination(playerTr.position);  //추적 대상의 좌표로 이동 시작 (위치 갱신)
                    nvAgent.isStopped = false;  //따라가기 시작
                    //Animator의 IsTrace 변수를 true로 설정
                    anim.SetBool("IsTrace", true);  //아이들 -> 추적 상태
                    break;
                case State.ATTACK:  //공격 상태
                    break;
                //case State.DIE:     //사망 상태 
                    //break;
            }

            yield return new WaitForSeconds(0.3f);  //while문을 빠져나가는걸 만들어줘야함 아니면 유니티 멈춤
        }
    }

    void OnDrawGizmos()
    {
        //추적 사정거리 표시
        if(state == State.TRACE)
        {
            Gizmos.color = Color.blue;
            Gizmos.DrawWireSphere(transform.position, traceDist);
        }
        //공격 사정거리 표시
        if(state == State.ATTACK)
        {
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(transform.position, attackDist);
        }
    }
}



Settings의 
gohit -> idle
Exit Time을 0.9로 해준다


















